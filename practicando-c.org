#+TITLE: Practicando C
* Practicando en C
** Aritmética de Punteros + ungetc + valorL no modificable
#+BEGIN_SRC C
  #include <stdio.h>
  #include <ctype.h>
  #include <stdlib.h>
  #include <string.h>

  int main(){
          int *ptr1 = malloc(sizeof(int));
          int* const ptr2 = malloc(sizeof(int));
          // el ptr2 si lo pasamos a cadena de caracteres, sería similar a lo siguiente
          // char* const palabra = "hola"; // <-- no puede cambiar su dirección de memoria
          // char palabra[30] = "hola"; // <- se reservó memoria en stack, no puede cambiar
          const int *ptr3 = malloc(sizeof(int));
          int numero2= 2, numero3= 3;

          ,*ptr1 = 1;
          printf("ptr1: %d\n", *ptr1);

          ,*ptr1 = numero2;
          printf("ptr1: %d\n", *ptr1);

          ptr1 = &numero3;
          // free(ptr1); // <-- este free tiraría error, porque ahora apunta al stack
          printf("ptr1: %d\n", *ptr1);

          ,*ptr2 = numero2;
          printf("ptr2: %d\n", *ptr2);

          // - esto arrojaría error, porque al declarar ptr2 dijimos que
          // no puede apuntar a otra dirección de memoria..
          // - int* const ptr2: ptr2 es una constante del tipo puntero a entero
          // (no puede cambiar la dirección de memoria)
          // - const int* ptr1: ptr1 es un puntero a entero que es constante 
          // (no puede cambiar el valor)
          //
          // ptr2 = &numero2;

          // lvalue no modificables, por ser const
          const int n1 = 5; // constante entera, no se puede modificar su valor después
          int const n2 = 5; // apunta a 5, y no puede cambiar su dirección x tanto tmpc su valor
          // ambos darán error "asignación a variable de sólo lectura"
          //n1 = 2;
          //n2 = 1;

          // --------------------------------------------------------------------

          char* cadena = malloc(sizeof(char)*100);
          char* palabra = "hola";
          // si no me equivoco.. los dos de abajo son lo mismo, no pueden cambiar su dirección en memoria
          // char* const palabra = "hola";
          // char palabra[30] = "hola";

          char *aux1=palabra, *aux2=palabra, *aux3=palabra;
          // errores xd
          //char aux1=malloc(sizeof(char)*100), aux2=malloc(sizeof(char)*100),aux3=malloc(sizeof(char)*100);
          //*aux1=palabra, *aux2=palabra, *aux3=palabra;

          // alternativa #1:
          // - while: ejecuta mientras el valor al que apunta aux1 no sea FIN de cadena
          // - printf: sólo imprime el valor al que referencia aux2
          // - aux2++: avanza a la sig. dirección usando arimética de punteros
          // (avanza a la sig. dirección, saltando N bytes como el tamaño de sizeof(char))
          printf("aux2: ");
          while(*aux2 != '\0') printf("%c", *aux2), aux2++; // <- usamos el , quedando una sentencia expresion
          //while(*aux2 != '\0'){ printf("%c", *aux2); aux2++; } // <- si usaramos sentencia compuesta
          aux2='\0';
          printf("\n");

          // alternativa #2:
          // - while: idem alternativa (1)
          // - printf: imprime el valor al que referenia aux1 y avanza a la sig. dirección
          printf("aux1: ");
          while(*aux1 != '\0') printf("%c", *aux1++);
          aux1='\0';
          printf("\n");

          // alternativa #3:
          // - while: itera mientras el puntero referencia a un valor, cuando sea NULL se detiene
          // - printf y aux3++ igual que los anteriores
          printf("aux3: ");
          while(*aux3){ printf("%c", *aux3), aux3++; }
          printf("\n");

          printf("\n");
          // aux1,aux2,aux3 apuntan a null... si queremos que devuelvan el string original
          // podriamos hacer que vuelvan a apuntar a la dirección de "palabra" si... (???)
          printf("aux1=%s, aux2=%s\n", aux1, aux2);
          free(aux1), free(aux2);
          //free(0); // <-- (???) no arroja error
          printf("palabra=%s\n", palabra);
          //*cadena++ = 'a';

          // --------------------------------------------------------------------

          int c;
          int i = 0;
          // mientras no sea un digito, le permite escribir
          // ó getc(stdin)
          char texto[500];

          while(!isdigit(c = getchar())){
                  //puts(c);
                  //*cadena++=c;
                  texto[i]=c;

                  //fprintf(stdout, "%c", c);
                  //
                  //fflush(stdin); // no es necesario...?
                  i++;
          }

          ungetc('#', stdout);
          printf("texto=%s\n", texto);

          return 0;
  }
#+END_SRC
** Orden de Evaluación de operadores (Asociatividad+Precedencia)
   #+BEGIN_SRC C
     #include <stdio.h>

     int main(void){
       int menor = 10;
       int mayor = 500;

       printf("valor=%d\n", menor ++> mayor); // lo interpreta: (menor++) > mayor
       printf("valor=%d\n", menor >++ mayor); // lo interpreta: menor > ++mayor
       printf("valor=%d\n", menor ++>++ mayor); // lo interpreta: menor++ > ++mayor
       // printf("valor=%d\n", menor++++); // ERROR sintáctico lvalue (menor++)++  
       // printf("valor=%d\n", menor+++++mayor); // ERROR sintáctico lvalue (menor++)++ + mayor

       printf("valor=%d\n", menor+++mayor); // lo interpreta: menor++ + mayor

       printf("valor=%d\n", menor --> mayor); // lo interpreta: (menor--) > mayor
       printf("valor=%d\n", (10-1) > 500); // sería lo mismo que esto

       printf("valor=%d\n", menor --< mayor); // lo interpreta: (menor--) < menor
       printf("valor=%d\n", (10-1) < 500); // sería lo mismo que esto



       printf("menor=%d, mayor=%d\n", menor, mayor);

       return 0;
     }
   #+END_SRC
** Puntero a Struct + Operador Ternario + Arimética de Punteros
   #+BEGIN_SRC C
     #include <stdio.h>
     #include <stdlib.h>
     #include <string.h>

     struct { int finales[3]; } automata1;
     struct { int* finales; } *automata2;

     struct {int x, y;} posicion;
     int main(){
             int arr[5];
             arr;
             //arr = 5;
             //arr[0] = 1;

             posicion.x = 5, posicion.y=10;
             printf("x=%d, y=%d\n", posicion.x, posicion.y);

             int const numero;
             // numero = 5;

             /*
             static int pepe;
             auto int pope;
             // static auto int pape;

             //int double valor;
             int _5;
             _5 = 2;

             int a,b,c;

             a=1,b=1;

             c = &a == &b ? b : a;

             printf("c=%d\n", c);

             printf("condicion 2 = %d\n", (0 == 1) ? 0 : 1); // 1
             printf("condicion 1 = %d\n", (0 == 0) ? 0 : 1); // 0

             printf("condicion 2 = %d\n", 0 == 1 ? 0 : 1); // 1
             printf("condicion 1 = %d\n", 0 == 0 ? 0 : 1); // 0

             printf("condicion 3 = %d\n", 2 ? 0 : 1); // 0
             printf("condicion 4 = %d\n", -1 ? 0 : 1); // 0
             ,*/

             /*
             automata1.finales[0] = 10;

             automata2 = malloc(sizeof(automata2));
             automata2->finales = malloc(sizeof(int)*3);
             automata2->finales[0] = 10;
             automata2->finales[1] = 6;

             printf("automata1.finales[0]=%d\n",automata1.finales[0]);
             //printf("automata2->finales[0]=%d\n",automata2->finales[0]);
             printf("automata2->finales[0]=%d\n", *(automata2->finales));
             printf("automata2->finales[1]=%d\n", *(automata2->finales+1));

             ++automata2->finales;
             ,*/

             char* cadena = malloc(sizeof(char)*4); // 3char + 1 (por el \0)
             strcpy(cadena, "ABC");

             /*
             printf("cadena=%s\n", cadena);

             cadena++; // cadena++; != cadena+1; (el segundo no es arimética de ptr)
             printf("cadena=%s\n", cadena);

             //cadena+1 = 'm';
             printf("p=%p, p+1=%p\n", cadena, cadena+1);
             printf("cadena=%s\n", cadena);
             ,*/

             free(cadena);

             // -----------------------------------------------

             char v[] = "ABC"; // <- v[3] tiene NULL osea \0

             printf("%p\n", v);
             printf("%p\n", v+1);
             printf("%p\n", v+2);
             printf("%c\n", v+1);

             //v+1 = 'm';

             v<v+1;

             /*
             printf("v[2] = %p\n", v[2]);
             printf("v[2] = %c\n", v[2]);
             printf("v[2] = %c\n", *(v+2));

             printf("v[] = %s\n", v);

             printf("*v: %c\n", *v);

             v+1;
             //v+1 = 'm';
             // v++; // <- no se puede no es lvalue, a menos que haga char* v;
             printf("*v: %c\n", *v);

             ,*v = 'z'; // es lo mismo que v[0] = 'z';
             printf("*v: %c\n", *v);

             printf("v[] = %s\n", v);

             //v+1 = 'z';
             ,*/

             return 0;
     }
   #+END_SRC
** Structs + Identificadores Vs Constantes Enteras/Reales
   #+BEGIN_SRC C
     #include <stdio.h>

     /*
     // alternativa #1

     // - declaramos una variable X del tipo estructura anónima,
     // porque no tiene identificador (se agrega luego de struct)
     // - no nos permite agregar otra sentencia creando un arreglo de 
     // esta estructura anónima, porque no tiene nombre
     // (X es el una variable del tipo struct, no es el struct en si)
     //
     // struct { int y; } X, Y[50]; <- podemos declarar un arreglo, pero con otro identificador que no sea X
     struct { int y; } X;

     // - declaramos una estructura "B" (identificador)
     // - declaramos una variable "Y" del tipo "struct B"
     // - podemos agregar otra sentencia declarando un arreglo "struct Y[50]"
     struct B{ int c; } Y;

     ,*/

     // -----------------------------------------------------------------

     struct B{ int c; }; // Ojo! no es lo mismo que struct { int c; } B;
     struct {struct B b[50]; } a;

     // alternativa #2
     //typedef struct { int c; } B;
     //struct { B b[50]; } a;

     // alternativa #3
     //struct { struct {int c;} b[50]; } a;
     // struct { struct { int c; } b[50]; } a;

     struct {
             // static int z;
     } Z;

     struct M{ int n; }; // declaramos la estructura llamada M
     struct M m; // declaramos una variable m del tipo M

     // interesante...!
     struct { struct{ int x, y; }posicion[50]; } posiciones={0};

     int main(){
             posiciones.posicion[40].x = 5;
             posiciones.posicion[40].y = 2;
             printf("posiciones.posicion[40].x=%d\n", posiciones.posicion[40].x);
             printf("posiciones.posicion[40].y=%d\n", posiciones.posicion[40].y);

             printf("posiciones.posicion[50].x=%d\n", posiciones.posicion[50].x);
             printf("posiciones.posicion[50].y=%d\n", posiciones.posicion[50].y);
             printf("\n\n");
             // a.b[40].c = 5;
             // printf("a.b[40].c=%d\n\n", a.b[40].c);

             int LU = 2;
             int a = 0;
             //a = 1LU++LU;

             printf("a=%d\n", a);
             a+++1;
             printf("a=%d\n", a);
             a++ +1;
             printf("a=%d\n", a);

             float x = 5001, y = .1, z=0LU;

             printf("x=%f\n", x);
             printf("x=%.2f\n", x);
             printf("x=%5.2f\n", x);

             printf("\n");

             printf("y=%f\n", y);
             printf("y=%.2f\n", y);
             printf("y=%3.2f\n", y);

             return 0;
     }
   #+END_SRC
** Scope/Ambito + Unidad de Traducción + Errores Semánticos
   #+BEGIN_SRC C
     #include <stdio.h>

     // - Scope: dentro de la definición de la función test()
     void test(void){
       struct { int x; } m;  // <- "m" es el identificador del struct
       // int m; // <-- Error semántico.! identificadores comparten namespaces

       enum {A,B} letras;
       // int A; // <-- Error semántico.! enum e identificadores comparten namespaces
     }

     // - Scope: Unidad de traducción (generado por el .c + .h)
     enum {A,B} letras;

     int main(void){
       // tag: test1
      test1: return 1; // etiqueta "test1"

       // etiqueta "test2"
      test2:
       return 2;

       return 0;
     }
   #+END_SRC
** Scope/Ambito + Punteros
   #+BEGIN_SRC C
     #include <stdio.h>

     int* f2(int x){ int *p; return p; }

     int* f3(int x){
       static int i = 0;
       i = 5 + x;

       // - si retornamos &x arrojará warning,
       // por devolver la dirección de una var local que
       // deja de existir cuando se termina de evaluar esta función
       // - si retornamos una variable "static" no hay problema
       // porque su ciclo de vida finaliza con el programa
       return &i;
     }

     char* f1(int x){
       static char* palabra = "hola";
       return palabra+x;
     }

     int main(void){
       char* x = f1(2);
       printf("palabra: %s\n", x);

       int* p = f2(5);
       p = f3(0);

       return 0;
     }
   #+END_SRC
** Expresiones validas, Evaluar expresiones, Operadores (Precedencia y Asociatividad)
   #+BEGIN_sRC C
     #include <stdio.h>

     int f(int x){ return x; }
     int f2(int x, int y){ return x; }

     enum {INICIAL=1, FINAL} state;

     const struct {int x; int y;} Posicion[10];
     struct {const int x; const int y;} Position[10];

     typedef int EDAD, NUMERO;

     struct { int edad; } pedro;

     int main(void){
             pedro = 1 < 1;

             {1+1;}; 5;

             int m = {9}; // se le asigna 9
             {m=0;}; // se lo cambiamos a 0
             printf("m=%d\n", m);

             int n = {9+1}; +5; 0+0; {1+2;}; // se le asigna 9+1,
             printf("n=%d\n", n);

             int a,b,c;
             a=b=c=1;
             {a=b=c=2;};
             printf("a=%d, b=%d, c=%d\n", a , b , c);

             NUMERO primero = 5;
             EDAD edad = 11;
             unsigned x;
             x = -1;
             printf("x=%d\n", x);

             printf("0<0<-1 = 0<-1 = %d\n", 0<0<-1);
             printf("0>-1 = %d\n", 0>-1);

             printf("2<0<1 = (2<0)<1 = 0<1 = %d\n", 2 < 0 < 1); // stdout = 1
             printf("2<0<0 = (2<0)<0 = 0<0 = %d\n", 2 < 0 < 0); // stdout = 0
             printf("3<2<1 = (3<2)<1 = 0<1 = %d\n", 3 < 2 < 1); // stdout = 1
             printf("\n");

             /*
             // l value no modificable
             Posicion[0].x = 0;
             Posicion[0].y = 0;

             // l value no modificable
             Position[0].x = 0;
             Position[0].y = 0;
             ,*/

             // -------------------------------------------------

             // int EOF = 1;
             int letra;
             letra = 'a';
             printf("letra=%c\n", letra);
             printf("sizeof(int)=%d, sizeof(char)=%d\n", sizeof(int), sizeof(char));

             printf("state=%d\n", state);
             state = INICIAL;
             printf("state=%d\n", state);
             state = FINAL;
             printf("state=%d\n", state);

             // -------------------------------------------------

             f; // <- sólo arroja warning de que no tiene efecto esa declaración
             f, f2;
             f(2);

             printf("%d\n", f(10));

             return 0;
     }
   #+END_SRC
** Evaluación de expresiones con Operadores como prefijo y sufijo
   #+BEGIN_sRC C
     #include <stdio.h>

     int main(void){
       char nombre[10] = "hol\";

       // empieza por 1
       for(int i=1; i < 5; i++) printf("%d ", i);
       printf("\n");
       // empieza por 1
       for(int i=1; i < 5; ++i) printf("%d ", i);

       printf("\n");

       int x,y,z; x=y=z=0;

       // incrementa x en 1, luego que la expresión y=x sea evaluada
       y = x++, printf("x=%d, y=%d\n", x, y);
       printf("x=%d\n", x);
       // incrementa x en 1, antes que la expresión z=x sea evaluada
       z = ++x, printf("x=%d, z=%d\n", x, z);
       /*
         int a=0, b=a++, c=a++;
         printf("a=%d, b=%d, c=%d\n", a,b,c);
         printf("a=%d, b=%d, c=%d\n", a,b,c);
       ,*/

       printf("\n");
       return 0;
     }
   #+END_SRC
** Punteros + Simbolos como Punctuator/Operador + Operadores Precedencia y Asociatividad
   #+BEGIN_SRC C
     #include <stdio.h>

     int true(int x){
             printf("true: %d\t", x); return 1;
     }
     int false(int x){
             printf("false: %d\t", x); return 0;
     }
     int sumar(int x, int y){ return x+y; }

     int main(void){
             false(0) || false(1) && false(2); // exp1 || exp2 => 0
             printf("\n");

             true(0) || false(1) < false(2); //  exp1 <-- no llega a evaluarse exp2<exp3
             printf("\n");

             false(0) || false(1) < false(2); // exp1 || exp2 < exp3 => 0
             printf("\n");

             printf("1+1*2=%d\n", 1+1*2); // exp1+(exp2*exp3) => exp1+exp4 => 3

             printf("\n------------------------------------\n\n");
             // ---------------------------------------------------

             for(int i=0,a=0,b=0; i < 10; a+=2, b+=3, i++) printf("i=%d, a=%d, b=%d\n", i, a, b);

             printf("\n------------------------------------\n\n");

             char cadena[50] = "hola", cadena2[50]="chau", *aux;

             aux = cadena;
             printf("cadena=%s, aux=%s\n", cadena, aux);
             printf("cadena=%s, aux[0]=%c\n", cadena, aux[0]);
             printf("cadena=%s, aux=%s\n", cadena, ++aux);

             aux = cadena;
             printf("cadena=%s, aux=%s\n", cadena, (++aux, ++aux, ++aux));


             aux=cadena;
             printf("aux=%s\n", aux);
             // 1) desreferenciamos la 1ra dirección del puntero a caracteres (el 1º caracter)
             // 2) desreferenciamos la 2da dirección del puntero a caracteres (el 2º caracter)
             ,*(aux+0) = 'x', *(aux+1) = 'x';
             // En vez de "hola" imprimirá "xxla"
             printf("aux=%s\n", aux);
             // como el ptr 'aux' apuntaba a 'cadena', tenía la misma dirección de memoria
             // por tanto los cambios en aux, afectaban a cadena
             printf("cadena=%s, aux=%s\n", cadena, aux);

             int numbers[10] = {2, 4, [2 ... 9] = 0};
             for(int i=0; i < 10; i++) printf("%d ", numbers[i]);
             printf("\n");

             // arr[3]={[0 ... 2]=0} es equivalente a arr[0]=0, arr[1]=0, arr[2]=0;
             int numeros[5] = {[0 ... 2]=0, [3 ... 4]=1}; // equivale a numeros[5]={0,0,0,1,1}
             for(int i=0; i < 5; i++) printf("%d ", numeros[i]);
             printf("\n");


             aux=cadena;
             for(int i=0; *aux=cadena[i]; i++, aux++) printf("%c, ", *aux);
             //for(int i=0; *aux++=cadena[i]; i++, aux++) printf("%c, ", *aux);
             printf("\n");

             int i;
             for(i=0, aux=cadena; *aux; *aux++=cadena[i], i++) printf("%c, ", *aux);

             //while(*aux++) printf("%c, ", *aux); printf("\n");
             //printf("cadena=%s, aux=%s\n", cadena, aux);

             printf("\n------------------------------------\n\n");
             // ---------------------------------------------------

             aux = cadena2;
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             for(int i=0; *aux=cadena2[i]; i++, aux++) printf("%c, ", *aux);
             printf("\n");

             // - como en el for hacíamos aux++ avanzabamos a
             // a la sig. dirección del bloque al que hace referencia (cadena2)
             // - terminado el for, aux apuntará a la última dirección de cadena2, osea al fin de cadena
             // por tanto no imprimirá nada
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             //*aux--='y'; // es equivalente a *(aux--)='y'

             // si hacemos +aux-- apuntamos a la dirección anterior de cadena2,
             // osea retrocedemos al caracter anterior de fin de cadena
             // *aux--; // equivale a *(aux--);
             //printf("cadena2=%s, aux=%s\n", cadena2, aux);

             // - cuando avanzamos aux++ en realidad avanzamos en el array cadena1, pero en aux
             // - avanzamos aux a la sig. dirección que apunta de cadena2, desreferenciamos y le asignamos
             // el caracter 'z' (osea cambiamos el valor a cadena2, no al puntero)
             ,*aux++='z'; // es equivalente a *(aux++)='z'
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             // *(aux++)='y' no es equivalente a aux++,*aux='y'
             // - al ptr le asignamos el caracter 'y' (esto genera efecto en cadena2 también)
             //aux++, *aux='y';
             ,*aux='y';
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             // cambiamos el valor al que apunte ptr (genera efecto sobre cadena2 también)
             ,*aux='m';
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             ,*(aux++)='Z';
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             printf("\n------------------------------------\n\n");
             // ---------------------------------------------------

             1+1, 2||2, 1||printf("a"), 0|printf("b"), 'a', 1, printf("\n");


             // usamos la ',' como operador, para agrupar expresiones
             printf("%d\n", (1,2,10)); // stdout 10, usa la ultima subexp que evaluó

             // usamos la ',' como caracter de puntuación para separar expresiones
             // (por lo general para pasar parámetros a una función)
             sumar(1,2);

             // usamos la ',' como operador y caracter de puntuación
             // - usamos los '(',')' como operador para agrupar las subexpresiones 1,2,10
             // en una expresion y evitar que arroje error semántico por no coincidir con la firma de la función
             // - del 2do parámetro se evaluará cada subexpresión, 
             // pero sólo la última que será que se pasará por parametro a la función
             sumar(1, (1,2+1,'a', "abc", printf("omg\n"),10)); 
             return 0;
     }
   #+END_SRC
** Identificadores Válidos + Tipos de Constantes
   #+BEGIN_SRC C
     #include <stdio.h>
     #include <string.h>

     struct{char*a;int i;}s1,s2;
     struct{char* a;float i;}m1;

     int main(void){
             char _; _ = 'a';
             printf("_=%c\n", _);

             char __;
             // la expresión del 2do parámetro, se evalúan las subexpresiones de izq a der.
             // 1) se evalúa la expresión de asignación __='b'
             // 2) se evalúa la expresión de asignación __='c'
             // 3) se evalúa la expresión lógica __ < 0 (el valor del identificador __ es el de la tabla ascii)
             // 4) se evalúa la expresion __ (identificador)
             //
             // del 2do parámetro las expresiones son agrupadas por el operador () y , (coma)
             // se evalúan de izq a der. y sólo la última será la que usará printf como 2do parámetro
             printf("__=%c\n", (__='b', __='c', __ < 0, __)); // todo ok, sin errores

             printf("\n");
             // -----------------------------------------------

             int a=15, b=0xF, c=017, z=0L;
             printf("15(entero decimal)=%d\n", a);
             printf("0xF(entero hexadecimal)=%d\n", b);
             printf("017(entero octal)=%d\n",c);
             printf("0L (entero, long)=%d\n", z); // <- decimal u octal (???)
             printf("\n");

             float d = .1, f=10., g=10.50, h;
             printf(".1 (numero real con precisión simple)=%f=%.2f=%2.1f\n", d);
             printf("10. (numero real con precisión simple)=%2.3f\n", f);
             printf("10.50 (numero real con precisión simple)=%.1f\n", g);
             printf("\n");

             double i; // precisión doble
             // -----------------------------------------------

             // esto es un doble puntero, (char**) un array de strings
             // capacidad hasta 2 strings, 
             // no limitamos la longitud de los strings
             char* cadena1[2] = {"hola", "chau"};
             printf("cadena1[0]=%s, cadena1[1]=%s\n",
                     cadena1[0], cadena1[1]);
             //strcpy(cadena[0], "hola");
             //char* cadena[10] = "hola";
             //cadena = "hola";

             // este otro también es un doble puntero (const char **) ???
             // pero limitamos la long. de los strings a 30 caracteres
             char cadena2[2][30] = {"hola", "chau"};
             printf("cadena2[0]=%s, cadena2[1]=%s\n",
                     cadena1[0], cadena1[1]);
             // -----------------------------------------------

             s1.a = "hola", s1.i = 0;
             //m1.a = "hola", m1.i = 0;

             printf("s1.a=%s, s1.i=%d, s1.a[s1.i]=%c\n",
                     s1.a, s1.i, s1.a[s1.i]);

             //printf("m1.a=%s, m1.i=%d, m1.a[m1.i]=%c\n",
             //      m1.a, m1.i, m1.a[m1.i]);

             return 0;
     }
   #+END_SRC
** Jugando con Printf
   #+BEGIN_sRC C
     #include <stdio.h>

     int main(void){
       // al evaluar esta sentencia compuesta, no evalúa el resto del código
       // {return 0;} 

       void x(); // mmh

       void *a=NULL, *b=(int*)5;

       (void) 1; 2 + 1, 2+a;
       1+NULL;

       printf("3+a=%d\n", 3+a); // 3+NULL = 3

       printf("3+a=%d\n", (a=(int*)5, 3+a)); // a=5 => 3+5 = 8

       // el NULL lo toma como 0 (?)
       printf("2+NULL=%d\n", 2+NULL); // 2+NULL = 1
       printf("9+\'\\0\'=%d\n", 9+'\0'); // 9+'\0'= 9

       printf("2+b=%d\n", 2+b); // 3+5 = 8

       // mmmh...
       printf("%d, %d, %d\n", (int*)b, 1+(int*)b, sizeof(int));

       return 0;
     }
   #+END_SRC
** Precedencia de Operadores y Expresiones Sintacticamente Correctas
   #+BEGIN_SRC C
     #include <stdio.h>
     #include <stdlib.h>

     //struct { S s;}S;
     //struct S{ struct S x; };

     struct P{}; struct { struct P x; } p;

     int a(){}; //int(*)() = &a; // anda

     struct { int b; } arr[10];
     const struct { int b; } vector[10];

     void s(int(*) (const char*, ...)){ }

     int sumar(){}

     struct { int x; } X;

     struct PE{ int *x; } *pe;
     struct { int x[10]; int y[10]; } po = {0};

     int main(){
             pe = malloc(sizeof(struct PE));
             pe->x = malloc(sizeof(int));
             ,*pe->x = 50;
             ,*(pe->x) = 40; // `->` mas precedencia que `*`
             printf("pe->x = %d\n", *(pe->x)); // `->` mas precedencia que `*`
             printf("pe->x[0]=%d\n", pe->x[0]);
             printf("++pe->x[0]=%d\n", ++pe->x[0]); // prioridad: ->, [], ++

             printf("\n\n");

             printf("po.x[0]=%d \t ++po.x[0]=%d\n", po.x[0], ++po.x[0]);
             printf("po.y[0]=%d \t po.y[0]++=%d\n", po.y[0], po.y[0]++);
             //5 = 1; if(1);
             //5=1;
             //X++;

             //char* opcion;
             //switch(opcion);

             int n =0;
             n++;
             //n[0];

             char* palabra = "hola";
             //palabra = 'a';

             char cadena[] = "ABC";
             cadena[0] = 'a';
             ,*cadena = 'a';
             ,*(cadena+0) = 'a';
             //cadena = 'a';
             //cadena+1 = 'a';

             sumar + 5;
             printf("%p\n", sumar);
             //printf("%d %s %c");

             s(printf);
             a(printf);

             printf;
             // while(1) printf;

             int c = vector[0].b;
             a;

             arr[1].b = 5;

             printf;

             if(1);
             if(1) 2;
             if(0.5);
             if('a');
             if("aa");
             int* ptr; if(ptr);
             int v[5]; if(v);

             printf("hola\n");

             return 0;
     }
   #+END_SRC
** Errores semánticos
   #+BEGIN_SRC C
     #include <stdio.h>
     #include <stdlib.h>

     int main(){
             // (1==1) ? "a" : 'b';

             // ---------------------------------------

             int*a,*b,*ptr,c;
             a=malloc(sizeof(int));b=malloc(sizeof(int));
             c=9;*a=5,*b=10;printf("a=%d, b=%d, c=%d\n",*a,*b,c);

             // (ptr  == &c) es verdadero, porque `ptr` apunta a la dirección de `c`
             // (&ptr == &c) es falso, porque `&ptr` apunta a la dirección de `ptr` (de la variable/objeto)
             ptr=&c;printf("ptr=%x, &ptr=%x\nc=%x, &c=%x\n",ptr,&ptr,c,&c);

             printf("\n");
             // ---------------------------------------

             char* cadena = "abc";
             printf(cadena); // ok, sin error porque espera como primer parámetro un char*
             printf("%c\n", "\n"); // el valor de \n

             void*p;printf(p); // ok, sin error

             printf(0); // ok, sin error
             // printf(7); // error semántico, error de tipo
             //printf((char*) 'a'); // error semántico, error de tipo


             //static int f;printf(f); // error, aunque f esté inicializado en 0 por ser static

             printf("\n");
             // ---------------------------------------

             int x=3,y=7,z=y;y+=x++<=3;z+=++x<=3;printf("x=%d, y=%d, z=%d\n",x,y,z);

             return 0;
     }
   #+END_SRC
** Errores Semánticos y Valor-L Modificables Vs Valor-L NO modificables
   #+BEGIN_SRC C
     #include <stdio.h>
     #include <stdlib.h>

     struct X{int x;}X1; // `X` es un lvalue modificable
     //struct{const int y; int z;}Y;
     struct Y{const int y; int yy;}Y1;
     int main(){
             int n[5]={0}, m[5]={1};

             // -----------------------------------------
             {
               // al agregar `const` hacemos que `a` sea un lvalue NO modificable
               const int a[1], i, *p;
               //a[0] = 5; // <-- ERROR semántico por ser `a[i]` un lvalue NO modificable
             }

             // -----------------------------------------
             const int r; // el identificador `x` es un lvalue NO modificable
             const int vector[10]; // hacemos a `vector` un lvalue NO modificable

             char a[10]; // declaración de `a`
             // los siguientes son lvalue modificables, porque apuntan a una dirección de memoria
             //a; // puntero, `a` apunta al principio de la dirección del array, a la dir. del primer elemento osea &a[0]
             a;

             a[0]; // expresión de subindice [], no se evalúa como arreglo completo porque apunta a la dirección del primer elemento
             a[0]=1; // es lvalue porque podemos hacer esto

             ,*a; // expresión de direccionamiento, el operando es `a`, la exp apunta a la dirección del primer elemento
             ,*a=0; // es lvalue porque podemos hacer esto

             ,*(a+0); // expresión de direccionamiento, apunta a la dirección del primer elemento
             ,*(a+0)=0; // es lvalue porque podemos hacer esto

             struct B{int x;}*b; // declaración de `b`, tipo puntero a struct B
             // los siguientes son lvalue modificables
             b; // puntero, apunta a `b`
             ,*b; // expresión de direccionamiento unario, el operando es `b`
             b->x; // expresión de selección de miembro, los operandos son b,x
             (*b).x; // expresión de selección de miembro, con subexpresión de direccionamiento unario

             b=malloc(sizeof(struct B));
             struct B b1={1};
             b[0]=b1;

             // -----------------------------------------

             int x; // `x` es un lvalue modificable
             const int y; // `y` es un lvalue NO modificable

             x=1;
             //X1 = 5; // error semántico, tipos incompatibles

             Y1.yy=1;
             //Y1.y=5; // error semántico, el miembro `y` es un lvalue NO modificable

             struct Y Y2={2,2};
             printf("Y1.y=%d, Y1.yy=%d\n",Y1.y,Y1.yy);
             printf("Y2.y=%d, Y2.yy=%d\n",Y2.y,Y2.yy);

             printf("\n");
             // -----------------------------------------

             char cadena[10];

             // - el identificador `cadena` es un lvalue modificable,
             // porque apunta a una dirección de memoria (es un objeto)
             // - apunta al primer elemento del array
             // - pero sólo es un operando válido para asignarle valor con [] ó *
             cadena;

             ,*cadena=2;*(cadena+0)=3;cadena[0]=3;

             // `cadena[0]` también es lvalue modificable,
             // apunta a la dirección del primer elemento
             cadena[0];

             // &cadena[0] es equivalente a &(cadena[0])
             printf("cadena=%x, &cadena[0]=%x\n", cadena, &cadena[0]);
             return 0;
     }
   #+END_SRC
** Expresión de Asignación con multiples expresiones + Constantes Reales
   #+BEGIN_SRC C
     #include <stdio.h>

     int main(){
             {
             int x,y,z,n;

             x=0;
             y=(x,1); // se le asigna la última expresión evaluada osea el 1
             z=(x,(x,1),9); // la última expresión evaluada es 9
             n=(x,(x,1),(1,5)); // la última expresión evaluada es 5

             printf("x=%d, y=%d, z=%d, n=%d\n\n", x,y,z,n);
             }

             // ---------------------------------------------------

             {
             float a=0,x,y,z;
             x=a+.1; // .1 es una constante real
             y=.1+x;
             z=.1+.1;

             printf("x=%f, y=%f, z=%f\n\n",x,y,z);

             x, .1, x+.1; // las expresiones son válidas

             x,1==5; // las expresiones son válidas
             }

             // ---------------------------------------------------

             {
             int x=1LU; // constante entera (no haría efecto el LU, "creo")
             long unsigned int y=1LU; // constante entera long unsigned

             printf("x=%d, y=%d\n",x,y);

             1LU+.1+0; // son expresiones válidas, son todos enteros
             }


             return 0;
     }
   #+END_SRC
** Errores semánticos + punteros
   #+BEGIN_SRC C
     #include <stdio.h>

     int main(){
       int a=5;void* v=&a;
       printf("%d\n\n", *(int*)v);
       ,*(int*)v=1; // ok, porque al castear a (int*), estamos desreferenciamos un puntero a entero
       printf("%d\n\n", *(int*)v);

       //*v=&a; // error semántico, NO se puede desreferenciar un puntero a void

       //--------------------------------------------------------------

       int x=2, *p=&x, y=5,*ptr=&x;

       printf("*ptr=%d\n\n", *ptr);
       ptr++; printf("x=%d,*ptr=%d\n\n",x,*ptr);
       ptr++; printf("x=%d,*ptr=%d\n\n",x,*ptr);
       //*ptr*1;


       //ptr = &x.y; // error semántico, &x no es un tipo struct
       // &x=0; // error semantico, &x no es lvalue

       printf("ptr[0]=%d\n", ptr[0]);
       //printf("&x[0]=%d\n", x[0]); // error semántico, el subindice `x` no es un arreglo ni puntero

       ptr=NULL;
       // *ptr = 0; // produce segmentation fault, se perdió la referencia al asignarle NULL
       return 0;
     }
   #+END_SRC
** Errores semánticos
   #+BEGIN_SRC C
     #include <stdio.h>

     char *a, *b(int);

     char* b(int x){
             return "hola";
     }

     char* test(){
             return "\0";
             return NULL;
     }
     char* nombreCompleto(int x){
             static char* palabra = "hola";
             return palabra + 1;
     }

     int* numero(int x){
             static int y = 0;
             y = y + x;
             return &y;
     }

     char* puntero(){
             char*p; return p;
     }

     int hola(int x){ return 0; }
     int main(){
             int z, *h;
             h = &z;

             // mmmmmh...
             int m = "hola"; // porque no lo toma como error de tipos incompatibles (?)
             hola("a"); // porque no lo toma como error de firma e invocación con distintos argumentos (?)

             //hola(1)=1; // error semántico, el operando de la izq. no es lvalue
             //hola=1; // error semántico, el operando de la izq. no es lvalue
             //hola++; // error semántico, el operando de la izq. no es lvalue

             puntero();
             printf("%d\n", puntero());

             a="abc";
             printf("b(1)=%s, a=%s\n\n", b(1),a);

             printf("%c\n", ""[0]); // ok, devuelve vacío
             printf("%c\n", "h"[1]); // Ok
             printf("%d\n", ""[0] == "h"[1]); // ok, devuelve 1 (true)

             printf("x%c\n", test());

             printf("%c\n", nombreCompleto(0)[0]); // devuelve 'o'

             printf("%d\n", numero('a')); // devuelve una dir. de memoria

             return 0;
     }
   #+END_SRC
** Errores semánticos + Scopes + Espacios de Nombres
   #+BEGIN_SRC C
     #include <stdio.h>

     // - no genera problemas con la declaración `int x,y`
     // porque no comparten el espacio de nombres con los identificadores
     struct x{int x, y;};
     struct y{int x, y;};

     enum dia{LUNES,MARTES};
     // error semántico, los structs/union/enums comparten el "espacio de nombres"
     // struct x{int x, y;};

     typedef int ENTERO;
     struct z{ int x;}x;

     int f(){}

     struct{ struct { int c; }b[42+1]; }a = {0};

     int main(){
       printf("%d\n\n", a.b[42].c);

       int ENTERO;
       char f = 'a';
       f;
       f(); // error semántico, no se puede declarar una variable

       x.x = 5; // ok, mientras esté antes de la declaración `int x`

       int x, y;
       // x.x = 5; // error

       printf("%d\n", LUNES); // toma el valor 0 de la constante enumeración
       int LUNES = 1; // ok, no genera error
       printf("%d\n", LUNES); // toma el valor 1 del identificador

       struct x X = {1,1};
       return 0;
     }
   #+END_SRC
** Errores semánticos + puntero a void + vectores
   #+BEGIN_SRC C
     #include <stdio.h>

     // struct{void *x;};
     int main(){
             // Scope (dentro de main)
             char cadena[] = "abc";

             cadena[0]='z'; printf("cadena=%s\n", cadena);

             // al agregar el caracter especial \0 como como segundo elemento,
             // al imprimir el string sólo imprimirá el primer caracter 'a'
             // porque el \0 indica fin de cadena
             // (de igual forma podemos imprimir el tercer caracter con cadena[2])
             cadena[1]='\0'; printf("cadena=%s, cadena[2]=%c\n", cadena, cadena[2]);

             // el identificador `cadena` apunta al comienzo del bloque reservado para el array,
             // y &cadena[0] al ser el primer elemento tendrá la misma dirección
             printf("cadena=%x, cadena+1=%x, &cadena[0]=%x, (cadena==&cadena[0])=%d\n",
                     cadena, cadena+1, &cadena[0], cadena==&cadena[0]);
             cadena+1;

             printf("\n");

             // -------------------- 

             // Scope #1
             {
             void* a; struct{}b; char c;

             // *a=0; // ERROR SEMANTICO! no se puede desreferenciar un puntero a void
             // *b; // ERROR SEMANTICO! NO se puede desreferenciar un struct
             // *c; // ERROR SEMANTICO! Sólo se puede desreferenciar un puntero ó vector
             }

             // -------------------- 

             // Scope #2
             {
             char* a; char* b="abc"; char c[3]="zxc"; int d[10];

             // OK, cada identificador es un objeto que representa la dir. de memoria
             a, b, c, d;

             ,*a; // OK, desreferenciamos un puntero a char
             ,*b; // OK, dereferenciamos un puntero a char
             ,*c; // OK, desrefereciamos un arreglo de caracteres
             ,*d; // OK, desreferenciamos un arreglo de enteros

             // *d es equivalente a d[0] ó *(d+0)
             printf("*d=%d, d[0]=%d, *(d+0)=%d\n",
                     ,*d, d[0], *(d+0));

             }
             return 0;
     }
   #+END_SRC
** Orden de evaluación de los operadores
   #+BEGIN_SRC C
     #include <stdio.h>

     int main(){
             // --------------------------------------------

             int x=5, *p=&x;
             printf("*p=%d\n", *p);
             //printf("*p++=%d\n",*++p); // *p++ es equivalente a *(p++)
             printf("*p++=%d\n",*p++); // *p++ es equivalente a *(p++)
             printf("x=%d, *p=%d\n\n",x,*p);

             printf("1<*p=%d\n", 1<*p); printf("1>*p=%d\n", 1>*p);
             printf("1>*p++=%d\n",1>*p++);
             printf("\n");

             &p;
             //p++;
             //++*p; // ok, se evalúa como ++(*p) <- 1ro desreferencia y luego incrementa
             // &p++; // error semántico, p++ no es lvalue.. se evalúa como &(p++)

             printf("x=%d, *p=%d\n", x, *p);
             // - Si usamos los paréntesis, podemos cambiar el orden de evaluación
             // de los operadores..
             (*p)++; printf("x=%d, *p=%d\n", x, *p);
             (*p)++; printf("x=%d, *p=%d\n", x, *p);
             printf("\n");

             // --------------------------------------------

             int y=1, *p1=&y;

             printf("y=%d, *p1=%d\n", y, *p1);
             // - la expresión *p1++ se evalúa como *(p1++),
             // NO se conoce el siguiente objeto al que apuntará el puntero p1 con ++
             // y que luego desreferenciará con *
             // - el valor que se desreferencia de p1++ podrá ser cualquier valor
             ,*p1++; printf("y=%d, *p1=%d\n", y, *p1);

             ,*p1++; printf("y=%d, *p1=%d\n", y, *p1);
             // --------------------------------------------

             printf; main;
             //return ;

             return 0;
     }
   #+END_SRC
** Evaluando diferentes expresiones con el Operador Lógico && (AND)
   #+BEGIN_SRC C
     #include <stdio.h>

     // Si usas typedef para crear un alias de un struct,
     // no podés usar el alias dentro del struct...
     // Para eso debes usar el nombre del struct (en este caso S)
     typedef struct S{ int m1; struct S *m2; } T;

     int main(){
             int a,b,c,d,e;
             a,b,c;

             // error sintáctico, se espera un caracter puntuación u operador luego de los identificadores
             //a b c;

             printf("%f, %f\n", 1.0, 1.0f);

             //for(;;) ;

             {unsigned x = -10; printf("(unsigned) x=%d\n", x);}
             {int x = -10; printf("(int) x=%d\n", x);}
             printf("\n");

             // Usamos el caracter de puntuación `,` para agrupar las expresiones a evaluar

             // (1 && cualquier valor distinto de cero ó NULL) = 1 (true)
             printf,printf("1&&5=%d\n", 1&&5),
             printf("1&&-1=%d\n", 1&&(-1)),
             printf("1&&'a'=%d\n", 1&&'a'),
             printf("1&&\"abc\"=%d\n", 1&&"abc"),
             printf("\n");

             // Al comparar con NULL, el caracter especial '\0' ó la constante entera 0 
             // la condición no se cumplirá (false)
             printf,
             printf("1&&NULL=%d\n", 1&&NULL),
             printf("1&&'\\0'=%d\n", 1&&'\0'),
             printf("1&&0=%d\n", 1&&0),
             printf("\n");

             return 0;
     }
   #+END_SRC
** Punteros a funciones
   #+BEGIN_SRC c
     #include <stdio.h>
     #include <stdlib.h>

     struct velocidad{int x,y;};

     void saludar(){
             printf("hola\n");
     }

     void saludarA(char* nombre){
             printf("Hola %s\n", nombre);
     }

     int calcularEdad(int anioNacimiento){
             return 9;
     }

     void saludarTipo(char* nombre, void(*tipo)(char*)){
             tipo(nombre);
     }

     void saludoFormal(char* nombre){
             printf("Hola señor %s\n", nombre);
     }

     void saludoInformal(char* nombre){
             printf("ola %s\n", nombre);
     }

     int sumar(int x, int y){
             return x + y;
     }

     int main(){
             int num=10, *p=&num;

             (*p)++; printf("*p=%d, num=%d\n", *p, num); // p apunta al 11 de num
             ,*p++; printf("*p=%d, num=%d\n", *p, num); // no sabe sabe a donde apunta `p`

             sumar(1,1);

             char* sumar;
             // - error semántico, se pisó la definición de la función sumar con la declaración de la variable
              //sumar(1,1);
             //sumar=5;
             //printf("sumar=%d\n", sumar);

             // --------------------------------------------------------------------

             struct velocidad* vInicial = malloc(sizeof(struct velocidad));
             vInicial->x = 0; // operador -> para acceder a un miembro de un ptr a struct
             (*vInicial).x = 5; // desreferenciamos para luego acceder al miembro del stuct

             // *(vInicial).x = 5; // WRONG, sería lo mismo que no poner los paréntesis

             printf("x=%d\n", vInicial->x);
             free(vInicial);

             // --------------------------------------------------------------------

             int (*ptr1)(int); // puntero a función tipo int que recibe 1 parámetro int
             ptr1=calcularEdad; // el puntero a función apunta a calcularEdad
             int edad = ptr1(1990);

             printf("f(1990)=%d, edad=%d\n", ptr1(1990), edad);

             void (*ptr2)(); // puntero a función tipo void, que no recibe parámetros
             ptr2=saludar;
             ptr2();


             void (*ptr3)(char*); // puntero a una función tipo void, que recibe 1 parámetro tipo char*
             ptr3=saludarA;
             ptr3("carlos");

             // funcion con 2 parámetos,
             // el segundo es puntero a función void que recibe string
             saludarTipo("carlos", saludoFormal);
             saludarTipo("carlos", saludoInformal);

             return 0;
     }
   #+END_SRC
** Errores Sintácticos
   #+BEGIN_SRC C
     #include <stdio.h>

     // - just a warning, no produce un error en tiempo de compilación
     // - sería ERROR semántico si.. quisieramos desreferenciar un puntero a void sin castear previamente
     void imprimir(){
     //      return 1;
     }

     // - imprime el caracter 'g' por stdout
     // - retorna como valor la diferencia de los valores 'g' y 'f' según la tabla ascii
     int g(void){putchar('g');return 'g'-'f';}

     // - imprime el caracter 'f' por stdout
     // - retorna 0 como valor, porque el valor de '\0' en ascii es 0
     int f(void){putchar('f');return '\0';}

     int main(){
             {int x=g()*f();putchar(x),putchar('\n');} // otro scope

             printf("NULL=%d, \'\\0\'=%d\n", NULL, '\0');

             // - es una única sentencia expresión, con 4 expresiones
             // - imprime zZz y hace salto de linea
             // - separamos las expresiones con el caracter de puntuación ','
             putchar('z'),putchar('Z'),putchar('z'),putchar('\n');

             g(),f(),printf("\n"); // sentencia expresión con 3 expresiones

             {int x= g()&&f();printf("x=%d\n",x);} // otro scope
             {int x= g()||f();printf("x=%d\n",x);} // otro scope
             {int x= g()*f();printf("x=%d\n",x);} // otro scope

             // ---------------------------------------------------

             // (); // <-- ERROR sintáctico, se espera una exp dentro de los ()
             int a;
             a=(1); printf("a=%d\n", a);
             a; (a);
             // (); // <-- ERROR sintáctico, se esperaba una expresión entre los ()

             switch(a){
                     case 1: a++, printf("a=%d\n", a);
                     break;
                     // a // <-- ERROR sintáctico, se espera un ; luego de la exp `a`
             } //} <-- produce un ERROR sintáctico más adelante

             //imprimir();

             return 0;
     }
   #+END_SRC
** Declaraciones válidas
   #+BEGIN_sRC C
     #include <stdio.h>

     int main(){
       short a=0; long b=0; printf("a=%d, b=%d\n",a,b);
       // short long int b=0; // <-- ERROR

       {long int x;}{long long x;}{long long int x;} // todas ok
       {long double x;}{long double x;} // ambas sentencias ok

       {;} // ok
       // while(1); // ok
       // while(1);{;}; // ok
       return 0;
     }
   #+END_SRC
** Objetos + Declaraciones Vs Definiciones + Errores Semánticos
   #+BEGIN_SRC C
     #include <stdio.h>

     // - tanto getchar, printf, main NO son palabras reservadas
     // por eso podemos usarlos para declarar un tipo de struct
     // - declarar un struct no implíca reserva de memoria,
     // por eso si hacemos
     struct getchar{}; struct printf{}; struct main{};

     // - error semántico, redeclaración del identificador getchar
     // - los identificadores y los struct tienen "espacios de nombres" diferentes
     // pero los identificadores comparten el namespace dentro del scope en el que estén,
     // por eso `int getchar` lanzaría un error semántico por redeclaración
     //
     // int getchar; // <-- ERROR semántico, redeclaración, xq fue declarado en stdio.h

     // - este prototipo `sumar` es la declaración de una función,
     // si intentamos hacer {printf("%x",sumar);} arrojará error
     // porque no está en memoria
     int sumar(int, int);

     // - la definición de la función `sumar`, implíca reservar memoria
     // por tanto podremos {printf("%x",sumar);}
     // y nos dirá la dir. de memoria del identificador `sumar`
     int sumar(int x,int y){ return x+y; }

     struct Persona{}p1;

     int main(){
             {
             int x;
             // - con el especificador de formato %x
             // obtenemos  el objeto (dirección de memoria) que se reservó
             // para ese identificador
             // - para las variables usamos el operador de dirección (&)
             // y para las funciones no sería necesario
             printf("sumar=%x, &sumar=%x\n", sumar, &sumar);
             printf("&x=%x\n", &x);
             }

             // ---------------------------------------------------------

             // - al "declarar" una variable, estamos reservando memoria
             // por tanto también es una "definición"
             int x;
             printf("x=%x, main=%x, getchar=%x, printf=%x\n",
                     &x,main,getchar,printf);
             // printf("struct Persona=%x\n", struct Persona);

             return 0;
     }
   #+END_SRC
* Referencias
  1. https://www.tenouk.com/cpluscodesnippet/chardecimalhexoctal.html
  2. https://slidetodoc.com/parsing-tools-introduction-to-bison-and-flex-1/
