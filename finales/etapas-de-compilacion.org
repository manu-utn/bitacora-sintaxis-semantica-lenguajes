#+TITLE: Resumen de Finales - Etapas de Compilación
* ASDR
** Problema 1 (2019-12-11)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la siguiente gramática:
   E → E + T | T
   T → T * F | F
   F → 1 | 2 | 3
   
   Indique si las siguientes afirmaciones son verdaderas o falsas y justifique su respuesta
   
   Puede ser implementada directamente, es decir, sin aplicar ninguna transformación a la
   gramática, por un *Parser descendente recursivo*
   #+END_QUOTE
*** Respuesta (resolucion)
   #+BEGIN_QUOTE
   Según la resolución es Falsa..
   
   Falsa. El PDR no soporta recursión a izquierda, debe ser transformada primero una GIC LL(1)
   #+END_QUOTE
* Evaluar expresiones
** Problema 1 (2020-12-14)
*** Enunciado
   #+BEGIN_SRC C
     int f(int c){
       int d = c-7;
       printf("%d",d);
       return d;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior función:
   Indicar de las siguientes expresiones su valor y su salida por ~stdout~
   1) ~f(7)-f(7)~
   2) ~f(8) || f(7)~
   3) ~f(7) || f(8)~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   El valor de retorno y la salida por stdout de las expresiones dadas serian
   (1) para ~f(7)-f(7)~
    - el valor de retorno es ~0~ (al evaluar la expresión, realiza una operación arimética 7-7 = 0)
    - la salida por stdout es ~00~ (al evaluar la expresión, invoca dos veces a f pasandole 7 como parámetro)
        
   (2) para ~f(8)||f(7)~
    - el retorno sería ~1~ (al evaluar la exp, y realiza una operación lógica que finaliza luego evalúar la primera subexpresion f(8) que la hace verdadera)
    - la salida ~1~ (como sólo evalúa la primera subexpresión osea f(8), se invoca sólo una vez a f pasandole 8 como parámetro)
        
   (3) para ~f(7)||f(8)~
    - el retorno sería ~1~ (al evaluar la exp. el operando de la derecha hace verdadera la expresión, por tanto devuelve 1)
    - la salida ~01~ (como el operando de la izquierda es falso, evalúa el de la derecha, por tanto se invoca dos veces a f y hace dos printf)
   #+END_QUOTE
** Problema 2 (2020-12-09)
*** Enunciado
   #+BEGIN_SRC C
     int f(int c){
       int d = c-'A';
       printf("%d",d);
       return d;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior función:
   
   Analice las siguientes expresiones. Indique su valor y su salida por stdout, si la salida no se puede
   determinar, indique "Indeterminada":
   #+END_QUOTE

   | Expresión            | Valor | Salida por stdout o "Indeterminada" |
   |----------------------+-------+-------------------------------------|
   | f('A')-f('A')        |       |                                     |
   | f('B')llf('A')       |       |                                     |
   | f('A')llf('B')       |       |                                     |
   | f('A')?f('B'):f('C') |       |                                     |
*** Respuesta
   #+BEGIN_QUOTE
   Al evaluar la exp ~f('A')-f('A')~
   - El valor de retorno es ~0~ (/realiza la operación arimética 0-0 = 0/)
   - La salida por stdout es ~00~ (/se invoca dos veces la función f, por tanto se ejecuta dos veces el printf haciendo 'A'-'A'/)
   
   Al evaluar la exp ~f('B')||f('A')~
   - El valor de retorno es ~1~ (/sólo evalúa la primera subexpresion f('B') hace verdadera a la expresión, y no se sigue evaluando el operando derecho/)
   - La salida por stdout es ~1~ (/como sólo evalúa el operando izquierdo, se ejecuta una única vez el printf que hace 'B'-'A' = 1/)
   
   Al evaluar la exp ~f('A')||f('B')~
   - El valor de retorno es ~1~
   - La salida por stdout es ~01~ (/como el operando izquierdo no hace verdadera la expresión OR, evalúa el operando derecho, por tanto se invoca dos veces f y también el printf/)
   
   Al evaluar la exp ~f('A')?f('B'):f('C')~
   - El valor de retorno es ~2~ (/como la condición del operador ternario es falsa, se invoca f('C') y 'C'-'A' = 2/)
   - La salida por stdout es ~02~ (/porque evalúa la exp de la condicion que es f('A') y luego f('C'), por tanto invoca a la función f dos veces y también printf/)
   #+END_QUOTE

   #+BEGIN_QUOTE
   La evaluación de la expresión ~f('A')-f('A')~ es de Izq. a Derecha porque
    - la asociatividad del operador aritmético ~-~ es de Izq. a Der.
    - no hay otras subexpresiones con operadores de mayor precedencia (Ej. el operador * de multiplicación)
    - tampoco se usaron paréntesis para alterar la precedencia con otras subexpresiones
     
   La evaluación de la expresión ~f('B')||f('A')~ es de Izq. a Derecha porque
   - La asociatividad del operador lógico OR ~exp1||exp2~ es de Izq. a Der. (tanto AND como OR)

   La evaluación de la expresión ~f('A')?f('B'):f('C')~ es de Izq. a Derecha porque
   - La asociatividad del operador ternario ~exp1?exp2:exp3~ es de Izq a Der.
   #+END_QUOTE
** Problema 3 (2019-07-015)
*** Enunciado
   #+BEGIN_QUOTE
   Sea la función ~int f(int a,int b){return&a==&b?b:a;}~, calcule ~f(x,y)~ siendo ~x~ e ~y~ *expresiones de tipo int*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   El resultado es valor ~x~ porque ~&a==&b ? b : a~ porque
   1. Verifica si dirección de memoria de ambos parámetros es la misma
   2. El resultado de ~&a==&b~ será ~0~ (false) porque no se cumple la condición
   3. El operador ternario ~exp1:exp2?exp3~ evalúa la expresion3 porque el valor de la expresion1 es 0 (false)
   #+END_QUOTE
** Problema 4 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
    Dada la *declaración* ~int x=0,a=2;~ evalúe cada expresión, indique su valor y el valor resultante
    de la variable ~a~.
    1) ~x && ++a~
    2) ~x<'a' ? x+'a' : a+=40~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
    (1) De la expresión ~x && ++a~
    - Su valor es ~0~ (porque al evaluarla, detecta que el primer operando es ~0~ por tanto no sigue evaluando) 
    - El valor de ~a~ es ~2~ (porque como sólo evalúa el valor del primer operando que no satisface la condición, no se evalúa la segunda expresión que incrementa el valor de ~a~)
       
    (2) ~x<'a' ? x+'a' : a+=40~
    - Su valor es ~'a'~ porque se cumple la condición de que ~x~ es menor que el valor ~'a'~ (según la tabla ascii)
    - El valor de ~a~ se mantiene en ~2~
   #+END_QUOTE
** [#A] Problema 5 (desconocido)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~int a=4,b=2;~ compare ~a=a+b~ y ~a+=b~ e indique cuál afirmación es falsa:
   
   1. Son expresiones.
   2. Tienen mismo valor.
   3. Tienen mismo *tipo de dato*
   4. Tienen mismo *efecto de lado*
   5. Tienen misma *cantidad de evaluaciones*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   1. Verdadero, ambas son expresiones (secuencia de operandos y operadores)
   2. Verdadero, el resultado de ambas es ~a=6~
   3. Verdadero, ambos son del tipo int
   4. Verdadero, al usar el operador de asignación ~=~ generan efecto de lado sobre la expresión primaria (identificador) a izquierda del ~=~
   5. FALSO, la primera se evalúa 4 veces y la segunda 3 veces
   #+END_QUOTE

   Evaluamos ambas expresiones al mismo tiempo, donde ~a=a+b~ se evalúa 4 veces, y ~a+=b~ 3 veces
   |-------+------|
   | a=a+b | a+=b |
   |-------+------|
   | a=a+b | a+=b |
   | a=4+b | a+=2 |
   | a=4+2 | a=6  |
   | a=6   |      |
   |-------+------|
** [WAITING] [#A] Problema 6 (desconocido)
*** Enunciado
   #+BEGIN_SRC C
    int g(void){putchar('g');return 'g'-'f';}
    int f(void){putchar('f');return '\0';}
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dadas las anteriores funciones, indique *el valor de cada expresión* y,
   si es que está determinada, *la salida por stdout*, si no la frase "Indeterminada":
   
   1. ~g()&&f()~
   2. ~g()*f()~
   3. ~g()||f()~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Por qué la salida por stdout de evaluar ~g()*f()~ sería indeterminada?
   Entiendo que el orden de evaluación de los operandos es a nivel semántico,
   y que es de izquierda a derecha para los operadores lógicos como AND y OR

   para el caso del operador arimético ~*~ "creo" que no está específicado,
   el orden de evaluación de los operandos, porque no se sabe si se ejecuta primero f() ó g() ?
   *OJO.. "que tuviste problema en el final con este tema..."*
   #+END_COMMENT
   
   | Expresión  | valor | salida por stdout |
   |------------+-------+-------------------|
   | ~g()&&f()~ |     0 | gf                |
   |------------+-------+-------------------|
   | ~g()*f()~  |     0 | INDETERMINADA     |
   |------------+-------+-------------------|
   | ~g()llf()~ |     1 | g                 |

   #+BEGIN_QUOTE
   El resultado de evaluar la operación ~'g'-'f'~ es ~1~, porque ambos caracteres representan un valor numérico de la tabla ascii,
   y como ~f~ está en una posición antes que ~g~ sería lo mismo que hacer 11-10 ó 12-11, etc...
   
   En la expresión ~g()&&f()~
   - El valor de retorno es ~0~, porque al evaluarla queda ~1 && 0~ y el operador lógico AND es 1 sólo si ambos operandos son
   - La salida por stout es ~gf~, porque se logra evaluar ambas expresiones que invocan a funciones que imprimen esos caracteres con ~putchar~
      
   En la expresión ~g()*f()~
   - El valor de retorno es ~0~ porque al evaluarla resulta en ~1*0~ que es una operación arimética común
   - La salida por stout es ~gf~ mismo caso que con el operador lógico AND &&
      
   En la expresión ~g()||f()~
   - El valor de retorno es ~1~ porque como operadores lógicos se evalúan de izq. a der. (por su asociatividad),
     es suficiente para el operador lógico OR ~||~ con que uno de los operandos valga ~1~ para retornar ~1~,
   - La salida por stout es ~g~ misma explicación que antes, y también que el operando de la derecha no se llega a evaluar,
     ya que termina de evaluarse la expresión con que uno de los operandos valga ~1~ (para el operador lógico OR)
   #+END_QUOTE
* Evaluar Operandos y Operadores
** [#A] Problema 1 (2020-12-21) <- interesante
*** Enunciado
   #+BEGIN_QUOTE
   Explique y ejemplifique en C el concepto de *orden de evaluación de operandos*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   El *orden de evaluación de operandos* determinará la *secuencia de evaluación de los operandos*
   
   El lenguaje C específica *el orden de evaluación de 4 operadores*
   1. Los dos operadores lógicos ~&&~ y ~||~
   2. La coma ~,~
   3. El operador ternario ~exp1 ? exp2 : exp3~

   Por ejemplo si tenemos la siguiente expresión ~f()+g()+h()~ ó ~f()*g()~
   no sabemos si evaluará primero a ~f()~ ó ~g()~ ó ~h()~

   Otro ejemplo sería la invocación de una función ~f(x,y)~,
   no sabemos si primero evaluará ~f~ ó ~x~ ó ~y~

   Otro ejemplo sería ~f() && g()~ donde si se sabe que los operadores lógicos evalúan de izq. a der.
   #+END_QUOTE
* Detectar Expresiones completas
** Problema 1 (2021-03-10)
*** Enunciado
   #+BEGIN_SRC C
     int f(int x, int y){
       int z=1;
       for(int i=1;i<=y;++i)
         z*=x;
       return z;
     }
   #+END_SRC

   #+BEGIN_QUOTE
   Dada la definición de ~f~
   1) Analice Sintácticamente e indique la cantidad de *expresiones completas* en la definición
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (/una expresión es una secuencia de operandos y operadores que producen un valor y/o producir efecto de lado/)
   las *expresiones completas* del cuerpo de la función ~f~ son
   #+END_QUOTE
   
   |---+-----------+-----------------------------------------------|
   |   | expresión | tipo de expresión                             |
   |---+-----------+-----------------------------------------------|
   | 1 | ~z=1~     | expresión de asignación                       |
   |---+-----------+-----------------------------------------------|
   | 2 | ~i=1~     | expresión de asignación                       |
   |---+-----------+-----------------------------------------------|
   | 3 | ~i<=y~    | expresión relacional                          |
   |---+-----------+-----------------------------------------------|
   | 4 | ~++i~     | expresión unaria                              |
   |---+-----------+-----------------------------------------------|
   | 5 | ~z*=x~    | expresión de asignación                       |
   |---+-----------+-----------------------------------------------|
   | 6 | ~z~       | expresión primaria (por ser un identificador) |
   |---+-----------+-----------------------------------------------|
** Problema 2 (2020-12-14)
*** Enunciado
   #+BEGIN_SRC C
     int f(int c){
       int d = c-7;
       printf("%d",d);
       return d;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior función:
   1. Analice sintácticamente el cuerpo de la función e indique la cantidad de *expresiones completas*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Hay 3 expresiones completas en el cuerpo de la función
   #+END_QUOTE

   |-------------------+--------------------------------------------|
   | Expresión         |                                            |
   |-------------------+--------------------------------------------|
   | ~d=c-7~           | expresión de asignación                    |
   |-------------------+--------------------------------------------|
   | ~d~               | expresión primaria (por ser identificador) |
   |-------------------+--------------------------------------------|
   | ~printf("%d", d)~ | por ser una invocación                     |
   |-------------------+--------------------------------------------|
** Problema 3 (2018-02-19)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~{ T v,*p; v =f(1.0 ) ;switch( v.m1){p= v .m2;} }~
   Analice sintácticamente y tilde la afirmación falsa:
   1. Contiene tres *expresiones completas*
   2. Contiene por lo menos cinco *subexpresiones*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <expresión sufijo> ->
     <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --

   *Los identificadores de las declaraciones NO son expresiones al parecer, si vemos la gramática*
   <decla> -> <puntero>? <declarador directo>
   <puntero> -> <lista calificadores tipos>? | <lista calificadores tipos>? <puntero>
   <lista calificadores tipos> -> <calificador de tipo> | <lista calificadores tipos> <calificador de tipo>
   
   <declarador directo> ->
     <identificador> | ( <decla> ) |
     <declarador directo> [ <expresión constante>? ] |
     <declarador directo> ( <lista tipos parámetros> ) /* Declarador nuevo estilo */
     <declarador directo> ( <lista de identificadores>? ) /*Declarador estilo obsoleto */
     
   <lista de identificadores> -> <identificador> | <lista de identificadores> , <identificador>
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) Verdadero, son  ~v=f(1.0)~, ~(v.m1)~ y ~p=v.m2~

   (2) Verdadero, encontramos al menos 11
   #+END_QUOTE
   
   |---+------------+-------------------------|
   |   | expresión  | tipo de expresión       |
   |---+------------+-------------------------|
   | 1 | ~v=f(1.0)~ | expresión de asignación |
   |---+------------+-------------------------|
   | 2 | ~(v.m1)~   | expresión (exp)         |
   |---+------------+-------------------------|
   | 3 | ~p=v.m2~   | expresión de asignación |
   |---+------------+-------------------------|

   |----+--------------+------------------------------------------------------|
   |    | subexpresion | tipo de expresión                                    |
   |----+--------------+------------------------------------------------------|
   |  1 | v            | expresión primaria (por ser identificador)           |
   |  2 | f            | expresión primaria (por ser identificador)           |
   |  3 | 1.0          | expresión primaria (por ser constante numérica real) |
   |  4 | f(1.0)       | (por ser una invocación)                             |
   |  5 | v            | expresión primaria (por ser identificador)           |
   |  6 | m1           | expresión primaria (por ser identificador)           |
   |  7 | v.m1         | expresión                                            |
   |  8 | p            | expresión primaria (por ser identificador)           |
   |  9 | v            | expresión primaria (por ser identificador)           |
   | 10 | m2           | expresión primaria (por ser identificador)           |
   | 11 | v.m2         | expresión                                            |
   |----+--------------+------------------------------------------------------|

   #+BEGIN_QUOTE
   (5) Verdadero
   tenemos como mínimo 5, si contamos las *expresiones primarias* (identificadores, constantes, literal cadena)
   #+END_QUOTE
* Nivel Léxico + Sintáctico + Semántico
** Conceptos básicos
*** Constructos de un (LP)
   - Los *constructos* ó *constructos sintácticos* se refieren a las *restricciones sintácticas*
   - Un constructo es una *secuencia de tokens* que forman una *categoría sintáctica* (Ej. expresiones, sentencias, declaraciones)
   - Los TOKENS son (LR)
*** Analizador Léxico (Scanner)
   - El Scanner usa ~getchar()~ para leer caracter a caracter de una secuencia de caracteres
   - El Scanner usa ~ungetc()~ para ...
*** Expresión
   - Una expresión es una secuencia de operandos y operadores que producen un valor y pueden producir efecto de lado
*** Declaración
   - Es una *sentencia* donde se específica atributos para darles un significado (Ej. tipo de dato) a uno ó varios identificadores.
   - Pasa a ser *definición* si esta implíca reservar memoria
   - Cuando declaramos una variable (/objeto/) también la estamos definiendo a menos que usemos ~extern tipoDato identificador~ ahí sólo declaramos
*** Punctuator - Caracter de Puntuación
   #+BEGIN_QUOTE
   *Según la BNF de C*
   
   punctuator -> uno de
     [ ] ( ) { } . -> ++ -- & * + -  ̃ !
     / % << >> < > <= >= == != ˆ | && ||
     = *= /= %= += -= <<= >>= &= ˆ= |=
     ? : ; ... , # ##
   #+END_QUOTE
*** Operador Vs Caracter de Puntuación
   |----------+---------------------------------------------------------+------------------------------------------|
   | Caracter | Operador                                                | Caracter de Puntuación                   |
   |----------+---------------------------------------------------------+------------------------------------------|
   | ','      | Separador de expresiones (/Ej. en una sentencia/)       | Separar parámetros en una función        |
   |----------+---------------------------------------------------------+------------------------------------------|
   | '(', ')' | Invocar una función                                     | Declarar ó definir una función           |
   |          | Agrupar expresiones                                     |                                          |
   |          | Conversión de datos explícita (typecasting)             |                                          |
   |          | Modificar precedencia de los *OPERADORES*               |                                          |
   |          | (Ej. al evaluar la expresión ~(1+1)*2 != 1+1*2~)        |                                          |
   |----------+---------------------------------------------------------+------------------------------------------|
   | '[', ']' | Acceder a un elemento de un array                       | Declarar una variable del tipo array     |
   |----------+---------------------------------------------------------+------------------------------------------|
   | '='      | Asignar un valor a una variable                         | Inicializar una variable                 |
   |          | (que ya estaba declarada, osea fuera de la declaración) | Definir una constante enumeración        |
   |          |                                                         | (Ej. ~enum mes{Enero=1, Febrero=2,...}~) |
   |----------+---------------------------------------------------------+------------------------------------------|
** Problema 1 (2021-06-23)
*** Enunciado
   #+BEGIN_SRC c
     while( EOF != (c=getchar()) ){
       switch(state){
       case INICIAL:
         switch(c){
         case 'a':
           state=INICIAL;
           continue;
           // ...
         }
         // ...
       }
      }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice el anterior fragmento de un programa C, asuma que se incluyó el header correspondiente:   
   
   Analice Léxica, Sintáctica, y Semánticamente el anterior fragmento:
   1. Indique cuántos *tokens* tiene la *expresión* que controla el while.
   2. Enumere las *operaciones que tiene esa expresión*
   3. Indique los *efectos de lado de la expresión*
   4. Declare ~state~ e ~INICIAL~
   5. Declare la variable ~c~. Justifique el tipo.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Tokens:
   1) ~!=~ <- operador desigualdad
   2) ~(~ <- caracter puntuación
   3) ~c~ <- identificador
   4) ~=~ <- operador de asignación
   5) ~getchar~ <- palabra reservada
   6) ~()~ -> operador invocar función
   7) ~)~ <- caracter de puntuación

   Cant. de operaciones:
   - son tres el ~!=~, ~=~ y ~()~

   Los efectos de lado:
   1) se asigna el retorno de ~getchar()~ que recibe la entrada del stdin, y se asigna como valor a ~c~ con el operador ~=~
   #+END_QUOTE

   #+BEGIN_SRC C
     // Alternativa #1 sin typedef, en una sola declaración
     // enum {INICIAL, ...} state;

     // Alternativa #2 con typedef, se puede reciclar para varias declaraciones
     typedef enum {INICIAL, ...} ESTADO;
     ESTADO state;

     state = INICIAL;

     // debe ser numérico porque el primer valor de un enum inicia en 0
     // (apesar de ser entero, podemos asignar c='a')
     int c;
   #+END_SRC
** Problema 2 (2021-08-04)
*** Enunciado
   #+BEGIN_SRC C
     function calcular(){
       var x;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice el anterior fragmento, siguiendo las reglas de C:
   
   1) ¿En qué cambiaría el resultado del *análisis léxico* si el anterior fragmento se escribe en solo una línea?
   2) ¿Cuántos *errores léxicos* tiene?
   3) ¿Cuántos *tokens keyword* tiene?
   4) Independientemente del contexto, ¿es *sintácticamente correcto*? ¿Por qué?
   5) En función a su respuesta anterior, ¿es *semánticamente correcto*? ¿Por qué?
   6) Introduzca al contexto del anterior fragmento *declaraciones typedef* que hagan cambiar su respuesta al punto 4.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   1) Ninguno, el Scanner lee la secuencia de caracteres
   2) NO tiene errores léxicos, habría error si el Scanner detecta en el fragmento un lexema que no es un TOKEN válido (categoría léxica)
   3) NO tiene ningún token keyword
   4) Tiene errores sintácticos porque no se puede derivar de la BNF de C
      - ~function~ no es especificador de tipo válido para definir una función
      - ~var~ tampoco es un espcificador de tipo válido para declarar una variable
   5) No es semanticamente correcto, al no ser sintacticamente correcto
   6) ~typedef int function, var;~
   #+END_QUOTE
** Problema 3 (2021-09-24)
*** Enunciado
   #+BEGIN_QUOTE
    Escriba el *prototipo en C* de la *función transición de un AFD*. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     typedef struct { /* ... */ } ESTADO;

     // - Hace una transición a un Estado, y lee un caracter
     // - Retorna el siguiente estado
     ESTADO transicion(ESTADO estado, char caracterLeido);
   #+END_SRC
** Problema 4 (2021-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el siguiente fragmento: ~a<b<c~
   
   1. Indique la *secuencia de caracteres* devueltos por ~ungetc~ durante el *Análisis Léxico*
   2. Indique la asociatividad mediante *paréntesis redundantes*.
   3. Para cada situación pedida a continuación escriba una declaración que haga…
      - … *Semánticamente inválido* al fragmento.
      - … cero al valor resultante sin usar el tipo int.
      - … uno al valor resultante sin usar el tipo int.
      
   4. Escriba una *expresión* que evalúe si un valor b está dentro del intervalo abierto ~(a, c)~. Agregue
   la *declaración* que haga *semánticamente válida* a esa expresión, no es necesario *inicializar*
   
   5. Presente un contexto *semántico* donde la anterior expresión, aunque *semánticamente correcta*,
   no pueda ser utilizada. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Durante el *analisis léxico* la secuencia de caracteres devueltos por ~ungetc~ es ~<b<c~
   1) devuelve ~<~ <-- porque al leer con ~getchar()~ el caracter ~a~ sabe que es identificador y el ~<~ no pertenecía a ese TOKEN
   2) devuelve ~b~ <-- porque al leer con ~getchar()~ el caracter ~<~ sabe que es un operador y ~b~ no pertenecía a ese TOKEN
   3) devuelve ~<~ <-- porque al leer ~b~ sabe que es un identificador y ~<~ no pertenecía a ese TOKEN
   4) devuelve ~c~ <-- porque al leer ~<~ sabe que es un operador y que ~c~ no pertenecía a ese TOKEN

   Si remarcamos la asociatividad de ~a<b<c~ quedaría ~(a<b)<c~
   porque la asociatividad del operador relacional ~<~ es de izquierda a derecha
   según la sintáxis de C (ésta especifica la asociatividad/precedencia de los operadores)
   #+END_QUOTE

   #+BEGIN_SRC C
     // - Esto haría semánticamente incorrecto la expresion "a<b<c" porque
     // los structs no se pueden comparar con el operador <
     struct { /*...*/ } a,b,c;

     // La siguiente declaración, e inicialización de las variables
     // hará que a<b<c retorne 0
     // 1) 'a' < 'a' < 0
     // 2) 0 < 0
     // 3) 0
     char a = 'a', b = 'a' , c = 0;

     // alternativa #2 para que a<b<c devuelva 0
     // 1) 0<0<-1
     // 2) 0<-1
     // 3) 0
     unsigned a = 0, b = 0, c = -1;

     // La siguientes declaraciones, e inicialización de las variables
     // hará que a<b<c retorne 1
     unsigned a, b, c;
     a = b = c = 1;

     char a, b, c;
     a = b = c = 'a';

     // expresiones que evalúan si b está entre (a,c)
     a < b && b < c;

     a < b && c > b;

     b > a && b < c;

     // las expresiones de las últimas 3 sentencias anteriores no podrían
     // ser utilizadas en los siguientes contextos

     // lo usamos para asignarlo a un valor que no es lvalue (Ej. una constante entera)
     42 = a < b && b < c;

     // ó al revés, donde éste no es un lvalue
     a < b && b < c = 42;
   #+END_SRC
** Problema 5 (2021-03-10)
*** Enunciado
   #+BEGIN_SRC C
     int f(int x, int y){
       int z=1;
       for(int i=1;i<=y;++i)
         z*=x;
       return z;
     }
   #+END_SRC

   #+BEGIN_QUOTE
   Dada la definición de ~f~
   
   *Analice Léxicamente*
   1. Indique la cantidad de *tokens* de la tercera expresión de la *sentencia* ~for~
   2. Indique la cantidad de veces que el símbolo ~=~ es un *lexem*. Justifique.
      
   *Analice Sintácticamente:*
   1. Indique si faltan llaves para que ~f~ sea *sintácticamente correcta*. Justifique.
   2. Indique la cantidad de *declaraciones* en la *sentencia compuesta*
   3. Indique la cantidad de *expresiones completas* en la definición
   
   *Analice Semánticamente:*
   1. Indique si la tercera expresión del ~for~ debiera ser ~i++~. Justifique.
   2. Considerando como único contexto la definición dada, escriba una *declaración* que use ~f~ y sea *semánticamente correcta*
   3. Indique el alcance de ~f~ y ~z~
   4. Indique los valores de ~x~ e ~y~ que hacen que la función retorne

   *Analice pragmáticamente* 
   Analice la función y luego escriba un nuevo *prototipo* para ~f~ que sea
   superador, es decir que sea mejor según sus propios criterios. Puede cambiar el *identificador de la función*
   y los tipos de datos. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   *Análisis Léxico*
   La expresión ~++i~ tiene 2 *tokens*
   1. ~++~ (operador incremento como prefijo)
   2. ~i~ (identificador)

   El símbolo ~=~ es un *lexema* en 2 ocasiones
   1. en ~z=1~
   2. en ~i=1~
   3. Pero no es lexema en ~i<=y~, ~z*=x~ porque representan otros operadores
   #+END_QUOTE
   
   #+BEGIN_QUOTE
   *Análisis Sintáctico*
   ~f~ no necesita de llaves adicionales, es sintácticamente correcta porque declara los parámetros
   y define su cuerpo con la sentencia compuesta que está delimitada por las llaves

   la *sentencia compuesta* que es el cuerpo de ~f~ tiene 2 declaraciones
   1. ~int z=1~
   2. ~int i=0~

   (/una expresión es una secuencia de operandos y operadores que producen un valor y pueden producir efecto de lado/)
   las *expresiones completas* del cuerpo de la función ~f~ son
   1. ~z=1~
   2. ~i=1~
   3. ~i<=y~
   4. ~++i~
   5. ~z*=x~
   6. ~z~
   #+END_QUOTE
      
   #+BEGIN_QUOTE
   *Análisis Semántico*

   Es indiferente si la 3º expresión del ~for~ tiene al operador de incremento ~++~ como prefijo ó sufijo sobre ~i~
   distinto hubiera sido si.. si hubiera usado en alguna expresión como ~a=i++~ ó ~a=++i~
   en ~a=i++~ se genera efecto en ~i~ luego de evaluar la expresión ~a=i~,
   mientras que ~a=++i~ se genera efecto sobre ~i~ previo a evaluar ~a=i~

   La declaración ~int x = f(0,0)~ sería semánticamente correcta

   El alcance/scope de ~f~ es la (UT) Unidad de traducción (etapa que se integra el archivo fuente .c y los archivos cabecera .h),
   el alcance de ~z~ es dentro del cuerpo de la función ~f~ (sentencia compuesta delimitada por las llaves { ... })

   Cualquiera sea el valor de ~x~ e ~y~, la función ~f~ retornará un entero
   #+END_QUOTE

   #+BEGIN_QUOTE
   *Análisis Pragmático*
   ~int numeroElevadoAExponente(int numero, int exponente);~
   #+END_QUOTE
** [#A] Problema 6 (2021-02-24)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión, que es sintácticamente correcta, y luego responda:
   ~f(g(x))~
   
   1. Indique el primer *token* resultante del *análisis léxico*
   2. Declare un *tipo de dato* capaz de _contener toda la información_ necesaria para representar
      cualquiera de los *tokens* de la expresión.
   3. Enumere en orden los caracteres retornados por ~ungetc~
   4. Escriba una *declaración* que haga a la expresión *semánticamente correcta*
   5. ¿Es posible declarar que ~g~ retorne un *arreglo*? ¿Por qué?
   #+END_QUOTE
*** Respuesta
   |                | f | (  | g | (  | x | )  | ) |
   |----------------+---+----+---+----+---+----+---|
   | ungetc         |   | x  |   | x  |   | x  |   |
   | getchar        | x | xx | x | xx | x | xx | x |
   |----------------+---+----+---+----+---+----+---|
   | cant. lecturas | 1 | 2  | 1 | 2  | 1 | 2  | 1 |
   
   #+BEGIN_QUOTE
   (1) ~f~ identificador
   
   (3) La secuencia de caracteres retornados por ~ungetc~ sería ~(, (, )~
   usamos como referencia la secuencia leída
   1. f( <- ungetc porque ~(~ NO pertenece al token de la secuencia anterior leída (identificador formada por f), se devuelve el ~(~
   2. (g( <- ungetc por el segundo ~(~ no pertenece al token de la secuencia anterior (identificador formada por g), se devuelve ~(~
   3. (x) <- ungetc por el segundo ~(~ , se devuelve ~)~
   4. )
   
   (4) Una posible declaración sería ~int f(int), g(int);~

   (5) Una función no puede retornar un arreglo, pero si puede retornar un puntero a la primera dirección
   de un bloque de memoria que fue reservada para el arreglo, apuntando a su primer elemento.
   #+END_QUOTE

   #+BEGIN_SRC C
     typedef enum {IDENTIFICADOR, OPERADOR, PUNCTUATOR/*...*/} TIPO_TOKEN;
     typedef struct {TIPO_TOKEN tipo, char* valor} TOKEN;

     // Ej.
     TOKEN apertura_parentesis;
     apertura_parentesis.tipo = PUNCTUATOR;
     apertura_parentesis.valor = "(";

     TOKEN cierre_parentesis;
     cierre_parentesis.tipo = PUNCTUATOR;
     cierre_parentesis.valor = ")";
   #+END_SRC
** Problema 7 (2020-12-21) <- interesante
*** Enunciado
   #+BEGIN_SRC C
   char user[1000];
   assert(0==strcmp("cjkent",CopyUser(user,"cjkent@dailyplanet.com")));
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice el anterior fragmento C que prueba una función
   
   1. Indique la cantidad de *tokens* en la declaración del fragmento anterior.
   2. Indique cuantos *literales y constantes* hay en la sentencia del fragmento anterior.
   3. Escriba una *expresión* que use user y que sea *semánticamente incorrecta*. Justifique.
   4. Indique el *prototipo* de CopyUser.
   5. Escriba la *definición* de CopyUser
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (resuelta) la resolución no consideró la "declaración" como una "sentencia expresión", por que?

   *Rta:* (similar al parcial 2020-12-14). NO son lo mismo, porque hay 3 categorías sintácticas: Declaración, Sentencia, Expresion.
   No es lo mismo una Sentencia que una Declaración.
   
   <sentencia> ->
     <sentencia expresión> |
     <sentencia compuesta> |
     <sentencia de selección> |
     <sentencia de iteración> |
     <sentencia etiquetada> |
     <sentencia de salto>
   
   <sentencia expresión> ->
     <expresión>? ;

   <nombre de tipo> está descripto más adelante, en la secciónDeclaraciones.
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Una declaración es una sentencia donde se específica atributos para darles un significado (Ej. tipo de dato) a uno ó varios identificadores.
   Por tanto existe sólo una declaración en ese fragmento y es ~char user[1000]~ que tiene 5 tokens
   1. ~char~ (palabra reservada)
   2. ~user~ (identificador)
   3. ~[~ (caractacter de puntuación)
   4. ~1000~ (constante numérica entera)
   5. ~]~ (caractacter de puntuación)
   6. ~;~ (caracter de puntuación) <---

   (2) La *sentencia expresión* de la segunda linea tiene 1 constante, y 2 literales cadena
   1. ~0~ (constante entera)
   2. ~"cjkent"~ (literal cadena)
   3. ~"cjkent@dailyplanet.com"~ (literal cadena)
   #+END_QUOTE

   #+BEGIN_SRC C
     // las siguientes sentencias tienen expresiones que son semanticamente incorrectas

     user++; // el operando 'user' no es lvalue válido para el operador de incremento ++

     42 = user[0]; // la constante 42 no es un operando lvalue válido para el operador de asignación

     user[0.1]; // la constante real 0.1 no es un operando lvalue válido para el operador []

     // --------------------------

     char* CopyUser(char*, const char*);

     char* CopyUser(char* usuario, const char* email){
       // aux apuntará a la primera dirección del bloque de memoria reservado para usuario
       char* aux = usuario;

       // - nos desplazamos por ambas cadenas como punteros, y los desreferenciamos para la asignación
       // - el centinela es el @
       while(*email != '@') *aux++ = *email++;
       // agregamos el caracter nulo, que representa fin de cadena
       ,*aux= '\0';

        // alternativa al puntero aux
        // int i; for(i =0; email[i] != '@'; i++) cadena[i] = email[i];
        // cadena[i] = '\0';
       return usuario;
     }


   #+END_SRC
** Problema 8 (2020-12-14)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~wiehl()--x;~   
   
   1. Enumere en orden los caracteres que son devueltos al flujo mediante ~ungetc~ durante el *Análisis Léxico*:
   2. Realice un *análisis de sintáctico* de izquierda a derecha y justifique si es una *sentencia*
      *sintácticamente correcta*. Si hay *error sintáctico*, reescríbala con el error encontrado corregido:
   3. Escriba una *declaración* que haga la sentencia anterior, ya se a la original o la corregida,
   *semánticamente correcta*:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Los caracteres devueltos mediante el ~ungetc~ por el Scanner son
   1. ~(~ porque cuando estaba leyendo la cadena ~wiehl~ (identificador) detectó que ~(~ no pertenece a ese TOKEN
   2. ~;~ porque cuando estaba lyendo la ~x~ (identificador) detectó que el ~;~ no pertenece a ese TOKEN

   (2) Tiene error sintáctico, el operador ~--~ que está como sufijo, necesita un operando que sea lvalue y ~wiehl()~ no lo es.
   1. Lee la cadena ~wiehl()~ que es derivable de la BNF de C (/la invocación de una función/)
   2. Cuando lee ~wiehl()++~ detecta que no se puede derivar, porque no esperaba un operador de incremento
   Posible soluciones serían, suponiendo que son valores numericos
   1. ~wiehl()*--x;~ (/una sentencia expresión, con una expresión de dos valores multplicandose, donde el 2do operando de decrementa previo a evaluar la multiplicación/)
   2. ~wiehl(),--x;~ (/dos expresiones en una sentencia expresión, separadas por la coma como operador/)
   3. ~wiehl();--x;~ (/dos sentencias expresión usando el punto y coma como operador para indicar el fin de cada expresión/)

   (3) Una posible declaración sería ~int wiehl(), x;~
   #+END_QUOTE
** [#A] Problema 9 (2020-12-14)
*** Enunciado
   #+BEGIN_SRC C
     int f(int c){
       int d = c-7;
       printf("%d",d);
       return d;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior función:
   
   1. Analice sintácticamente el cuerpo de la función e indique:
      - Cantidad de *sentencias*
      - Cantidad de *expresiones completas*
      - Cantidad de *declaraciones*
   2. ¿Explique para qué usaría la keyword ~union~ en la *construcción de scanners*?
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT   
   <<DUDA>>: (resuelta) La resolución dice que hay 3 expresiones completas, cuales son? y cuales serian no completas(?)
   *Rta:* son ~d=c-7~ (exp. de asignación), ~printf(..)~ (por ser una invocación) y ~d~ (expresión primaria, por ser identificador)
   
   <<DUDA>>: (resuelta) habia considerado la declaración ~int d = c-7;~ como sentencia expresión,
   pero la resolución indicaba que había sólo 2, al derivar de la gramatica de la BNF
   ésta no resulta como sentencia expresión entonces?
 
   *Rta:* NO, porque hay 3 categorías sintácticas: Declaración, Sentencia, Expresion.
   No es lo mismo una Sentencia que una Declaración.
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Cant. de sentencias: 2
   1. ~printf(...);~ (sentencia expresión)
   2. ~return d;~ (sentencia expresión)

   Cant. de expresiones completas: 3
   1. ~d=c-7~ (exp. de asignación)
   2. ~printf(..)~ (por ser una invocación)
   3. ~d~ (expresión primaria, por ser identificador)
   
   Cant. de declaraciones: 1
   1. ~int d = c-7;~

   (2) Podría usar la palabra reservada ~union~ para darle un significado (valor semántico) a los *TOKENS*,
   de la misma forma como usaría un ~struct~
   #+END_QUOTE

   #+BEGIN_SRC C
     typedef enum {IDENTIFICADOR, OPERADOR, ...} TIPO_TOKEN;
     typedef union{ TIPO_TOKEN tipo; char* valor; } TOKEN;
   #+END_SRC
** Problema 10 (2020-10-14)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión C: ~s.a[s.i]~
   
   1. Enumere en orden los caracteres devueltos por ~ungetc~ durante el *análisis léxico*
   2. Escriba una *declaración* para que la *expresión* sea del *tipo puntero a char*
   3. Escriba una *declaración que haga semánticamente incorrecta* a la expresión.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) el Scanner (analizador léxico) devuelve los sig. caracteres con ~ungetc~
   1. ~.~ (porque luego de leer con getchar ~s~ (identificador) detecta que ~.~ no pertenece a ese TOKEN, then retrocede
   2. ~[~ (luego de leer ~a~ (identificador) detecta que ~[~ no pertenece a esa Categoria Léxica, then retrocede
   3. ~.~ idem cuando lee ~s~
   4. ~]~ idem cuando lee ~i~
   #+END_QUOTE

   #+BEGIN_SRC c
     struct {
       char* a; // puntero a char (requerimiento)
       int i; // evitamos error semántico, será valido para el operador [] en a[s.i]
     }s;

     // - el operador exp1[exp2] para acceder a un elemento de un array,
     // espera como operando exp2 un entero, caso contrario arrojará error (semántico)
     struct {
       char* a;
       double i; // esto la haría la expresión s.a[s.i] semánticamente incorrecta
     }s;
   #+END_SRC
** Problema 11 (2020-10-13)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión C: ~lim( x --> 0 )~
   
   1. Si es *sintácticamente correcta* entonces escriba una *declaración* que lo haga también
      *semánticamente correcto*, si no, justifique.
   2. ¿La *expresión* calcula el límite de una función cuando x tiende a 0? Justifique.
   3. ¿Agregar o quitar un espacio en algún lugar podría cambiar la *cantidad de lexemas*?
   Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Si la función ~lim~  recibe por parámetro un entero, entonces podría ser *sintacticamente correcta*
   Una posible declaración sería ~int x, lim(int);~
   
   (2) Falso, la expresión no calcula el limite, porque no existe el operador ~-->~
   en la expresión dada son dos operadores, el decremental ~--~ y el relacional ~>~

   (3) Si, depende en donde coloquemos los espacios, las únicas que varían la cantidad, no sin sintácticamente correctas
   1. Si agregamos un espacio entre ~--~ y ~>~ no habria diferencia, seguiría habiendo 7 lexemas {lim,(x,--,>,0,)}
   2. Otras posibilidades aunque con errores sintácticos (porque no se podrían derivar de la BNF de C) serían
      - Si la dejamos como ~lim(x - - > 0)~ habría 8 lexemas {lim, x,-,-,>,0}
      - Si la dejamos como ~lim(x - -> 0)~ habría 8 lexemas {lim, x,-,->,0}
      - Si agregamos espacio entre alguno de los caracteres del identificador ~lim~ tendriamos más identificadores, por tanto más lexemas
   #+END_QUOTE
** [WAITING] [#A] Problema 12 (2020-03-03) <- interesante
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~0xF+F0x+0L+L0~
   
   1. Indique cuantos *tokens* tiene:
   2. Indique cuantos *tipos de tokens o categorías léxicas* tiene. Justifique:
   3. Indique cuantas invocaciones a ~getchar~ se necesitan para su análisis:
   4. Indique cuantas invocaciones a ~ungetc~ se necesitan para su análisis:
   5. Indique la *categoría sintáctica* a la que pertenece el fragmento (Declaración, Expresión, Sentencia o Error sintáctico)
   6. Escriba la o las *declaraciones* necesarias para que sea un fragmento *semánticamente correcto*
      con tipo ~double~ y valor 15.
   7. Escriba la o las *declaraciones* necesarias para que sea un fragmento *semánticamente incorrecto*
      por *error de tipo*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>:
   El scanner para leer ~0xF+F0x+0L+L0~ hace 7 invocaciones a ungetc según la resolución, y yo veo 6
   el 7 será el EOF?
   #+END_COMMENT

   #+BEGIN_QUOTE
   (3) (4) el scanner hace 20 invocaciones a ~getchar~ (cant. de invocaciones nos da 4+2+4+2+3+2+2 = 20)
   - una invocación por cada caracter leído,
   - dos invocaciones a ~getchar~
     - si el siguiente caracter no pertenece al TOKEN del anterior
     - hace ~ungetc~ para retroceder y volver a leer ese caracter

   cant. de getchar: 3+(2+2+2+2+2)+1+2+2+1= 3+10+6 = 19 getchar
   cant. de ungetc: 6
   
   1. 0xF <- 3 llamadas a getchar (3 lecturas, una por cada caracter)
   2. + <- ungetc porque el + no es una constante entera, por tanto son 2 getchar (la primera lectura, y una nueva)
   3. F0x <- ungetc porque F no es un operador, por tanto 2 getchar + 2 getchar (por los caracteres 0x)
   4. + <- ungetc porque + no es un identificador, por tanto 2 getchar (la primera vez que lo leyó, más una nueva)
   5. 0L <- ungetc porque 0 no es un operador, por tanto 2 getchar + 1 getchar (por la L)
   6. + <- ungetc porque + no es una constante entera, por tanto 2 getchar
   7. L0 <- ungetc porque L no es un operador, por tanto 2 getchar + 1getchar (por el 0)
   
   La secuencia de lectura para ~0xF+F0x+0L+L0~ sería
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | Secuencia de caracteres leídos | Cant. lecturas | Caracter devuelto por ~ungetc~ | Motivo para invocar a ~ungetc~                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | 0xF+                           |              4 | +                              | invoca a ~ungetc~ porque ~+~ no pertenece al tipo de TOKEN identificadores |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | +F                             |              2 | F                              | invoca a ~ungetc~ porque ~F~ no pertenece al tipo de TOKEN operadores      |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | F0x+                           |              4 | +                              | ungetc por ~+~                                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | +0                             |              2 | 0                              | ungetc por ~0~                                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | 0L+                            |              3 | +                              | ungetc por ~+~                                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | +L                             |              2 | L                              | ungetc por ~L~                                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | L0                             |              2 |                                |                                                                            |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   
   (1) Tiene 7 tokens (categorías léxicas)
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | Secuencia de Caracteres | Tipo de Token (ó Categoría Léxica a la que pertenece)                                                            |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~0xF~                   | Constante entera hexadecimal                                                                                     |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~+~                     | Operador                                                                                                         |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~F0x~                   | Identificador (/empiezan con una letra o guión bajo, seguido ó no de numeros,letras,guiones en cualquier orden/) |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~+~                     | Operador                                                                                                         |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~0L~                    | Constante entera octal                                                                                           |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~+~                     | Operador                                                                                                         |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~L0~                    | Identificado (/por empezar con una letra/)                                                                       |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|

      
   (2) tiene 3 tipos de tokens (identificador, constante entera, operador)

   (5) el fragmento ~0xF+F0x+0L+L0~ pertenece a la ctegoria sintáctica Expresión,
   ya que una expresión es una secuencia de operandos y operadores,
   en este caso los operadores son sólo tres ~+~
   y los operandos son identificadores (F0, L0) y constantes enteras (0xF, 0L)
   #+END_QUOTE

   #+BEGIN_SRC C
     // - La siguiente declaración hace a la expresión semánticamente correcta,
     // porque F0x y L0 son identificadores (por empezar con una letra)
     // - Inicializamos en 0, para que el resultado sea 15 (requerimiento)
     double F0x=0, L0=0;

     // 15 + 0 + 0 + 0, resultado = 15
     0xF+F0x+0L+L0;

     // - La siguiente declaración hace a la expresión anterior
     // semanticamente incorrecta, ya que el tipo struct no es un operando
     // válido para usar con el operador '+'
     struct {} F0x, L0;
   #+END_SRC
** [#B] Problema 13 (2020-02-18)
*** Enunciado
   #+BEGIN_SRC C
     {
       int f; // renglón #1
       f+=42; // renglón #2
       f(); // renglón #3
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior *sentencia compuesta*
   
   1. *Analice léxicamente* los tres renglones. Indique cuantos *tokens* hay:
   2. *Analice sintáctimente* cada renglón y clasifique como Error sintáctico, Expresión, Sentencia, ó Declaración.
   3. *Analice semánticamente* la *sentencia compuesta*. Indique si hay un *error semántico* o no y
      justifique. En el caso de haber error semántico indique en qué renglón lo detecta el compilador.
   4. *Analice pragmáticamente* el renglón #2 en el contexto del renglón #1. Indique si hay un error
   pragmático o no. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: El scanner siempre detecta a los caracteres ~(~ y ~)~ como punctuator?,
   en algún momento sabe que son operador ~()~ ?
   
   *Rta*: SI, el scanner sólo los detecta como punctuator porque no sabe si lo estás usando
   como operador.. porque éste recibe una secuencia de caracteres..

   Distinto hubiera sido si te pedían a nivel sintáctico, porque éste recibe una secuencia de tokens
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Cant. de TOKENS: 11 (si analizamos *lexicamente*)
    1. ~int~ (palabra reservada)
    2. ~f~ (identificador)
    3. ~;~ (caracter de puntuación)
    4. ~f~ (identificador)
    5. ~+=~ (operador)
    6. ~42~ (constante entera decimal)
    7. ~;~ (caracter de puntuación)
    8. ~f~ (identificador)
    9. ~(~ (caracter de puntuación)
    10. ~)~ (caracter de puntuación)
    11. ~;~ (caracter de puntuación)

   (2) Usamos de referencia que en Categorías Sintácticas están las Declaraciones, Expresiones, Sentencias
   - Renglon 1: declaración
   - Renglon 2: sentencia expresión
   - Renglon 3: sentencia expresión

   (3) Hay error semántico en el renglon 3, al evaluar la expresión ~f()~,
   ya que el identificador ~f~ se usó previamente para declarar una variable,
   y el operador ~()~ para invocar funciones sólo puede tener como operando el identificador de una función,
   no el de una variable.
   
   (4) En la declaración ~int f~, al no inicializar ~f~ y hacer ~f+=42~,
   lo que hará será sumarle 42 a un valor basura que tiene por defecto ~f~
   #+END_QUOTE
** [#A] Problema 14  (2020-02-12) <- interesante
*** Enunciado
   #+BEGIN_SRC C
     int f(int x){
       if(0)return 1;
       return 42;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice la anterior función:
   
   1. Dentro del *cuerpo de la función*, sin contar las llaves:
      1. Indique cuántas *expresiones* hay
      2. Indique en total cuantas *sentencias* y *subsentencias* hay
      3. Indique cuántas *declaraciones* hay
      4. Indique cuántas invocaciones a ~ungetc~ son necesarias para *analizar léxicamente* el cuerpo de la función
      5. Indique cuantas invocaciones a ~getchar~ son necesarias para detectar el *lexema* ~42~
   2. Escriba y justifique un posible error pragmático (i.e., warning) que un compilador pueda informar. Justifique.
   3. Escriba y justifique otro posible error pragmático. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Antes de resolverlo, recordamos la sintáxis según la BNF de C de algunas de las sentencias es:

   La sentencia de Seleccción:
   ~<sentencia de seleccion> -> if(exp) <sentencia> | if(<exp>) <sentencia> else <sentencia> | switch(<exp>) <sentencia>~

   La sentencia de Expresión:
   ~<sentencia expresion> -> <exp>?;~

   La sentencia de salto:
   ~<sentencia de salto> -> continue; | break; | return <expresion>? | goto <identificador>;~
   #+END_QUOTE

   #+BEGIN_COMMENT   
   <<DUDA>>: (resuelta) No estoy seguro si estará ok el de ungetc y getchar, la respuesta coincide con la resolución
   pero la misma sólo da la cantidad, no detalla

   *Rta*: te faltaba considerar la lectura del espacio, éste es también otro caracter más, al igual que el ~\n~ ó ~\0~ etc..
   #+END_COMMENT
   
   |---------+---+---+----+---+----+--------+-----------+---+----+--------+-----------+---+---+----|
   |         | i | f | (  | 0 | )  | return | ~espacio~ | 1 | ;  | return | ~espacio~ | 4 | 2 | ;  |
   | getchar | x | x | xx | x | xx | xxxxxx | x         | x | xx | xxxxxx | x         | x | x | xx |
   | ungetc  |   |   | x  |   | x  |        | xx        |   | x  |        | xx        |   |   | x  |
   |---------+---+---+----+---+----+--------+-----------+---+----+--------+-----------+---+---+----|

   |----+-----------+---------------------------------------------------------------------------------------------------------------|
   |    | Lexema    | Motivo por el que se invoca a getchar y/o ungetc                                                              |
   |----+-----------+---------------------------------------------------------------------------------------------------------------|
   |  1 | if        | 2 getchar, (dos lecturas)                                                                                     |
   |  2 | (         | ungetc porque ( no es identificador, por tanto 2 getchar                                                      |
   |  3 | 0         | getchar                                                                                                       |
   |  4 | )         | ungetc porque ) no es identificador, por tanto 2 getchar                                                      |
   |  5 | return    | 6 getchar (6 lecturas)                                                                                        |
   |  6 | ~espacio~ | ungetc por tanto 2 getchar ,porque es un caracter especial (ascii) actuaría como centinela para el prox TOKEN |
   |  7 | 1         | getchar                                                                                                       |
   |  8 | ;         | ungetc porque ; no es constante real, por tanto 2 getchar                                                     |
   |  9 | return    | 6 getchar                                                                                                     |
   | 10 | ~espacio~ | ungetc por tanto 2 getchar ,porque es un caracter especial (ascii) actuaría como centinela para el prox TOKEN |
   | 11 | 4         | getchar                                                                                                       |
   | 12 | 2         | getchar                                                                                                       |
   | 13 | ;         | ungetc porque ; no es constante real, por tanto 2 getchar                                                     |

   #+BEGIN_QUOTE
   (1)
   Cant. de expresiones: 3
   1. dos expresiones en la primera sentencia, y en la subsentencia: ~if(exp1)return exp2~
   2. una expresión en la segunda sentencia: ~return exp3~
   
   Cant. de sentencias: 2, Cant de Subsentencias: 1
   1. sentencia de selección: ~if(0)return 1;~
   2. subsentencia (sentencia de salto) ~return 1;~
   3. sentencia de salto ~return 42;~

   Cant. de declaraciones: 0

   Cant. de invocaciones a ~ungetc~: seis

   Cant. de invocaciones a ~getchar~ para leer el lexema ~42~: tres
   |-------------------------+-------------------------------------------------------------------------------------------|
   | Secuencia de caracteres |                                                                                           |
   |-------------------------+-------------------------------------------------------------------------------------------|
   | ~4~                     | 1º invocación, lee la constante entera 4                                                  |
   |-------------------------+-------------------------------------------------------------------------------------------|
   | ~2~                     | 2º invocación, lee la constante entera 2                                                  |
   |-------------------------+-------------------------------------------------------------------------------------------|
   | ~;~                     | 3º invocación, cuando detecta el caracter de puntuación ~;~ sabe que terminó la secuencia |
   |-------------------------+-------------------------------------------------------------------------------------------|
   
   (2) Que el parámetro con identificador ~x~ no se está utilizando, en el cuerpo de la función
   
   (3) Que el comportamiento de ~f~ es retornar siempre 42, ya que la condición de if nunca se cumple al pasarle ~0~
   #+END_QUOTE
** Problema 15 (2019-12-18)
*** Enunciado
   #+BEGIN_SRC C
     /*1*/ int h(int x){
       /*2*/ int y=0;
       /*3*/ y=f(x);
       /*4*/ y=g(y);
       /*5*/ return y;}
   #+END_SRC
   
   #+BEGIN_QUOTE
   Considerando ~int f(int),g(int);~ con ~f~ y ~g~ definidas, analice la anterior función:
   
   1. Indique cuantas *sentencias* tienen la *sentencia compuesta* de la función ~h~.
   2. Analice la *sentencia* de la línea 3:
      1. Enumere cada operación realizada e indique la *precedencia*, uno es la menor.
      2. Escriba en renglones diferentes las *subexpresiones que tiene la expresión*
   3. El compilador emite en la línea tres el mensaje: “se asigna un valor que no es utilizado”.
      1. Si coincide con el mensaje categorice el tipo de error. Justifique.
      2. Proponga una solución para evitar el error. Justifique. 
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Cant. de sentencias del cuerpo de la función h: 3
   1. sentencia expresión: ~y=f(x);~ (/que contiene una expresión de asignación/)
   2. sentencia expresión: ~y=g(y);~ (/que contiene una expresión de asignación/)
   3. sentencia de salto ~return y;~

   (2) Las operaciones de la sentencia expresión ~y=f(x);~
   - La secuencia es
     1. Se invoca a la función ~f~ pasandole un parámetro ~x~ con ~f(x)~
     2. Se le asigna el retorno de ~f(x)~ a ~y~ con ~y=f(x)~
   - La precedencia de los operadores es
     1. precedencia=1 (menor prioridad) el ~=~ operador de asignación de un valor a una variable
     2. precedencia=2 (mayor prioridad) el ~()~ operador para invocar una función
   - Hay 4 subexpresiones en la expresión de asignación ~y=f(x)~
     1) ~y~ es una *expresión primaria* (si derivamos <expresión unaria> -> <expresion sufijo> -> <expresion primaria> -> <identificador>)
     2) ~f~ es una *expresión primaria* (por ser identificador)
     3) ~x~ es una *expresión primaria* (por ser identificador)
     4) ~f(x)~ es una *expresión sufijo* (por ser una invocación)
      
   (3) Sería un *error pragmático*, y surje de la declaración del renglón 2 que inicializa ~y~ con el valor ~0~,
   ese valor no se utiliza, sólo se pisa con el resultado que devuelve ~f(x)~.
   Una posible solución sería reducir las sentencias en una única *sentencia de salto* ~return g(f(x));~
   #+END_QUOTE

   #+BEGIN_QUOTE
   Agregamos parte de la BNF de C, relacionada con ~y=f(x)~ ya que ésta es una *expresión de asignación*,
   si nos guíamos con la gramática de la BNF (reglás sintácticas de C) vemos que los identificadores ~y~, ~f~ y ~x~ son *expresiones primarias*
   ~<expresión unaria> --> <expresion sufijo> --> <expresion primaria> --> <identificador>~
   
   y que ~f(x)~ es una *expresión sufijo* 
   ~<expresión unaria> --> <expresion sufijo> --> <expresión sufijo> (<lista de argumentos>?)~
   
   <expresión de asignación> ->
     <expresión condicional> |
     <expresión unaria> <operador asignación> <expresión de asignación>
     
   <expresión unaria> ->
     <expresión sufijo> |
     ++ <expresión unaria> |
     -- <expresión unaria> |
     <operador unario> <expresión de conversión> |
     sizeof <expresión unaria> |
     sizeof (<nombre de tipo>)
     
   <expresión sufijo> ->
     <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --
     
   <expresión primaria> ->
     <identificador> |
     <constante> |
     <constante cadena> |
     (<expresión>)
   #+END_QUOTE
** [WAITING] [#A] Problema 16 (2019-12-18)
*** Enunciado
   #+BEGIN_QUOTE
   1. Indique el orden de las *etapas fuera y dentro del proceso de compilación*, donde uno (1) es la
      primera. Si no corresponde indíquelo con un guión:
      - Vinculación.
      - Análisis léxico.
      - Previnculación.
      - Análisis sintáctico.
      - Preprocesamiento.
      - Análisis semántico.
      - Generación de código
   2. Tilde todas las afirmaciones verdaderas acerca de C:
      - Una *definición de variable* implica reserva de memoria.
      - Una *declaración de variable* implica reserva de memoria.
      - Las *variables static (estáticas)* de tipo int se inicializan por defecto en cero cuando no tienen *inicializador explícito*
      - Las *variables static (estáticas)* definidas externamente (fuera de toda función) siempre son accesibles desde toda la UT.
      - Para compilar con éxito una *unidad de traducción (UT)* debe tener las *definiciones de todos los identificadores* que aparecen en la misma  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Chequear con alguien las respuestas 2.2, 2.4, y 2.5
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) etapas
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   |   | Nombre de etapa      | Realizada por | Descripción                                                                                               |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 1 | Preprocesamiento     | Preprocesador | Por el preprocesador, aplica las directivas (#if, #else, #define, #include, ...), remueve los comentarios |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 2 | Análisis léxico      | Compilador    | Lee la secuencia de caracteres de los archivos, los agrupa (lexemas) y los clasifica por tipo de TOKEN    |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 3 | Análisis sintáctico  | Compilador    | Recibe los TOKENs generados por el Analizador Lexico                                                      |
   |   |                      |               | Analiza si el conjunto de TOKENs se pueden derivar de las reglas sintácticas BNF de c                     |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 4 | Análisis semántico   | Compilador    | Recibe los Lexemas generados por el Analizador Lexico                                                     |
   |   |                      |               | Analiza el contexto (Ej. redeclaración, la invocación de una función coincide con su firma, ...)          |
   |   |                      |               | Analiza las reglas semánticas (Ej. el operando del operador [] debe ser una constante entera)             |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 5 | Generación de código |               | Los archivos fuente (.c) y archivos de cabecera (.h) en objetos (.o)                                      |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 6 | Vinculación          | Linker        | El Linker/Enlazador enlaza los objetos (.o) con las bibliotecas externas, ...                             |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
      
    No existe la etapa de Previnculación

   (2)
   1) VERDADERO, porque definir una variable implíca memoria. (Ej. ~int edad = 5;~)
   2) FALSO, porque declarar una variable no implíca reserva de memoria (Ej. declaramos una variable del tipo struct, ~struct {} a;~)
   3) VERDADERO, porque las variables ~static~ se inicializan en 0 por defecto, si no se inicializan explicitamente
   4) FALSO, porque las variables definidas ~static~ sólo se pueden usar (scope/ámbito) en el archivo fuente donde se definió,
      no en toda la (UT) *Unidad de Traducción* que está formado por uno ó varios .c con uno ó varios archivos .h
   5) FALSO, la (UT) puede tener sólo las declaraciones de los identificadores para compilar correctamente
   #+END_QUOTE
** [#A] Problema 17 (2019-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~char v[]="ABC";~ tilde todas las expresiones que sí son *ValorL*:
   
   1. v
   2. *v
   3. v+1
   4. v[3]
   5. v<v+1
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | v     | SI es un lvalue porque es una dirección de memoria, pero es un *lvalue NO MODIFICABLE* (/no podemos asignarle un valor ej. v=1/)    |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | v+1   | SI es un lvalue porque también es una dir. de memoria, pero es un *lvalue NO MODIFICABLE* (/mismo caso que con el identificador v/) |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | *v    | SI es lvalue, es una expresión de direccionamiento que apunta al primer elemento del arreglo es equivalente a ~v[0]~                |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | v[3]  | SI es lvalue, es una expresión de subindice [] que no evalúa al arreglo completo, es equivalente a ~*(v+3)~                         |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | v<v+1 | NO es lvalue, porque devuelve una constante entera como resultado de la expresión                                                   |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   #+END_QUOTE
** [WAITING] [#A] Problema 18 (2019-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todos los conceptos que se pueden definir con el *BNF del LF Expresiones de C*:
   
   1. *Efecto de lado* de la expresión.
   2. *Precedencia* de los operadores.
   3. *Asociatividad* de los operadores.
   4. *Orden de evaluación* de los operandos.
   5. *Aridad* (cantidad de operandos) de los operadores
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Donde está definido el efecto de lado de C? En el MROC?,
   Entiendo que es un concepto semántico, pero donde figura?
   
   <<DUDA>>: La asociatividad y la precedencia, indican el orden de las operaciones (osea la *Secuenciación*) ?
   
   <<DUDA>>: (resuelta) yo tenía anotado que...
   la SEMÁNTICA especifíca el orden de evaluación de los operandos ?
   y la SINTAXIS especifíca la asociatividad y precedencia de los operadores ?
   
   *Rta (mi suposicion)*: Si, porque en la semántica no es lo mismo ~n = 10~ (si n es int, ok) que ~10 = n~ (error semántico)
   y en la sintáxis no es lo mismo ~*p++~ (no sabe sabe a donde apuntará p) que ~(*p)++~ (desreferencia el valor de la variable a la que apunta y luego lo incrementa)
   porque ~++~ tiene mayor precedencia que el ~*~ (al parecer)
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) FALSO

   (2) VERDADERO

   (3) VERDADERO

   (4) FALSO, de los operadores
   
   (5) VERDADERO
   #+END_QUOTE
** Problema 19 (2019-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión: ~a[i]+s.m~      
   
   1) A nivel sintáctico: Enumere los *operadores* y su *precedencia* relativa en la expresión dada; cero es la menor precedencia:
   2) A nivel semántico: Escriba las declaraciones que hagan semánticamente correcta a la expresión:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1)  (a[i])  + (s.m)
   |-------------+----------|
   | Precedencia | Operador |
   |-------------+----------|
   |         0   | +        |
   |         1   | .        |
   |         1   | []       |
   |-------------+----------|
   #+END_QUOTE

   #+BEGIN_SRC C
     int i, a[10];
     struct { int m; } s;
   #+END_SRC
** Problema 20 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
   Sea la expresión ~++automata->finales[i]~
   
  1. Reescriba la *expresión* con *paréntesis redundantes* que expliciten la *precedencia y la asociatividad*
  2. Escriba las *declaraciones* para que sea *semánticamente correcta*
   #+END_QUOTE
*** Respuesta
  #+BEGIN_QUOTE
  | 1 | ++automata->finales[i]     |                                                                                    |
  |---+----------------------------+------------------------------------------------------------------------------------|
  | 2 | ++(automata->finales)[i]   | el ~->~ tiene más precedencia que los tres, accede al miembro del puntero a struct |
  |---+----------------------------+------------------------------------------------------------------------------------|
  | 3 | ++((automata->finales)[i]) | el ~[]~ tiene más precedencia que ~++~, accede al elemento del arreglo             |
  |---+----------------------------+------------------------------------------------------------------------------------|
  | 4 | ++((automata->finales)[i]) | el ~++~ es el de menor precedencia                                                 |

  Por tanto la expresión quedaría ~++ ( ( automata -> finales ) [i])~
  #+END_QUOTE

  #+BEGIN_SRC C
    // otra manera..: struct { int finales; } *automata;

    int i;
    struct Estado{ /*...*/ };
    struct { Estado* finales; } Automata;
    Automata* automata;
  #+END_SRC
** Problema 21 (2019-07-15)
*** Enunciado
   #+BEGIN_QUOTE
   Sea la declaración ~int x=3,y=7;~ analice la expresión ~y+=x++<=3~
   
   1. Enumere los tokens.
   2. Indique si tiene *efectos sobre variables*, en ese caso, descríbalos.
   3. Indique el *tipo y el valor de la expresión*
   #+END_QUOTE
*** Respuesta
  #+BEGIN_QUOTE
  (1) Tokens de ~y+=x++<=3~ son seis
  |--------+-------------------------------------|
  | lexema | tipo de token                       |
  |--------+-------------------------------------|
  | y      | identificador                       |
  | +=     | operador                            |
  | x      | identificador                       |
  | ++     | operador (incremento como postfijo) |
  | <=     | operador (relacional)               |
  | 3      | constante (entera)                  |
  |--------+-------------------------------------|

  (2) Los efectos que se producen en ~y+=x++<=3~ son
  | expresión | descripción del efecto producido                                                                    |
  |-----------+-----------------------------------------------------------------------------------------------------|
  | x++       | incrementa en 1 el valor de ~x~ luego de evaluar la expresión donde está contenida                  |
  | y+=x++<=3 | se incrementa el valor de ~y~ en 1, si el ~++~ estuviera como prefijo se mantendría el valor de ~y~ |
  |-----------+-----------------------------------------------------------------------------------------------------|

  (3) El resultado de evaluar ~y+=x++<=3~ es un dato del tipo entero, y su valor es 8
  1. y+=x++<=3
  2. y+=3<=3
  3. y+=1
  4. y=7+1
  5. y=8
  #+END_QUOTE
** [WAITING] Problema 22 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el siguiente fragmento de código C: ~x.1==1LU++LU~
   
   1. Enumere los *lexemas* en orden de aparición y separados por coma.
   2. Justifique si el fragmento es una *expresión sintácticamente correcta* o no.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: En la resolución dice que "luego del operador sufijo ~++~ no se espera una expresión",
   no se referirá a que no espera antes del operador una "constante real"?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Los lexemas de ~x.1==1LU++LU~ son
   | Lexema | Tipo de Token (no lo pide)                      |
   |--------+-------------------------------------------------|
   | x      | identificador                                   |
   | .1     | constante real (es double, porque no tiene ~f~) |
   | ==     | operador                                        |
   | 1LU    | constante entera (long unsigned)                |
   | ++     | operador                                        |
   | LU     | identificador                                   |

   (2) La expresión ~x.1==1LU++LU~ NO es sintacticamente correcta,
   porque al derivarla de las reglas sintácticas (BNF) luego del identificador ~x~ no se espera una constante real ~.1~,
   por lo cual el compilador arroja un error sintáctico y no sigue evaluando el resto de la expresión.
   #+END_QUOTE
** [WAITING] [#B] Problema 23 (2019-02-25)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente declaración: ~int var;~
   
   1. Lexicamente. ¿Cúantas invocaciones a ~getchar~ son necesarias para realizar su *análisis léxico*?
      Asuma que todas las invocaciones son exitosas y que la última retorna ~EOF~. Justifique.
   2. ¿Es semánticamente correcta? Justifique.
   3. Lexicamente y Sintacticamente, si se eliminan los espacios, ¿sigue siendo un *constructo sintáctico válido*? Justifique.
   4. Sintacticamente, si el *lexema* ~int~ se reemplaza por ~T~ ¿sigue siendo una *declaración*? Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: si los identificadores de las variables, funciones, comparten el mismo namespaces,
   porque si tengo una función y una variable con mismo identificador no rompe al compilar?
   
   *Rta (mi suposicion)*: si definis el mismo identificador al definir una función y al declarar una variable,
   arrojará error semántico si tratamos de usarlo para invocar una función porque ahora es una variable

   
   <<DUDA>>: si los identificadores y las constantes de enumeración y los alias de tipo (typedef)
   comparten namespace porque no rompe al compilar?
   *Rta (mi suposicion)*: idem similar al anterior supongo?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Para la declaración ~int var;~ se necesitan 11 invocaciones a ~getchar~
   
   | Lexema  | Cant. invocaciones a ~getchar~ | Motivo                                                                 |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | int     | 3 invocaciones                 | una invocacion por cada caracter                                       |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | espacio | 2 invocaciones                 | dos porque en la 1ra invocación hizo ungetc al no ser un Identificador |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | var     | 3 invocaciones                 | una invocacion por cada caracter                                       |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | ;       | (2 invocaciones                | dos porque en la 1ra invocación hizo ungetc al no ser un Identificador |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | EOF     | (1 invocación                  |                                                                        |
   |---------+--------------------------------+------------------------------------------------------------------------|

   (2) Es semánticamente correcta, según el contexto apesar que sea sintácticamente correcta (se puede derivar de las reglas sintacticas de la BNF),
   - Es semánticamente incorrecta si... en el mismo *Scope/Ambito/Alcance* hay otra variable con el mismo identificador
   - Es semánticamente incorrecta si... en el *Espacio de Nombres* se repite el nombre

   (3) Si, Lexicamente sería un identificador ~intvar~ seguido de un Caracter de Puntuación ~,~
   y Sintácticamente pasaría de ser una *Declaración* a una *Sentencia Expresión* donde ~intvar~ es una *expresión primaria* (identificador)
   Suponemos que previamente se declaró una variable ~intvar~

   (4) Sintacticamente ~T var;~ sería correcto, suponiendo que previamente se usó un ~typedef~ para crear el alias ~T~
   a un tipo de dato ó estructura, y si seguiría siendo una *declaración*
   #+END_QUOTE
** Problema 24 (2019-02-25)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la expresión ~a.b[42].c~
   
   1. Enumere los operadores
   2. Escriba las *declaraciones* para que sea una *expresión* ~int~
   3. Resuelva el anterior ítem utilizando una sola *declaración*, que no use ~typedef~, y haga
   que el valor de expresión sea cero.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Los operadores de la expresión ~a.b[42].c~ son tres
   1. ~.~ (para acceder a un miembro de una estructura ó union)
   2. ~[]~ (para accedera un elemento de un arreglo)
   3. ~.~ (para acceder a un miembro de una estructura ó union)
   #+END_QUOTE

   #+BEGIN_SRC C
     // (2)
     struct B{ int c; };
     struct{ struct B b[42+1]; }a;

     // (3)
     struct{ struct { int c; }b[42+1]; }a = {0};
   #+END_SRC
** Problema 25 (2019-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la siguiente sección de código C: ~x=f(4)[2]~
   
   1. Indique cuantos ~ungetc~ son necesarios para detectar los *lexemas*
   2. Si es una *expresión sintáctimante correcta* escriba una *declaración* que la
      haga *semánticamente correcta*, si no, justifique.
   3. Escriba una *definición de f* que haga que la sección sea *semánticamente correcta*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Se necesita invocar cinco veces a ~ungetc~
   |--------------+----------------------------------------------------------------------------|
   | lexema leído | motivo para invocar ~ungetc~                                               |
   |--------------+----------------------------------------------------------------------------|
   | x=           | ungetc por el ~=~ no pertenece al token de los Identificadores             |
   |--------------+----------------------------------------------------------------------------|
   | =f           | ungetc por ~f~  no pertenece al token de los Operadores                    |
   |--------------+----------------------------------------------------------------------------|
   | f(           | ungetc por ~(~   no pertenece al token de los Identificadores              |
   |--------------+----------------------------------------------------------------------------|
   | 4)           | ungetc por ~)~  no pertenece al token de las constantes numericas enteras  |
   |--------------+----------------------------------------------------------------------------|
   | 2]           | ungtec por ~]~   no pertenece al token de las constantes numericas enteras |
   |--------------+----------------------------------------------------------------------------|
   #+END_QUOTE

   #+BEGIN_SRC C
     // (2)
     char x, *f(int);

     // (3) -> Solución semanticamente correcta
     char* f(int x){
       static char* palabra = "hola";
       return palabra + 1;
     }

     // (3) -> Solución semanticamente correcta, pero pragmaticamente dudosa
     char* f(int x){
       char* ptr; return ptr;
     }
   #+END_SRC
** [WAITING] [#B] Problema 26 (2019-02-11)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente declaración: ~int f ( int ) ;~

   1. A nivel léxico, indique cuantos *lexemas* tiene si se remueven todos los espacios:
   2. Escriba, con la mínima cantidad de *tokens*, una *sentencia semánticamente correcta* que use ~f~
   3. Escriba una *expresión* que use ~f~ pero que sea *semánticamente incorrecta*. Justifique: 
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Si el identificador de un arreglo porque si apunta a una dirección de memoria
   se considera lvalue no modificable..
   
   *Rta: (mi suposición)*: si tenés ~int arr[1]~ el identificador ~arr~ es lvalue por ser un dir. de memoria,
   pero NO es modificable porque debe desreferenciar con el operador de indirección ~*~
   ó.. usar el operador ~[]~ de acceso a elementos de una matriz.
   Ej. Lvalue modificables del ejemplo anterior serian ~*arr~ (desreferencia la posicion del primer elemento)
   ó también ~arr[0]~ ó ~*(arr+0)~

   <<DUDA>>:
   el identificador de una función también apunta a una dir. de memoria, pero no es lvalue,
   por tanto sería una excepción a ser lvalue?
   Ej. Si ~f~ es una función entonces en estas expresiones f no es lvalue, no? f++; f=1;

   <<DUDA>>:
   porque las sig. definición, y la sentencia no arrojan error de tipo incompatibles?
   int x="hola";
   int f(int x){}; f("hola");
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Si a la declaración ~int f ( int ) ;~ le removemos los espacios,
   nos queda la siguiente sentencia expresión ~intf(int);~ que contiene 5 lexemas
   1. ~intf~ <-- identificador
   2. ~(~ <-- caracter de puntuación
   3. ~int~ <-- palabra reservada
   4. ~)~ <-- caracter de puntuación
   5. ~;~ <-- caracter de puntuación
   #+END_QUOTE

   #+BEGIN_SRC C
     // (2)
     // - sentencia expresión que usa la minima cant. de tokens (identificador y caracter de puntuación)
     // - la expresión que contiene es un identificador que representa la dir. de memoria de la variable `f`
     f;

     // (2)
     // otra alternativa, invocar la función pero.. usaríamos 2 tokens más
     f(0);


     // (3) - Las sig. sentencias contienen expresiones que son semanticamente incorrectas,
     // usando el contexto de que `f` es una función

     f++; // error semántico, f no es un lvalue
     f=1; // error semántico, f no es un lvalue
     f[0]; // error semántico, f no es un arreglo
     f.a; // error semántico, f no es un struct ó union
   #+END_SRC
** [#A] Problema 27 (2018-12-17) <- interesante
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión: ~a[i]=f(i)~
   1. Nivel léxico — Indique por lo menos tres *tokens* que no requieran ~ungetc~ para su detección
   2. Nivel sintáctico — Enumere los *operadores* y su *precedencia* relativa en la expresión dada; cero es la menor precedencia
   3. Nivel semántico — Escriba una *declaración* que haga *semánticamente correcta* a la expresión
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (resuelta) (1) la resolución dice que son: [, ], (, )
   pero yo detecté que era a,=,) y.. que algunos de los que menciona si requerían ungetc para ser detectados

   **Rta:* cuando los leen en realidad hacen ungetc, pero no hay otro caracter que junto con los paréntesis, corchetes ó llaves
   formen otra palabra que pertenezca a alguna de las Categorias léxicas.

   1. a <- getchar
   2. [ <- ungetc, por tanto 2 getchar
   3. i <- getchar
   4. ] <- ungetc, por tanto 2 getchar 
   5. = <- getchar
   6. f <- ungetc, por tanto 2 getchar 
   7. ( <- ungetc, por tanto 2 getchar 
   8. i <- getchar
   9. ) <- ungetc, por tanto 2 getchar 
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) Los caracteres que no requieren ~ungetc~ para su detección serían 4, los corchetes y los paréntesis,
   porque no hay una palabra en las *Categorias Lexicas* que esté formado con alguno de ellos,
   o bien podríamos decir que no existe un sublenguaje que contenga una palabra de longitud mayor o igual que 2
   que contenga esos caracteres.
   Un caso opuesto a ellos sería caracter ~<~ porque existen otras palabras formadas por éste como ~<<~, ~<=~
   ó también con el ~=~ que podría haber sido ~==~

   Aunque no se pide en el enunciado, ponemos las llamadas a getchar y ungetc durante la lectura de la cadena de caracteres
   por el Scanner
   |---------+---+----+---+----+---+----+----+---+----|
   |         | a | [  | i | ]  | = | f  | (  | i | )  |
   |---------+---+----+---+----+---+----+----+---+----|
   | ungetc  |   | x  |   | x  |   | x  | x  |   | x  |
   |---------+---+----+---+----+---+----+----+---+----|
   | getchar | x | xx | x | xx | x | xx | xx | x | xx |
   |---------+---+----+---+----+---+----+----+---+----|

   (2) Los operadores de ~a[i]=f(i)~ son
   |----------+-----------------------|
   | operador |           precedencia |
   |----------+-----------------------|
   | =        | 0 (menor precedencia) |
   |----------+-----------------------|
   | []       |                     1 |
   |----------+-----------------------|
   | ()       |                     1 |
   |----------+-----------------------|
   #+END_QUOTE

   #+BEGIN_SRC C
     int i, a[10], f(int);
   #+END_SRC
** Problema 28 (2018-07-30)
*** Enunciado
   #+BEGIN_QUOTE
   2. Sea ~char a[]="SSL";~ tilde todas las *expresiones* que sí son *ValorL modificable*:
   1. ~a~
   2. ~a+1~
   3. ~a[3]~
   4. ~*(a+3)~
   5. ~*(3+a)~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO. La *expresión primaria* ~a~ es un valorL NO modificable
   porque no podemos evaluar la expresión de asignación ~a='z'~
      
   (2) FALSO. La expresión ~a+1~ es un valorL NO modificable,
   porque no podemos evaluar la expresión de asignación ~a+1='c'~
      
   (3) Verdadero. La expresión ~a[3]~ es un valorL modificable,
   por ser una expresión de [] con subindice que no declara un arreglo completo
   (Ej. podemos hacer a[3]="\0")
      
   (4) Verdadero. La expresión ~*(a+3)~ es un valorL modificable,
   se está desreferencia última posición del arreglo, que contiene el caracter especial '\0'
   que indica el fin de una cadena
      
   (5) Verdadero. La expresión ~*(3+a)~ se repite la situación anterior,
   ya que el operador ~+~ es conmutativo
   #+END_QUOTE
** Problema 29 (desconocido)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~fi(x>0)a=x;~
   1) Enumere en orden los caracteres que son devueltos al flujo mediante ungetc durante el análisis léxico:
   2) Realice un análisis de sintáctico de izquierda a derecha y justifique si es una sentencia
   sintácticamente correcta. Si hay error sintáctico, reescríbala con el error encontrado corregido:
   3) Escriba una declaración que haga la sentencia anterior semánticamente correcta
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (1) porque la solución de zuñiga, no considera que el ungetc también devuelve el ~;~ ???
   #+END_COMMENT

   |                | fi | (  | x | >  | 0  | )  | a | =  | x  | ; |
   |----------------+----+----+---+----+----+----+---+----+----+---|
   | ungetc         |    | x  |   | x  | x  | x  |   | x  | x  | x |
   | getchar        | xx | xx | x | xx | xx | xx | x | xx | xx | x |
   |----------------+----+----+---+----+----+----+---+----+----+---|
   | cant. lecturas |    |    |   |    |    |    |   |    |    |   |

   #+BEGIN_QUOTE
   (1) Los caracteres devueltos por ungetc son ~(, > , 0, ), =, x, ;~
   #+END_QUOTE

   #+BEGIN_SRC C
     // (2)

     // - error sintáctico
     // - luego de la invocación de la función `fi` no se espera un identificador
     //
     // fi(x>0) a=x;

     // solución #1: una sentencia expresión usando el caracter de puntuación ','
     fi(x>0), a=x;

     // solución #2: dos sentencias expresión usando el caracter de puntuación ';'
     fi(x>0);a=x;

     // ----------------------------------------------------
     // (3)

     int a,x,fi(int);
   #+END_SRC
** [TODO] Problema 30 (desconocido)
*** Enunciado
   #+BEGIN_QUOTE
   Marque con una cruz si los siguientes *constructos ANSI C* tiene *errores semánticos*, *errores sintácticos*,
   o no tiene error de compilación. Asuma que las funciones estándar están disponibles.
   
   |                                       | Errores Semánticos | Errores Sintácticos | Error Léxico | Sin Error |
   |---------------------------------------+--------------------+---------------------+--------------+-----------|
   | {int 2z=0; 2z += 1;}                  |                    |                     |              |           |
   |---------------------------------------+--------------------+---------------------+--------------+-----------|
   | {int a=7; while a-- printf(“%d”, a);} |                    |                     |              |           |
   |---------------------------------------+--------------------+---------------------+--------------+-----------|
   | {char *a = malloc(5); a[8]=Á'+2;}     |                    |                     |              |           |
   |---------------------------------------+--------------------+---------------------+--------------+-----------|
   | {int a; float a; for(;;) a++;}        |                    |                     |              |           |
   |---------------------------------------+--------------------+---------------------+--------------+-----------|
   | {int v[5],*p; p=v; *v++=3; *p++=2;}   |                    |                     |              |           |
   |---------------------------------------+--------------------+---------------------+--------------+-----------|
   #+END_QUOTE
** [#A] Problema 31 (desconocido)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente sentencia compuesta: ~{short a=0;{char a; a;}while(1)a;}~
   1) ¿Cuántos *lexemas* posee?
   2) ¿Cuántas *expresiones*?
   3) ¿Es *semánticamente correcta*? ¿Por qué?
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Si lo analizamos léxicamente, el Scanner detectaría 20 lexemas

   (2) Si lo analizamos sintácticamente, el Parser detectaría 4 expresiones,
   recordando que el constructo sintáctico de una expresión primaria es
   ~<expresión primaria> -> <identificador> | <constante> | <literal cadena> | (<expresión>)~
   (en realidad va un salto de linea luego ó antes del pipe pero así queda más entendible :))

   (3) SI es semánticamente correcta, separamos las sentencias para analizarlas
   #+END_QUOTE
   
    |-----------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------|
    | constructo sintáctico | tipo de constructo (categoría sintáctica) | motivo porque es semánticamente correcta                                                            |
    |-----------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------|
    | ~short a=0;~          | declaración                               | porque ~short~ es un tipo numérico más chico que ~int~                                              |
    |-----------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------|
    | ~{char a; a;}~        | sentencia compuesta                       | porque contiene una declaración válida al ser otro scope, seguido de una sentencia expresión válida |
    |-----------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------|
    | ~while(1)a;~          | sentencia de iteración                    | porque el while sólo necesita una expresión que lo controle seguido de una sentencia                |
    |-----------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------|
     
   |---+-----------+-----------------------------------------------+-----------------------------------------------------------------------------|
   |   | Expresion |                                               | motivo                                                                      |
   |---+-----------+-----------------------------------------------+-----------------------------------------------------------------------------|
   | 1 | a=0       | expresión de asignación                       | porque luego de declarar se inicializó en 0                                 |
   | 2 | a         | expresión primaria (por ser identificador)    | porque si, está sóla dentro de la sentencia expresión                       |
   | 3 | 1         | expresión primaria (por ser constante entera) | es la expresión que controla al while.. ~while(exp)~                        |
   | 4 | a         | expresión primaria (por ser identificador)    | porque si, está sóla dentro de la subsentencia de la sentencia de iteración |
   |---+-----------+-----------------------------------------------+-----------------------------------------------------------------------------|

   |----+--------+----------------------------------|
   |    | Lexema | Tipo de TOKEN (categoría léxica) |
   |----+--------+----------------------------------|
   |  1 | {      | caracter de puntuación           |
   |  2 | short  | palabra reservada                |
   |  3 | a      | identificador                    |
   |  4 | =      | operador                         |
   |  5 | 0      | constante numérica entera        |
   |  6 | ;      | caracter de puntuación           |
   |  7 | {      | caracter de puntuación           |
   |  8 | char   | palabra reservada                |
   |  9 | a      | identificador                    |
   | 10 | ;      | caracter de puntuación           |
   | 11 | a      | identificador                    |
   | 12 | ;      | caracter de puntuación           |
   | 13 | }      | caracter de puntuación           |
   | 14 | while  | palabra reservada                |
   | 15 | (      | caracter de puntuación           |
   | 16 | 1      | constante numérica entera        |
   | 17 | )      | caracter de puntuación           |
   | 18 | a      | identificador                    |
   | 19 | ;      | caracter de puntuación           |
   | 20 | }      | caracter de puntuación           |
   |----+--------+----------------------------------|
* Nivel Léxico
** Problema 1
*** Enunciado
   #+BEGIN_QUOTE
   Analizar la siguiente declaración: ~int f ( int ) ;~
   e indique cuantos *lexemas* tiene si se remueven todos los espacios:   
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   1. intf
   2. (
   3. int
   4. )
   5. ;
   #+END_QUOTE
** [WAITING] [#B] Problema 2 (2021-02-10) <- pendiente lex/flex
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas acerca del *análisis léxico*
    
    1. Es realizado por *lex/flex*
    2. Detecta a ~"hola\"~ como *léxicamente correcto*
    3. Reconoce a ~main~ como *palabra clave (keyword)*
    4. Puede generar un mismo *token* a partir de diferentes *lexemas*
    5. Puede diferenciar cuando un símbolo actúa como *operador, punctuator, ó separador* .
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Las últimas dos preguntas, estarán ok?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (2) FALSO. La secuencia de caracteres ~"hola\"~ no es léxicamente correcta,
   al usar el ~\~ se escapa las comillas dobles (que son un caracter especial) y las toma como un caracter común,
   para ser *literal cadena* los caracteres deben estar delimitadas entre comillas dobles
   
   (3) FALSO. El *lexema* ~main~ NO es una *palabra reservada*,
   podríamos escribir la sig. declaración sin problema ~struct main{ int x; }~

   (4) VERDADERO. A partir de diferentes *lexemas* (Ej. for, while, ...) puede generar el mismo TOKEN,
   Ej. for, while son lexemas diferentes pero se genera el mismo tipo de TOKEN (palabra reservada)
   
   (5) El *analizador léxico* no sabe si un símbolo actúa como *operador* ó *caracter de puntuación*,
   porque no sabe del contexto, ni la sintáxis del lenguaje.
   Este sólo lee caracter por caracter de una secuencia de caracteres
   según el contexto se podría saber si actúa como *punctuator* u *operador* pero.. el Scanner no sabe de eso.

   Notas:
   1) En C el scanner (analizador léxico) NO puede almacenar/buscar en la (TS) *tabla de símbolos*
   2) En LP simples, el analizador léxico podría almacenar/buscar en la (TS)
   #+END_QUOTE
** [TODO] Problema 3 (2021-02-17) <- pendiente lex/flex
*** Enunciado
   #+BEGIN_QUOTE
   Indique todas las afirmaciones verdaderas sobre el *análisis léxico*:
   
   1. Lo puede realizar la salida de lex/flex.
   2. Utiliza *lexemas* para construir *tokens*.
   3. Detecta a ~'\''~ como *léxicamente correcto*
   4. Reconoce a ~printf~ como *palabra clave (keyword)*
   5. Detecta cuando el asterisco (*) actúa como *operador binario* o *unario*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (2) Verdadero. El *analizador léxico* lee una secuencia de caracteres, caracter por caracter
   y genera *lexemas*. Usa los *lexemas* para construir *tokens* (que usará el analizador sintáctico)

   (3) Verdadero. El Scanner lee el lexema ~'\''~ como una *constante caracter*,
   porque al usar el ~\~ escapa la comilla simple y lo interpreta como un caracter común
   
   (4) FALSO. El lexema ~printf~ NO es una *palabra reservada*,
   si lo fuera no podriamos realizar la siguiente declaración ~struct printf{ }~
   
   (5) FALSO. El Analizador léxico, no sabe del contexto ni sintáxis,
   por tanto no sabe si el operador ~*~ actúa como operador binario o unario,
   sólo sabe que es un operador
   #+END_QUOTE
** [WAITING] [#B] Problema 4 (2019-12-11)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis léxico*
   
   1. Puede implementarse con un *AF*
   2. Procesa su entrada caracter a caracter.
   3. ~s(printf)~ es siempre *léxicamente correcto*
   4. Un *lexema* dado puede generar diferentes *lexemas*
   5. Diferencia entre *identificadores* y *palabras clave (keywords)*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Como justificar mejor la 4, 5 (?)

   <<DUDA>>: (4) podriamos decir..? si tenemos el lexema ~abc~ no puede representar otro a menos que lo alteremos,
   osea le saquemos ó agregemos otro caracter
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) VERDADERO, el Scanner (analizador léxico) se puede implementar con un AF,
   donde la transición de un estado a otro depende de la secuencia de caracteres leídos
   
   (2) VERDADERO, porque el Scanner lee caracter a caracter

   (3) VERDADERO, porque ~s(printf)~
   - cada palabra pertenece a un LR de las Categorías Léxicas (Identificador, Operador, ...)
   - si clasificamos esos lexemas por tipo de Token tenemos identificador,punctuator,identificador,punctuator

   (4) FALSO, 

   (5) VERDADERO, porque los *identificadores* y las *palabras clave* son dos *categorías léxicas*,
   cada una representa un (LR) generado por su (GR)
   #+END_QUOTE

   #+BEGIN_QUOTE
   Para tener de referencia, nos guiamos con la siguiente *Gramática* para los TOKENs
   
   <token> ->
     <palabra reservada> |
     <identificador> |
     <constante> |
     <literal de cadena> |
     <punctuator>
   
   <token de preprocesamiento> ->
     <nombre de encabezado> |
     <identificador> |
     <número de preprocesador>|
     <constante carácter> |
     <literal de cadena> |
     <punctuator> |
     cada uno de los caracteres no-espacio-blanco que no sea uno de los anteriores

   <palabra reservada> -> una de
      auto break case char const continue default do
      double else enum extern float for goto if
      int long register return short signed sizeof static
      struct switch typedef union unsigned void volatile while

   <identificador> -> <no dígito> | <identificador> <no dígito> | <identificador> <dígito>
     <no dígito> -> uno de _ a b c d e f g h i j k l m n o p q r s t u v
       w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
     <dígito> -> uno de 0 1 2 3 4 5 6 7 8 9
   #+END_QUOTE
** Problema 5 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis léxico*
   
   1. *Recibe lexemas* y *genera tokens*
   2. ~ungetc~ devuelve al flujo el último token leido.
   3. Un *token* puede ser generado por *diferentes lexemas*
   4. En C, ~prontf("hola")~, es siempre *léxicamente correcto*
   5. Se puede determinar el operador que representa el lexema asterisco (*).
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO, el Scanner recibe una secuencia de caracteras y genera tokens (para el Parser) y lexemas (para el analizador semantico)

   (2) FALSO, cuando el Scanner invoca el ~ungetc~, éste devuelve el último caracter leído,
   suponiendo que éste no pertenece al tipo de TOKEN de la secuencia de caracteres leidos que le precede

   (3) VERDADERO, un TOKEN del tipo Identificador podría ser generador por varios lexemas
   (Ej. estos tres lexemas edad, nombre, apellido son identificadores)

   (4) VERDADERO, ~prontf("hola")~ para el Scanner está formado por identificador,punctuator,literal cadena, punctuator
   porque lee caracter por caracter invocando ~getchar~ y por cada caracter que no pertenece a la gramática de la secuencia leida
   invoca a ~ungetc~ y continúa leyendo, por tanto reconoceria cada lexema

   (5) FALSO, el Scanner no sabe del contexto y no puede determinar que tipo de operador es
   el lexema asterisco ~*~ solo reconoce el tipo de TOKEN, en este caso operador
   #+END_QUOTE
** [WAITING] [#A] Problema 6 (2018-10-03) <- interesante
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente función: ~int f(void){return 1<*p++;}~
   1. Indique cuantos *tokens* hay
   2. Indique los tres *tokens* que pertenecen a un *LF infinito*
   3. Indique por lo menos tres *tokens* que no requieran ~ungetc~ para su detección
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (2) Los identificadores son LF infinitos porque apesar de que tiene un número finito de caracteres el alfabeto,
   se pueden generar un número infinito de palabras?

   <<DUDA>>: (2) Las constantes numéricas, son LF infinitos por lo mismo de arriba?


   <<DUDA>>: (resuelta) (3) porque la resolución dice que el (, ), no necesitan ungetc?
   
   **Rta:* cuando los leen en realidad hacen ungetc, pero no hay otro caracter que junto con los paréntesis, corchetes ó llaves
   formen otra palabra que pertenezca a alguna de las Categorias léxicas.
   #+END_COMMENT
   
   |----------------+-----+-----------+---+----+------+----+---+--------+-----------+---+----+---+----+----+---+---|
   |                | int | ~espacio~ | f | (  | void | )  | { | return | ~espacio~ | 1 | <  | * | p  | ++ | ; | } |
   |----------------+-----+-----------+---+----+------+----+---+--------+-----------+---+----+---+----+----+---+---|
   | unget          |     | x         |   | x  |      | x  |   |        | x         |   | x  |   | x  | x  |   |   |
   | getchar        | xxx | xx        | x | xx | xxx  | xx | x | xxxxxx | xx        | x | xx | x | xx | xx | x | x |
   |----------------+-----+-----------+---+----+------+----+---+--------+-----------+---+----+---+----+----+---+---|
   | cant. lecturas | 3   | 2         | 1 | 2  | 3    | 2  | 1 | 6      | 2         | 1 | 2  | 1 | 2  | 2  | 1 | 1 |
   |----------------+-----+-----------+---+----+------+----+---+--------+-----------+---+----+---+----+----+---+---|

   |--------+-----------------------------|
   | Lexema | Tipo de Token               |
   |--------+-----------------------------|
   | int    | Palabra Reservada           |
   |--------+-----------------------------|
   | f      | Identificador               |
   |--------+-----------------------------|
   | (      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | void   | Palabra Reservada           |
   |--------+-----------------------------|
   | )      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | {      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | return | Palabra Reservada           |
   |--------+-----------------------------|
   | 1      | Constante numérica (entera) |
   |--------+-----------------------------|
   | <      | Operador (relacional)       |
   |--------+-----------------------------|
   | *      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | p      | Identificador               |
   |--------+-----------------------------|
   | ++     | Operador                    |
   |--------+-----------------------------|
   | ;      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | }      | Caracter de Puntuación      |
   |--------+-----------------------------|

   #+BEGIN_QUOTE
   (1) En ~int f(void){return 1<*p++;}~ hay 14 tokens
   
   (2) Los TOKENs de la sentencia compuesta que pertenecen a un LF infinito son:
   1. f -> Identificador
   2. 1 -> Constante numérica (entera)
   3. p -> Identificador
   
   (3) Los caracteres que no requieren ~ungetc~ para su detección serían 5, los paréntesis, las llaves y el punto y coma
   porque no hay una palabra en las *Categorias Lexicas* que esté formado con alguno de ellos,
   o bien podríamos decir que no existe un sublenguaje que contenga una palabra de longitud mayor o igual que 2
   que contenga esos caracteres.
   Un caso opuesto a ellos sería caracter ~<~ porque existen otras palabras formadas por éste como ~<<~, ~<=~
   ó también con el ~=~ que podría haber sido ~==~

   Aunque no se pide en el enunciado, ponemos las llamadas a getchar y ungetc durante la lectura de la cadena de caracteres
   por el Scanner
   #+END_QUOTE
** Problema 29 (2018-02-19)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~{ T v,*p; v =f(1.0 ) ;switch( v.m1){p= v .m2;} }~
   Analice léxicamente y tilde la afirmación falsa:
   1. Es léxicamente correcto.
   2. Contiene dos tokens punto (.).
   3. Los espacios son intrascendentes en el análisis léxico.
   4. Al remover todos los espacios la cantidad de tokens varía.
   5. Agregar un espacio en cualquier lugar lo mantiene léxicamente correcto.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero

   (2) Verdadero, tiene dos tokens ~.~
   - ~v.m1~
   - ~v.m2~

   (3) FALSO, los espacios pueden generar menos ó mayor cantidad de lexemas.
   Ej. Si la palabra reservada ~switch~ y pasaría a ser 6 identificadores ~s w i t c h~,
   sin tener en cuenta si es sintacticamente ó semánticamente correcta o no.

   (4) Verdadero,
   Ej. ~T v~ son dos identificadores, si removemos los espacios sería ~Tv~ por tanto sería 1 identificador

   (5) Verdadero
   #+END_QUOTE
* Nivel Sintáctico
** [WAITING] [#B] Problema 1 (2021-02-10) <- interesante
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas acerca del *Análisis Sintáctico*
    
    1. Recibe una *secuencia de tokens*
    2. Un *parser* diferencia *expresiones de sentencias*
    3. Puede detectar el error de variable no declarada.
    4. ~printf(main)~ es siempre *sintácticamente correcto*
    5. Aplica el *orden de evaluación* del *operador ternario* ~?:~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero, El *analizador sintáctico* recibe una secuencia de *TOKENS* generados por el Analizador Léxico
   
   (2) Verdadero, El Parser diferencia entre *expresiones* y *sentencias*, porque son parte de las *categorías sintácticas* de la BNF de c,
   es más son dos *categorías sintáticas* de las 3 que hay (expresiones, sentencias, declaraciones)
   
   (3) FALSO, El Parser no sabe si una variable fue declarada o no, porque no conoce el contexto
   (el analizador semántico si, por tanto si ocurriera sería un error semántico)
   
   (4) Verdadero, La expresión ~printf(main)~ es sintácticamente correcta porque se puede derivar de la BNF de C,
   pero es semanticamente incorrecta porque la firma de printf espera una cadena de caracteres como primer argumento
   #+END_QUOTE

   #+BEGIN_COMMENT
   Falso, C especifica que el *orden de evaluación del Operador Ternario* ~exp1 ? exp2 : exp3~ es de de izq. a derecha,
   el Parser evalúa de Izq a Der ó Der a Izq según la precedencia y asociatividad de los OPERADORES según la sintáxis del lenguaje,
   osea según las reglas/constructos sintácticos de la BNF de C, donde si dos operadores tienen igual precedencia
   se evaluará según la asociatividad
   #+END_COMMENT
** [TODO] [#C] Problema 2 (2021-02-17) <- pendiente yacc/bison
*** Enunciado
   #+BEGIN_QUOTE
   Indique todas las afirmaciones verdaderas sobre el *análisis sintáctico*:
   
   1. Detecta un error en ~printf()~
   2. Recibe una *secuencia de caracteres*
   3. Lo puede realizar la salida de *yacc/bison*
   4. Puede diferenciar si un *token* se usa como *puntuación* u *operador*
   5. Puede detectar un error en la cantidad de argumentos usados al invocar una función.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: La última estará bien justificada (???)
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) FALSO. Es un error semántico, que lo detecta el Analizador Semántico

   (2) FALSO. El analizador sintáctico recibe una secuencia de TOKENs (generados por el analizador léxico)

   (4) VERDADERO. En las reglas sintácticas de la BNF de C (ó constructos sintácticos)

   (5) FALSO. Es el analizador semántico, que chequea la cant. de argumentos de invocar una función,
   comparando con la firma de la función invocada, porque analiza según el contexto
   #+END_QUOTE
** [TODO] Problema 3 (2020-03-03)
*** Enunciado
   #+BEGIN_QUOTE
   1. Indique el valor de verdad de la siguiente afirmación y justifique:
      *La sintaxis de C especifica el orden de evaluación de los operandos* y *la precedencia de los operadores*
   2. Escriba un fragmento breve que sea sintáctimente válido tanto en C y como en C++, pero
      que tenga diferente semántica para cada LP.  
   #+END_QUOTE
*** Respuesta
** [TODO] Problema 4 (2020-02-12) (2020-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   1. Ejemplifique brevemente un aspecto sintáctico en el cual el LP C es
      diferente a otro LP que usted conozca. Justifique.
   2. Indique y justifique el valor de verdad de la siguiente afirmación:
      Los LP C y C++ tienen la misma sintaxis.
   #+END_QUOTE
** [WAITING] [#A] Problema 5 (2019-12-11) <- pendiente PAS
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. Un *parser* procesa *expresiones*
   2. Un *PAS* puede invocar al *scanner*
   3. ~s(printf)~ es siempre *sintácticamente correcto*
   4. El *operador de acceso a miembro* ~(.)~ *es conmutativo*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (1) está ok la justificación?

   <<DUDA>>: (3) como la derivamos de la BNF? <- arbol sintáctico?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) FALSO, procesa una secuencia de TOKENs (son lexemas, que el Scanner generó según las reglas léxicas de una secuencia de caracteres)
   
   (3) VERDADERO, la expresión ~s(printf)~ la podemos derivar de la BNF de C
   
   (4) FALSO, el operador ~.~ de acceso a miembro no es conmutativo,
   el operando de la derecha es el miembro al que se accederá del operando de la izquierda
   (/Ej. struct { int x, y; } pos; no es lo mismo pos.x que x.pos/)
   #+END_QUOTE

   #+BEGIN_QUOTE
   <expresión> ->
     <expresión de asignación> |
     <expresión> , <expresión de asignación>
     
   <expresión de asignación> ->
     <expresión condicional> |
     <expresión unaria> <operador asignación> <expresión de asignación>
     
   <operador asignación> -> uno de
     = *= /= %= += -= <<= >>= &= ^= |=

   <expresión unaria> ->
     <expresión sufijo> |
     ++ <expresión unaria> |
     -- <expresión unaria> |
     <operador unario> <expresión de conversión> |
     sizeof <expresión unaria> |
     sizeof (<nombre de tipo>)
     <expresión sufijo> ->

   <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --

   <expresión primaria> ->
     <identificador> |
     <constante> |
     <constante cadena> |
     (<expresión>)
   #+END_QUOTE
** [TODO] Problema 6 (2019-12-04) <- pendiente YACC
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. *Yacc* es un *parser*
   2. Un parser procesa una *secuencia de tokens*
   3. En C, ~prontf("hola")~ es siempre *sintácticamente correcto*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (2) VERDADERO, el Parser ó Analizador Sintáctico lee una secuencia de tokens (generados por el Scanner)

   (5) VERDADERO
   #+END_QUOTE
** [WAITING] [#A] Problema 7 (2019-02-11)
*** Enunciado
   #+BEGIN_QUOTE
   Indique con Verdadero/Falso los *conceptos asociados a la sintaxis*
   
   1. BNF.
   2. Orden de tokens.
   3. Valor-l modificable.
   4. Precedencia de operadores.
   5. Orden de evaluación de operandos  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: En la (2) es Verdadero... sería el orden en que los recibe/lee?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Verdadero, la BNF contiene las reglas/constructos sintácticas del lenguaje

   (3) Falso, si un valorl es modificable o no, es a nivel semántico.
   Un caso más común es al declarar una variable con el calificador de tipo ~const~,
   éste lo hace un lvalue no modificable.

   (4) Verdadero, la sintaxis indica la precedencia de los operadores en la BNF.
   Más cerca está del axioma, menos es su precedencia(prioridad).

   (5) Falso, la sintaxis no especifíca el orden de evaluación de los operandos,
   pero si el de los operadores en la BNF.
   #+END_QUOTE
** [WAITING] [#C] Problema 8 (2018-10-03) <- interesante
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente función: ~int f(void){return 1<*p++;}~
   Dentro de la sentencia compuesta:
   1. Indique cuantas *declaraciones* hay
   2. Indique el *operador* con menor *precedencia*
   3. Indique cuántas *expresiones*, contando las *subexpresiones*, hay; por ejemplo 40+2 tiene tres expresiones
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (3) porque no consideró como expresiones a ~*p~ y ~1<*p~ ?
   la resolución solo dice que hay cinco.. 1, p, p++, *p++, 1<*p++
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) En la sentencia compuesta ~{return 1<*p++;}~ no hay declaraciones

   (2) Para la predencia operadores de ~{return 1<*p++;}~
   usamos paréntesis redundantes para identificar la precedencia de cada operador ~return 1 < ((*p)++)~
   
   |----------+-----------------------|
   | Operador | Precedencia           |
   |----------+-----------------------|
   | <        | 0 (menor precedencia) |
   | ++       | 1                     |
   | *        | 2 (mayor precedencia) |
   |----------+-----------------------|

   (3) Las expresiones que contiene la sentencia compuesta ~{return 1<*p++;}~ son siete
   1. 1  <-- es una *expresión primaria* (por ser constante numérica)
   2. p  <-- es una *expresión primaria* (por ser identificador)
   3. ~*p~ <-- es una *expresión unaria* (por ser el operador de indirección * un operador unario)
   4. *p++
   5. p++ <-- es una *expresión unaria* (al tener el operador ++ lo hace una expresión sufijo)
   6. 1<*p
   7. 1<*p++

   Nota: ~return~ es una *palabra reservada*, no forma parte de las expresiones
   #+END_QUOTE

   #+BEGIN_QUOTE
   Dejamos una parte de la BNF de las expresiones como referencia
   
   <expresión unaria> ->
     <expresión sufijo> |
     ++ <expresión unaria> |
     -- <expresión unaria> |
     <operador unario> <expresión de conversión> |
     sizeof <expresión unaria> |
     sizeof (<nombre de tipo>)
     
   <nombre de tipo> 
   
   <operador unario> -> uno de & * + - ~ !
   
   <expresión sufijo> ->
     <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --
     
   <expresión primaria> ->
     <identificador> |
     <constante> |
     <constante cadena> |
     (<expresión>)
   #+END_QUOTE
** [#A] Problema 9 (2018-02-19)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~{ T v,*p; v =f(1.0 ) ;switch( v.m1){p= v .m2;} }~
   Analice sintácticamente y tilde la afirmación falsa:
   1. Contiene una *declaración*
   2. Contiene dos *invocaciones*
   3. Contiene tres *expresiones completas*
   4. Contiene por lo menos tres *sentencias*
   5. Contiene por lo menos cinco *subexpresiones*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (resuelta) la resolución de la (3) dice que es verdadera, por que? cuales son?
   para mi habian dos y eran las *expresiones de asignación* la tercera sería la expresión que controla al switch?

   *Rta:* Si, la tercera es la expresión que controla al switch (exp)
   #+END_COMMENT
   
   |---+------------+-------------------------|
   |   | expresión  | tipo de expresión       |
   |---+------------+-------------------------|
   | 1 | ~v=f(1.0)~ | expresión de asignación |
   |---+------------+-------------------------|
   | 2 | ~(v.m1)~   | expresión (exp)         |
   |---+------------+-------------------------|
   | 3 | ~p=v.m2~   | expresión de asignación |
   |---+------------+-------------------------|

   |---+---------------------+----------------------------|
   |   | sentencia           | tipo de sentencia          |
   |---+---------------------+----------------------------|
   | 1 | ~v=f(1.0);~         | sentencia expresión        |
   |---+---------------------+----------------------------|
   | 2 | ~switch(v.m1){...}~ | sentencia iteración switch |
   |---+---------------------+----------------------------|
   | 3 | ~p=v .m2;~          | sentencia expresión        |
   |---+---------------------+----------------------------|

   #+BEGIN_QUOTE
   (1) Verdadero
   La declaración es ~T v, *p;~ declara ~v~ y ~*p~ del tipo ~T~ (usando typedef para definir el alias T de un tipo de dato)

   (2) FALSO.
   Sólo una y es ~f(1.0 )~

   (3) Verdadero
   
   (4) Verdadero
   
   (5) Verdadero
   tenemos como mínimo 5, si contamos las *expresiones primarias* (identificadores, constantes, literal cadena)
   1. v
   2. f
   3. 1.0
   4. f(1.0)
   5. v
   6. m1
   7. v.m1
   8. p
   9. v
   10. m2
   11. v.m2
   #+END_QUOTE
** [#A] Problema 10 (desconocido)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~double d=1;~ analice el fragmento ~++d++~ y responda:
   
   1. ¿A qué *categoría sintáctica* pertenece?
   2. ¿Cuántos *operandos* tiene?
   3. ¿Es *semánticamente correcta*? ¿Por qué?
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) el fragmento ~++d++~ pertenece a la categoría sintácica *expresión*

   (2) la expresión ~++d++~ tiene dos operandos (aunque NO sea semánticamente correcta)
   - ~d~ es el operando del operador ~++~ como prefijo
   - ~++d~ es el operando del operador ~++~ como sufijo <- acá lanzaría un error semántico, por no ser ~++d~ un lvalue válido

   (3) la expresión ~++d++~ no es semánticamente correcta,
   porque al evaluarla hace
   1. ~++d~ (incrementa en 1 el valor de ~d~)
   2. ~1++~ falla luego de evaluar ++d el resultado es una constante numérica real, por tanto no es un lvalue válido para el operador ~++~
   #+END_QUOTE
** [#A] Problema 11 (desconocido)
*** Enunciado
   #+BEGIN_QUOTE
   Analice sintácticamente la siguiente función y describa tres errores sintácticos, en orden de aparición:
   ~void f(int a){int a=(); switch(a){a} return 2;}}~
   #+END_QUOTE
*** Respuesta
   | fragmento | motivo del error sintáctico                            |
   |-----------+--------------------------------------------------------|
   | ~();~     | se espera que los paréntesis ~()~ tengan una expresión |
   | ~{a}~     | se espera que luego del identificador ~a~ haya un ~;~  |
   | ~}}~      | no se espera un segundo ~}~                            |
   |-----------+--------------------------------------------------------|
* Nivel Semántico
** Problema 1 (2021-08-04)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba *declaraciones* que hagan que la siguiente expresión sea *semánticamente válida* y que
   la expresión a la derecha de la asignación sea un *valor-l no modificable*
   
   ~c = a[1].b~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     int c;
     const struct { int b; } a[10]; // declaramos un vector 'a' del tipo de un struct anónimo

     // - la expresión a[1].b es un valor-l NO modificable
     // - es lvalue porque b es un miembro del struct a, y es un operando
     // válido para el operador de asignacion =
     // - no es modificable porque el struct lo impide, es de sólo lectura por ser const
     c = a[1].b;
   #+END_SRC
** Problema 2 (2021-03-10)
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas acerca del *Análisis Semántico*
    
    1. Utiliza la *tabla de símbolos*
    2. Detecta un error en ~for-while~
    3. Puede _detectar argumentos faltantes_
    4. Debe detectar si una *variable se usa sin inicializar*
    5. ~struct S{struct S m;};~ puede ser *semánticamente correcto*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   El *Analizador Semántico* usa la *tabla de símbolos*

   En la expresión ~for-while~ el que encuentra error es el *Analizador sintáctico* (Parser),
   porque no se puede derivar usando las *reglas sintácticas de la BNF de C*
   
   Como el *analizador semántico* conoce el contexto, entonces puede revisar
   las firmas de las funciones y detectar si faltan o no argumentos,
   cuando son invocadas.
   #+END_QUOTE

   #+BEGIN_COMMENT
   <<DUDAS>>:
   No es responsabilidad del *analizador semántico* detectar si una variable se usa sin inicializar,
   pero si debe validar la redeclaración de una variable, ó redefinición de una función, por ej.
   
   la sentencia expresión ~struct S{struct S m;};~ NO es semánticamente correcta,
   porque... (?)
   #+END_COMMENT
** Problema 3 (2021-02-17)
*** Enunciado
   #+BEGIN_QUOTE
   Indique todas las afirmaciones verdaderas sobre el *análisis semántico*:
   
   1. Lee la *tabla de símbolos*
   2. Detecta un error en ~if()~
   3. Puede detectar el uso de una *variable no declarada*
   4. Debe detectar si una variable se declara pero no se usa.
   5. La declaración ~int v[5];~ es siempre *semánticamente correcta*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero

   (2) Falso. Es un error sintáctico, se deduce al tratar de derivar la expresión
   usando la BNF de C

   (3) Verdadero. Si se utiliza en una expresión, y ésta no fue declarada previamente, es un error semántico

   (4) Falso.

   (5) Falso. Se debe evaluar el contexto donde fue declarada..
   Ej. No sería semánticamente correcta si ya fue declarada previamente una variable con el identificador ~v~
   #+END_QUOTE

   #+BEGIN_COMMENT
   La (4) es un warning que arroja el compilador,
   se necesita saber más detalle de eso?
   #+END_COMMENT
** Problema 4 (2019-12-11)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis semántico*
   
   1. Tiene en cuenta el contexto.
   2. Hay un *error semántico* en ~while++~
   3. Detecta errores de programación (bugs).
   4. Usa los *prototipos* para validar las invocaciones.
   5. ~s(printf)~ es siempre *semánticamente correcto*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) VERDADERO, en el Análisis Semántico se chequea el contexto (Ej. puede analizar si al invocar una función, ésta respeta su firma)

   (2) FALSO, ~while++~ es un *error SINTACTICO*,
   porque el Parser al derivar de la BNF sabe que luego del ~while~ no espera un operador ~++~

   (3) FALSO,

   (4) VERDADERO, en el Analisis Semántico se usa los prototipos para validar las invocaciones
   porque se tiene en cuenta el contexto

   (5) FALSO, ~s(printf)~ podría no ser *semanticamente correcto* si el prototipo de ~s~ es ~int s(int)~ ó ~int s(char)~
   pero sería válido si fuese ~int s()~ ó ~int s(int(*) (const char*, ...))~
   #+END_QUOTE
** Problema 5 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis semántico*
   
   1. Es parte del compilador.
   2. Detecta un error en ~printf("%d")~ <-- Ojo..!
   3. Vincula con las funciones de biblioteca.
   4. Detecta inconsistencias de tipo de dato.
   5. En C, ~prontf("hola")~ es siempre *semánticamente correcto*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) VERDADERO, es la 3º etapa (1ro léxico, 2do sintáctico, 3ro semántico)

   (2) FALSO, devuelve un valor basura

   (3) FALSO, es el Linker/Enlazador quien vincula con funciones de biblioteca

   (4) VERDADERO, el Analizador Semantico verifica si el operador espera un tipo especifico de operando
   (Ej. un error semántico sería ~int a[5];~  porque el operador ~[]~ espera una *constante entera* no una *constante real*)

   (5) FALSO, depende del contexto, ~prontf("hola")~ puede ser semánticamente incorrecto,
   si el prototipo de ~prontf~ espera otro tipo que no sea una cadena de caracteres
   #+END_QUOTE
** Problema 6 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba un ejemplo de una *expresión C* con por lo menos un *error semántico*. Justifique
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     // Tiene error semántico, porque al invocar printf debe coincidir con su prototipo
     // y espera al menos una cadena de caracteres como primer parámetro
     printf();

     printf(1); // error semántico, idem anterior

     // Tiene error semántico porque el `1` es una constante entera por tanto
     // no es un lvalue válido para el operador `++`
     1++;

     // Tiene error semántico porque se está declarado dos veces el mismo identificador
     // en el mismo scope/ámbito
     int a; char a;

     int n;
     n[0]; // error semántico porque `n` no es vector ni puntero

     char* opcion;
     switch(opcion); // error semántico porque `opcion` no es un entero

     struct {} X;
     X++; // error semántico, un `struct` no es un tipo válido como operando para `++`

     5 = 10; // el `5` no es un lvalue válido para `=`
   #+END_SRC
** [WAITING] [#A] Problema 7 (2019-07-15) <- Interesante
*** Enunciado
   #+BEGIN_QUOTE
   Escriba un ejemplo de una *declaración C* con por lo menos un *error semántico*. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Los dos de abajo son de la resolución, deberian estar bien, pero no son errores sintácticos?
   
   <<DUDA>>: (resuelta) ~static auto int edad;~ no es error sintáctico?,
   *Rta:* en Lenguaje natural se dice que sólo puede tener un *especificador de clase de almacenamiento* por declaración,
   por tanto puede tener uno u otro, pero no ambos
   
   <<DUDA>>: ~int double valor;~ no es error sintactico? // <-- multiples tipos en los especificadores de tipo de la declaración (es int ó double, no ambos)
   *Rta:* en realidad con las reglas sintácticas de la BNF, en la declaración de una variable se puede tener más de un *especificador de tipo*,
   por tanto es sintacticamente correcto pero NO es semanticamente correcto..
   la resolución habrá tratado de llegar a que si es sintacticamente incorrecta, tampoco será semánticamente correcta?

   De las dos dudas anteriores, al parecer no es error sintáctico porque.. derivé de la sintáxis de C (del pdf de bruno) y me daba ok
   1. <declaracion>
   2. <especificadores de declaración> <lista de declaradores>
   3. <especificador de tipo> <especificadores de declaración> <lista de declaradores>
   4. <especificador de tipo> <especificador de tipo> <lista de declaradores>
   5. int double <lista de declaradores>
   6. int double <decla>
   7. int double <identificador>
   8. int double x
   #+END_COMMENT
   
   #+BEGIN_SRC C
     // redeclaración de un identificador en el mismo scope
     int a, a;
     struct {int x; int x;} X;

     // el tamaño del vector no es un tipo entero
     int b[0.5];
   #+END_SRC
** [#A] Problema 8 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   *Declare un arreglo* y luego dé un *ejemplo semánticamente correcto de valor-l NO MODIFICABLE*
   que use ese arreglo
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     int x[5];

     // las siguientes sentencias son semanticamente correctas,
     // y tienen expresiones lvalue NO MODIFICABLES

     x; // apunta a la dirección del principio de `x` pero no se le puede asignar un valor Ej. x=1

     x+1; // apunta a la dirección siguiente de fin del arreglo, pero tampoco se le puede asignar un valor
   #+END_SRC
** [WAITING] [#A] Problema 9 (2019-05-23) <- interesante
*** Enunciado
   #+BEGIN_QUOTE
   Dada la declaración ~struct{double x,y;}p;~ escriba una *expresión semánticamente incorrecta*
   utilizando como *operandos solo constantes (literales)* y los *identificadores* declarados en la
   anterior *declaración*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: El enunciado pide "como operandos constantes (literales) y en la resolución
   hace ~0=p.x+p.y~ dónde está la constante literal ahi..?
   #+END_COMMENT
   
   #+BEGIN_SRC C
     p.x="y";
     p.y="b";
   #+END_SRC
** Problema 10 (2018-12-17)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~int i=0,j=1,*p=&i;~ analice cada una de las siguientes *expresiones* y si es *semánticamente incorrecta* describa el error,
   si no escriba correcto:
   1) ~&i=&j~
   2) ~&p=&i~
   3) ~p=&i.j~
   3) ~p[0]==&i[0]~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   1) ~&i=&j~ <- error semántico, porque ~&i~ no es un lvalue
   2) ~&p=&i~ <- error semántico, porque ~&p~ no es un lvalue
   3) ~p=&i.j~ <- error semántico, al evaluar ~&i.~ porque ~&i~ no es un tipo struct, no es un operando válido para el operador ~.~
   4) ~p[0]==&i[0]~ <- error semántico al evaluar ~i[0]~ porque ~i~ no es un puntero ni tampoco un arreglo
   #+END_QUOTE
** [WAITING] [#A] Problema 11 (2018-12-10) <- interesante
*** Enunciado
   #+BEGIN_QUOTE
   Indique cuál error no es detectable durante el análisis semántico:
   1. Redefinición de variable.
   2. Identificador no declarado.
   3. Desreferencia de puntero nulo.
   4. Asignación a expresión que no es l-value modificable.
   5. Demasiados argumentos con respecto a la declaración ó prototipo.
   6. Operador punto aplicado a expresión que no es estructura ni unión.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: La (2) según la resolución no se detectaen el analisis semántico, por que?
   Si se utiliza un identificador que no fue declarado, no es error semántico, porque debe analizar el contexto?
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) La redefinición de variable es un error detectable en el fase del Analisis Semantico,
   porque debe ver el contexto..

   (3) Desreferenciar un puntero nulo, también es un error que se detecta en el Analisis semántico
   porque debe conocer el contexto para saber si es nulo

   (4) La asignación a expresión que no es lvalue modificable, es un error que se detecta en la fase de Analisis semántico,
   Ej. chequea en el contexto si el operando izquierdo es const

   (5) Si no coincide la cantidad de argumentos entre la declaración y prototipo de una función,
   es un error que se detecta en el Analisis Semántico,
   porque al invocar la funcion, se revisa el prototipo de la misma.

   (6) Si la expresión no es estructura ni unión y se usa como operando del operador punto,
   se detecta como error en el Analisis semántico,
   porque debe ver en el contexto el tipo de dato del operando cuando se declaró
   #+END_QUOTE
** Problema 12 (2018-12-03)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~int i=1;void*p=&i;~ describa el *error semántico* en cada *sentencia* o escriba correcto si no lo hay:
   1. ~{ ++p; }~
   2. ~{ *p=i; }~
   3. ~{ double i=42; i=p*i; }~
   4. ~{ int *p=malloc(sizeof i); }~
   5. ~Describa el posible error pragmático de una de las sentencias.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) ~{ ++p; }~
   *NO se puede determinar al siguiente objeto (dirección de memoria) al que apuntará el puntero*

   (2) ~{ *p=i; }~
   ERROR semantico, NO se puede desreferenciar un puntero a void..
   pero.. se puede castear puntero a un tipo y luego desreferenciar ese tipo (Ej. ~*(int*)p=i~ )

   3. ~{ double i=42; i=p*i; }~
   ERROR semántico, el operador binario ~*~ sólo opera con tipos ariméticos
   pero.. se podría primero desreferenciar el puntero (Ej. ~i=*p*i~)

   4. ~{ int *p=malloc(sizeof i); }~
   *MEMORY LEAK..* NO se puede liberar los recursos asignados al puntero luego de esa sentencia compuesta,
   porque se pierde la referencia
   #+END_QUOTE
** Problema 13 (2018-10-03)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente función: ~int f(void){return 1<*p++;}~
   1. Agregue antes de la función una *declaración* que haga *semánticamente correcta* a la función
   2. Agregue antes de la función una *declaración* que haga *semánticamente incorrecta* a la función
   3. Justifique su anterior respuesta:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     // (2) - Declaración que hace semánticamente correcta la definición de la función `f`
     int*p;

     // (2) # alternativa
     int i, *p=&i;


     // (3) - Declaración que hace semánticamente incorrecta la definición de la función `f`
     // - La hace incorrecta, porque declaramos a `p` como entero
     // y al evaluar `*p` arroja un error semántico ya que `p` no es puntero ni arreglo
     int p;

     // (3) # alternativa
     // - También la hace semanticamente incorrecta, porque un puntero a void
     // no se puede desreferenciar (a menos que se castee a un puntero a un tipo, previo a desreferenciar)
     void* p;
   #+END_SRC
** Problema 14 (2018-02-19)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~{ T v,*p; v =f(1.0 ) ;switch( v.m1){p= v .m2;} }~
   Escriba las *declaraciones* de los siguientes *identificadores* para que el fragmento sea semánticamente correcto:
   1. De ~T~
   2. De ~f~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     // (1): Declaración de T
     // - Lo hacemos del tipo struct porque en el fragmento se usa
     // el operador (.) para acceder a los miembros de la `v`
     // - Usamos typedef para crear el alias porque declara dos variables
     // de la sig manera `T v, *p`
     // - El miembro `m1` debe ser `int` porque la expresión del switch
     // debe ser entero
     // - El miembro 'm2' lo hacemos del tipo puntero a `struct S` porque en la
     // expresión de asignación `p=v.m2` le asigna un valor que es del mismo tipo que `p`
     typedef struct S{int m1; struct S *m2;} T;

     // (2)
     // - Retorna un struct para que en la expresión de asignación
     // `v=f(1.0)` no haya problemas de tipo
     // - Recibe por parámetro un double, porque en la invocación `f(1.0)`
     // si a una Constante numérica real no se agrega el sufijo `f`
     // por default es del tipo `double` (doble precisión)
     T f(double);
   #+END_SRC
** Problema 15 (desconocido)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la siguiente expresión sintácticamente correcta: ~a[i]=*p~
   escriba *tres declaraciones para esa expresión*, una que la haga semántica correcta,
   otra semánticamente incorrecta por Lvalue, y otra semánticamente incorrecta por operación y
   operador incompatible.

   1) *Declaración* que hace a la *expresión semánticamente correcta*:
   2) *Declaración* que hace a la *expresión semánticamente incorrecta* por *error asociado a Lvalue*
   3) *Declaración* que hace a la *expresión semánticamente incorrecta* por error asociado a *operador y operando incompatibles*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     // (1) - Declaración que la hace semánticamente correcta
     int a[3], i, *p;

     // (2) - Declaración que la hace semánticamente INCORRECTA por error asociado a lvalue
     // - Como `a[3]` es const, provoca al intentar asignar un valor a `a[i]` por ser un lvalue NO modificable
     const int a[3], i, *p;

     // (3) - Declaración que la hace semánticamente INCORRECTA por error asociado a "operador y operando incompatibles"
     // - por no ser `a` un  array, ni puntero válido para el operador []
     // - suponiendo que `a` fuese un array, seguiría siendo error de tipos porque `i` no es un entero y el operador [] lo pide
     double a, i, *p;
   #+END_SRC

* Etapas compilación
** [TODO] Problema 1 (2019-07-29)
   #+BEGIN_QUOTE
   Indique cuál es la entrada a la parte (o proceso) de *síntesis de un compilador*
   #+END_QUOTE
** [WAITING] [#A] Problema 2 (2019-07-15)
*** Enunciado
   #+BEGIN_QUOTE
   Indique las *fases de la parte de análisis de un compilador*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Me parece que te falta desarrollar un poco más...
   <<DUDA>>: En el *análisis sintáctico* se especifica el orden de evaluación de los OPERADORES?
   *Rta:* Si. Mientras que en el semántica el de los operandos.

   <<DUDA>>: En el *análisis sintáctico* si los operadores tienen igual precedencia, se evalúa por asociatividad ?

   <<DUDA>>: En el análisis semántico, que tiene de entrada? lexemas?

   <<DUDA>>: En el análisis semántico se verifica las restricciones en (LN) de la BNF,
   y también de la (GSC) que la BNF no puede representar?

   <<DUDA>>: En el *MROC* aparecen las *restricciones* sobre los constructos definidos
    en la "Sintaxis" y que la BNF ó una GIC no podría representar de forma clara?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   1. Análisis Léxico (Scanner)
      - recibe y procesa una secuencia de caracteres, los agrupa en lexemas y clasifica por tipo de TOKENs
   2. Análisis Sintáctico (Parser)
      - recibe y procesa una secuencia de TOKENs, analiza si cumplen con las reglas sintácticas de la BNF
      - verifica la precedencia y asociatividad de los operadores
      - sólo entiende TOKENs (son LRs, generados por GRs)
      - se especifíca la precedencia y asociatividad de los OPERADORES
   3. Análisis Semántico
      - se especifíca el orden de evaluación de los OPERANDOS
   #+END_QUOTE
** [WAITING] Problema 3 (2018-07-30)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto al proceso de compilación:
   1) Detecta errores semánticos.
   2) Incluye un backend y un front end.
   3) Incluye una etapa de vinculación (link).
   4) Incluye una etapa de preprocesamiento.
   5) Incluye una etapa de análisis y otra de síntesis.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (2) la resolución dice que es verdadera (?)

   <<DUDA>>: (5) sintesis? 
   UN fragmento del apunte de ferreiros..
   "la segunda etapa del compilador — la Síntesis — y del programa objeto que se obtiene, como hemos visto en el capítulo 
   anterior, aunque éstos no sean temas para profundizar en este libro. "

   Otro fragmento del apunte de ferreiros..
   ArchivoFuente (.c) -> Analisis (Léxico, Sintáctico, Semántico) -> Sintesis -> Ensamblado -> Enlazado -> ArchivoEjecutable (.exe)
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) Verdadero. La última etapa del proceso de compilación es el *Analisis Semántico*,
   y en este se detectan los *errores semánticos*

   (3) FALSO. La etapa de vinculación es externa al compilador,
   la realiza el Linker/Enlazador para generar el ejecutable (.exe ó .out)
   a partir de los objetos (.o) generados a partir de los archivos fuente (.c) y archivos de cabecera (.h).

   (4) FALSO. La etapa preprocesamiento, es externa al compilador,
   la realiza el Preprocesador de C, que remueve los comentarios, y aplica las directivas (#define, #if, #include, ...)
   #+END_QUOTE
** Problema 4 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
   V/F? En un programa la línea ~#include <stdio.h>~ permite vincularlo (link) con la biblioteca estándar.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: está ok lo del preprocesador?
   #+END_COMMENT

   #+BEGIN_QUOTE
   FALSO. El Linker/Enlazador no recibe la cabecera.
   La directiva ~#include~ es analizada por el *Preprocesador de C*, éste se encarga de las directivas
   #+END_QUOTE
** [WAITING] Problema 5 (2018-02-19)
*** Enunciado
   #+BEGIN_QUOTE
   Indique el orden en el cual se ejecutan los siguientes procesos o subprocesos:
   -  Parser
   -  Linker
   -  Scanner
   -  Backend
   -  Preprocesamiento
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Qué es el backend?
   #+END_COMMENT

   #+BEGIN_QUOTE
   - (1) Preprocesamiento
   - (2) Scanner
   - (3) Parser
   - (4) *Backend* <--
   - (5) Linker
   #+END_QUOTE

* [TODO] Arboles sintácticos
** Problema 1 (2020-10-14)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión C: ~s.a[s.i]~
   
   Nivel sintáctico
   1. Indique *la raíz y las hojas* del *árbol de expresión*
   2. Escriba todas las *subexpresiones de la expresión*
   #+END_QUOTE
** Problema 2 (2019-12-18)
*** Enunciado
   #+BEGIN_SRC C
     /*1*/ int h(int x){
       /*2*/ int y=0;
       /*3*/ y=f(x);
       /*4*/ y=g(y);
       /*5*/ return y;}
   #+END_SRC

   #+BEGIN_QUOTE
   Analice la *sentencia* de la línea 3, dibuje el *árbol asociado a la expresión*
   #+END_QUOTE
** Problema 3 (2019-12-11)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. En un *árbol de derivación*, los nodos internos son variables.
   #+END_QUOTE
** Problema 4 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. En un *árbol de derivación*, las hojas son *tokens*
   2. En C, la expresión ~a+b+c~ tiene un único *árbol de derivación*
   #+END_QUOTE
**** Respuesta (resolución)
   #+BEGIN_QUOTE
   (1) verdadero

   (2) Verdadero
   #+END_QUOTE
** Problema 5 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Dibuje el *árbol de expresión* para ~f(x).a[i]~
   #+END_QUOTE
