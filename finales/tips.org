#+TITLE: Resumen de Finales - Tips
* Declaraciones (Calificador de Tipo y Especificador de Tipo)
   #+BEGIN_QUOTE
   - El/Los *declaradores* son los identificadores de la declaración
   - El *inicializador* es el valor con el que se inicializa el objeto (dirección de memoria)
   
   Los calificadores de tipo son:
   1) ~const~
      - al agregar esto en una variable, no se podrá modificar su valor en tiempo de ejecución
      - se les puede asignar un valor una única vez, sólo cuando se declaran
      - la variable se convierte en una de sólo lectura
   2) ~volatile~

   Los especificadores de tipo son:
   1) void
   2) unsigned
   3) signed
   4) short
   5) long
   6) double
   7) float
   8) int
   9) char

   Los especificadores de clase de almacenamiento son: (puede haber sólo uno en cada declaración)
   1) static
   2) auto
   3) register
   4) extern
   5) typedef
   #+END_QUOTE

   |-----------------------+-------------------------+--------------+---+-----------------|
   | *CALIFICADOR de tipo* | *ESPECIFICADOR de tipo* | *DECLARADOR* |   | *INICIALIZADOR* |
   |-----------------------+-------------------------+--------------+---+-----------------|
   | ~const~               | ~char~                  | ~nombre[]~   | = | ~"carlos"~      |
   |-----------------------+-------------------------+--------------+---+-----------------|

   |--------------------------------------------+-------------------------+----------------|
   | *especificador de clase de almacenamiento* | *ESPECIFICADOR de tipo* | *DECLARADORES* |
   |--------------------------------------------+-------------------------+----------------|
   | ~static~                                   | ~float~                 | ~x, y, *p~     |
   |--------------------------------------------+-------------------------+----------------|
* ValorL
#+BEGIN_SRC C
  int numeros[10] = {0};

  numeros; // lvalue NO modificable, se debe usar los operadores * ó [] para que sea modificable
  (numeros+2); // lvalue NO modificable

  ,*numeros; // lvalue modificable, desreferencia la dirección del primer elemento
  numeros[0]; // lvalue modificable, accede al primer elemento

  // ---------------------------------------------------------------------------

  // Ojo! NO es lo mismo que {char nombre[6+1]="pepito";}
  char* nombre = "pepito";

  // las cuatro sentencias tienen expresiones que son lvalue modificables
  nombre; // lvalue modificable, podemos hacer.. {nombre = &apellido;}
  ,*nombre; // lvalue modificable, podemos hacer.. {*nombre='z';}
  nombre[3]; // lvalue modificable, podemos hacer.. {nombre[3]='z';}
  ,*(nombre+3); // lvalue modificable, {*(nombre+3) = 'z';}

  // acá el identificador `nombre` no sería un lvalue modificable,
  // no podemos hacer nombre=algo
  char nombre[30]= "pepito";

  // ---------------------------------------------------------------------------

  struct posicion{ int x, y; }posicionInicial;

  posicionInicial; // lvalue no modificable
  posicionInicial.x; // lvalue modificable


  struct velocidad{ int x, y; };
  struct velocidad* velocidadInicial;

  velocidadInicial; // lvalue no modificable
  velocidadInicial->x; // lvalue modificable
  (*velocidadInicial).x; // lvalue modificable
#+END_SRC
* Efecto de lado
   #+BEGIN_QUOTE
   El efecto de lado no se define en la sintaxis de las expresiones de C, 
   *es un concepto semántico* que indica el comportamiento al evaluar una expresión
   #+END_QUOTE
* ungetc y getchar
   #+BEGIN_QUOTE
   Analice la expresión ~f(g(x))~ que es sintácticamente correcta y nos piden enumerar en 
   orden los caracteres retornados por ~ungetc~

   La secuencia de caracteres retornados por ~ungetc~ sería ~(, (, )~
   usamos como referencia la secuencia leída
   1. f( <- ungetc porque ~(~ NO pertenece al token de la secuencia anterior leída (identificador formada por f), se devuelve el ~(~
   2. (g( <- ungetc por el segundo ~(~ no pertenece al token de la secuencia anterior (identificador formada por g), se devuelve ~(~
   3. (x) <- ungetc por el segundo ~(~ , se devuelve ~)~
   4. )

   Aclaración, cuando lee la secuencia ~(g(~ ocurre sólo 1 ~ungetc~
   | secuencia leída |                                                                                                                                                     |
   |-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~(~             | lee un caracter                                                                                                                                     |
   | ~(g~            | lee el siguiente caracter, y no hace ~ungetc~ porque no hay otro caracter que combinado con ~(~ forme algun token (si podría si fuese el simbolo =) |
   | ~(g(~           | hace ungetc porque luego de leer ~g~ detecta el ~(~ y éste no forma parte de los identificadores (a la que si pertenece el caracter ~g~)            |

   En la secuencia ~(x))~ también sólo ocurre un llamado a ~ungetc~
   | (  | llama a getchar, todo ok                                                                                  |
   | x  | llama a getchar, todo ok (igual que con el ejemplo de ~(g(~ por eso no hace ungetc)                       |
   | x) | llama a ungetc, detecta que el ~)~ no pertenece al TOKEN de los identificadores al que si pertenece ~x~   |
   | )) | llama a getchar, todo ok son solo dos paréntesis, no hay otro caracter que combinado con ellos forme otro |
   #+END_QUOTE
* Operador Vs Caracter de Puntuación
** Ejemplo 1
   - Si te piden de ~f()+1~ los TOKENs (nivel léxico), tenés
     1) f  <-- identificador
     2) (  <-- caracter de puntuación
     3) )  <-- caracter de puntuación
     4) +  <-- operador
     5) 1  <-- constante numérica entera
   - Si te piden de ~f()+1~ los operadores, tenés
     1) ()
     2) +
** Ejemplo 2
   - Si te piden de ~x[0]=1~ los TOKENs (nivel léxico), tenés
     1. x  <-- identificador
     2. [  <-- caracter de puntuación
     3. 0  <-- constante numérica entera
     4. ]  <-- caracter de puntuación 
     5. =  <-- operador
     6. 1  <-- constante numérica enteraaaa
   - Si te piden de ~x[0]=1~ los operadores, tenés
     1) []
     2) =
** Ejemplo 3
   - Si te piden de la expresión ~a[i]+s.m~ los operadores, y su precedencia (siendo 0 la menor)
     1) + (precedencia=0)
     2) . (precedencia=1)
     3) [] (precedencia=1)
   - Si te piden de la expresión ~a[i]+s.m~ los TOKENs
     1) a  <-- identificador
     2) [  <-- caracter de puntuación
     3) i  <-- identificador
     4) ]  <-- caracter de puntuación
     5) +  <-- operador
     6) s  <-- identificador
     7) .  <-- caracter de puntuación (?)
     8) m  <-- identificador
* Categorias sintácticas
   - Las Categorías Sintácticas son las Declaraciones, Expresiones, Sentencias
   - Son generadas por (GICs) Gramáticas Independientes del Contexto, y presentan (LICs)

   #+BEGIN_SRC C
   // En el siguiente fragmento tenemos 2 sentencias de expresión, y 1 declaración
   
   int f;
   f+=42;
   f(); // error semántico, no se puede invocar una variable
   #+END_SRC
* GIC - Gramática BNF de C - Constructos/Categorías/Reglas Sintácticas
** Declaración
   #+BEGIN_COMMENT
     1. <declaracion>
     2. <especificadores de declaración> <lista de declaradores>
     3. <especificador de tipo> <especificadores de declaración> <lista de declaradores>
     4. <especificador de tipo> <especificador de tipo> <lista de declaradores>
     4. int double <lista de declaradores>
     4. int double <decla>
     4. int double <identificador>
     4. int double x
   #+END_COMMENT


   #+BEGIN_QUOTE
   <declaración> ->
     <especificadores de declaración> <lista de declaradores>?
   
   <especificadores de declaración> ->
     <especificador de clase de almacenamiento> <especificadores de declaración>? |
     <especificador de tipo> <especificadores de declaración>? |
     <calificador de tipo> <especificadores de declaración>?

   <lista de declaradores> ->
     <declarador> |
     <lista de declaradores> , <declarador>
     
   <declarador> ->
     <decla> |
     <decla> = <inicializador>
     
   <inicializador> ->
     <expresión de asignación> | /* Inicialización de tipos escalares */
     {<lista de inicializadores>} | /* Inicialización de tipos estructurados */
     {<lista de inicializadores> , }

   <especificador de clase de almacenamiento> -> uno de
     typedef static auto register extern
     * No más de un <especificador de clase de almacenamiento> puede haber en una declaración

   <especificador de tipo> -> uno de
     void char short int long float double signed unsigned
     <especificador de "struct" o "union">
     <especificador de "enum">
     <nombre de "typedef">
   
   <calificador de tipo> -> const | volatile
   
   <especificador de "struct" o "union"> ->
     <"struct" o "union"> <identificador>? {<lista de declaraciones "struct">} |
     <"struct" o "union"> <identificador>
     
   <"struct" o "union"> -> struct | union
   
   <decla "struct"> ->
     <decla> |
     <decla>? : <expresión constante>
   
   <decla> -> <puntero>? <declarador directo>
   
   <puntero> ->
     * <lista calificadores tipos>? |
     * <lista calificadores tipos>? <puntero>

   <declarador directo> ->
     <identificador> |
     ( <decla> ) |
     <declarador directo> [ <expresión constante>? ] |
     <declarador directo> ( <lista tipos parámetros> ) /* Declarado nuevo estilo */
     <declarador directo> ( <lista de identificadores>? ) /* Declarador estilo obsoleto */
   #+END_QUOTE
** Expresión
   #+BEGIN_QUOTE
   <expresión> ->
     <expresión de asignación> |
     <expresión> , <expresión de asignación>
     <expresión de asignación> ->
     <expresión condicional> |
     <expresión unaria> <operador asignación> <expresión de asignación>
   
   <expresión condicional> ->
     <expresión O lógico> |
     <expresión O lógico> ? <expresión> : <expresión condicional>
     
   <operador asignación> -> uno de
     = *= /= %= += -= <<= >>= &= ^= |=
     
   <expresión O lógico> ->
     <expresión Y lógico> |
     <expresión O lógico> || <expresión Y lógico>
     
   <expresión Y lógico> ->
     <expresión O inclusivo> |
     <expresión Y lógico> && <expresión O inclusivo>
     
   <expresión O inclusivo> ->
     <expresión O excluyente> |
     <expresión O inclusivo> | <expresión O excluyente>
     
   <expresión O excluyente> ->
     <expresión Y> |
     <expresión O excluyente> ^ <expresión Y>
     
   <expresión Y> ->
     <expresión de igualdad> |
     <expresión Y> & <expresión de igualdad>
     
   <expresión de igualdad> ->
     <expresión relacional> |
     <expresión de igualdad> == <expresión relacional> |
     <expresión de igualdad> != <expresión relacional>
     
   <expresión relacional> ->
     <expresión de corrimiento> |
     <expresión relacional> < <expresión de corrimiento> |
     <expresión relacional> > <expresión de corrimiento> |
     <expresión relacional> <= <expresión de corrimiento> |
     <expresión relacional> >= <expresión de corrimiento>
     
   <expresión aditiva> ->
     <expresión multiplicativa> |
     <expresión aditiva> + <expresión multiplicativa> |
     <expresión aditiva> - <expresión multiplicativa>
     
   <expresión multiplicativa> ->
     <expresión de conversión> |
     <expresión multiplicativa> * <expresión de conversión> |
     <expresión multiplicativa> / <expresión de conversión> |
     <expresión multiplicativa> % <expresión de conversión>
     
   <expresión de conversión> ->
     <expresión unaria> |
     (<nombre de tipo>) <expresión de conversión>
     
   <expresión unaria> ->
     <expresión sufijo> |
     ++ <expresión unaria> |
     -- <expresión unaria> |
     <operador unario> <expresión de conversión> |
     sizeof <expresión unaria> |
     sizeof (<nombre de tipo>)
     
   <nombre de tipo> 
   
   <operador unario> -> uno de & * + - ~ !
   
   <expresión sufijo> ->
     <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --
     
   <expresión primaria> ->
     <identificador> |
     <constante> |
     <literal cadena> |
     (<expresión>)

   primary-expression: <- de otra fuente
     identifier
     constant
     string-literal
     ( expression )
     generic-selection
   #+END_QUOTE
** Sentencia
   #+BEGIN_QUOTE
   <sentencia> ->
     <sentencia expresión> |
     <sentencia compuesta> |
     <sentencia de selección> |
     <sentencia de iteración> |
     <sentencia etiquetada> |
     <sentencia de salto>
   
   <sentencia expresión> ->
     <expresión>? ;
   
   <sentencia compuesta> ->
     {<lista de declaraciones>? <lista de sentencias>?}
     
   <lista de declaraciones> ->
     <declaración> |
     <lista de declaraciones> <declaración>
     
   <lista de sentencias> ->
     <sentencia> |
     <lista de sentencias> <sentencia>
     - La sentencia compuesta también se denomina bloque.

   <sentencia de selección> ->
     if (<expresión>) <sentencia> |
     if (<expresión>) <sentencia> else <sentencia> |
     switch (<expresión>) <sentencia>
     La expresión e controla un switch debe ser de tipo entero.
   
   <sentencia de iteración> ->
     while (<expresión>) <sentencia> |
     do <sentencia> while (<expresión>) ; |
     for (<expresión>? ; <expresión>? ; <expresión>?) <sentencia>
     
   <sentencia etiquetada> ->
     case <expresión constante> : <sentencia> |
     default : <sentencia> |
     <identificador> : <sentencia>
     Las sentencias case y default se utilizan solo dentro de una sentencia switch.
     
   <sentencia de salto> ->
     continue ; |
     break ; |
     return <expresión>? ; |
     goto <identificador> ;
     - La sentencia continue solo debe aparecer dentro del cuerpo de un
     ciclo. La sentencia break solo debe aparecer dentro de un switch
     o en el cuerpo de un ciclo. La sentencia return con una expresión
     no puede aparecer en una función void.
   #+END_QUOTE 
* Lenguajes Formales
** Conceptos básicos
*** Relación con la BNF de C
**** Conceptos
   - Si X es (LR) => por definición es posible escribir una (GIC) que lo genere => es posible escribir una BNF que lo defina
**** Declaraciones
   - No son (LR) por tener *paréntesis balanceados*
   - En C se definen con notación BNF, que se puede representar con (LIC)
**** Constantes enteras
   - Las constantes enteras sin sufijo se pueden representar con la (ER) ~0(0+1+2+3+4+5+6+7)*~
**** Sentencias
* Errores de Compilación
** Mix
   #+BEGIN_SRC C
     printf("%d");  // OK, devuelve un valor basura

     struct{ } printf; // no produce error, `printf` no es una keyword
     struct{ } main; // no produce error, `main` no es una keyword

     int a(){ }
     a; // no produce error
     
     int b(int x){ return x; }
     b; // no produce error
     b('a'); // no produce error, porque 'a' es un caracter y representa un valor númerico de la tabla ascii
   #+END_SRC
** Errores Léxicos
** Errores Sintácticos
   #+BEGIN_QUOTE
   <sentencia> -> <sentencia expresión> | <sentencia compuesta> | <sentencia de selección> | <sentencia de iteración> | <sentencia etiquetada> | <sentencia de salto>
   
   <sentencia de selección> ->
     if (<expresión>) <sentencia> |
     if (<expresión>) <sentencia> else <sentencia> |
     switch (<expresión>) <sentencia>
     La expresión e controla un switch debe ser de tipo entero.
   
   <sentencia expresión> -> <expresión>? ;
   #+END_QUOTE
   
   #+BEGIN_SRC C
          // - no es error sintáctico porque se puede derivar de la BNF
          // - es error semántico, porque el prototipo de printf espera una cadena de caracteres como primer parámetro
          printf(main); 
          printf(); // idem que el anterior
          printf(printf); // idem que el anterior

     // ERROR sintáctico, al derivar de la BNF no espera el operador `-` seguido de la keyword `for`,
     for-while ;     
   #+END_sRC
** Errores Semánticos
   #+BEGIN_SRC C
     printf("%d"); // Ok, no produce error, imprime un valor basura
     
     // - NO es error semántico. Es error sintáctico, debe ser del tipo `while(exp) sentencia` ó `while(exp){ sentencia }`
     while++;

     // Es error semántico según el contexto, Ej. si fue declarada previamente en el mismo scope/ámbito
     int v[5];

     // Es error semántico según el contexto,
     // - ERROR semántico si el prototipo de s es `int s(char);`
     // - NO es error si el prototipo de s es `int s()`
     // - NO es error si el prototipo de es `s(int(*) (const char*, ...))`
     s(printf);


     // -----------------------------------------------------------------------------------------------------

     // - ERROR Semántico, porque tiene que ser del tipo `if(expresion)`
     if();

     // - estos otros no producen error porque son del tipo `if(expresion)`
     if(1); if(0.5); if('a'); if("abc"); // ok
     int* ptr; if(ptr); // ok
     int v[5]; if(v); // ok

     // -----------------------------------------------------------------------------------------------------

     // - ERROR Semántico, tipo de dato incompleto. NO es error sintáctico porque puede derivar
     struct S{struct S m;};

     // - No produce error, se declaró la estructura `P` y luego se declaró `x` que es del tipo `struct P`
     struct P{}; struct { struct P x; } p;

     // -----------------------------------------------------------------------------------------------------

     int b(int x){ return x; }
     b; // no arroja error, es una sentencia semanticamente correcta, que usa la minima cantidad de TOKENs
     b(0); // sentencia expresión
     b("hola"); // ERROR semántico, la invocación de `b` no coincide con su prototipo

     // -----------------------------------------------------------------------------------------------------

     prontf("hi"); // Es error semántico según el contexto, arroja error si el prototipo de `prontf` no coincide con su invocación

     // - es error semántico, porque el prototipo de printf espera una cadena de caracteres como primer parámetro
     printf(main);
     printf(); // idem que el anterior

               // -----------------------------------------------------------------------------------------------------

               // - La expresión `c = a[1].b` es semánticamente válida
               // - La expresión `a[0].b` es un lvalue NO MODIFICABLE
     int c;
     const struct { int b; } a[10];
     c = a[1].b;

     // -----------------------------------------------------------------------------------------------------

     // Alternativa #1 - No produce error semántico en `c=a[1].b`
     int c; struct { int b; } a[10];
     c = a[1].b; // no es error semańtico, por el contexto

     // Alternativa #2 - ERROR semántico en `c=a[1].b`
     // - porque `a` no es un arreglo del tipo struct
     int c, a;
     c = a[1].b; // ERROR semańtico, por el contexto
   #+END_SRC
   
