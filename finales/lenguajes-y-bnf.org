#+TITLE: Resumen de Finales - Lenguajes Formales + BNF de C
#+STARTUP: inlineimages
* Tips
** Relación entre (LP), (LF) y la BNF
   #+BEGIN_QUOTE
   Un (LP) Lenguaje de Programación es una *notación* para describir
   - algoritmos
   - estructuras de datos
   
   Los (LP) están formados por
   - (LRs) Lenguajes Regulares <- generados por (GRs)
   - (LICs) Lenguajes Independientes del Contexto <- generados por (GICs)

   Un (LF) Lenguaje Formal es un conjunto de palabras que
   - tienen *sintáxis* (reglas gramáticales, forman la estructura, el orden, ...)
   - NO tienen *semántica* asociada (permite que no sean ambíguos, osea tienen una única interpretación)

   Características de una *BNF*
   - es una notación sin ambiguedades, única interpetación
   - describe la sintáxis de un (LP) Lenguaje de programación
   - parecida a una (GF) Gramática Formal, pero con nuevos *metasímbolos*
   #+END_QUOTE
** Relación entre los (LF) y el Compilador
   |----------------------+----------------------+-------------------------------------------+-------------------------------------|
   | Jerarquía de Chomsky | Lenguaje Formal (LF) | Gramática que genera al (LF)              | Autómata que lo reconoce            |
   |----------------------+----------------------+-------------------------------------------+-------------------------------------|
   | Tipo 0               | LI                   | (GI) Gramática Irrestricta                | Maquina de Turing                   |
   | Tipo 1               | LSC                  | (GSC) Gramática Sensible de Contexto      | (ALL) Autómata Linealmente Limitado |
   | Tipo 2               | LIC                  | (GIC) Gramática Independiente de Contexto | (AP) Autómata de Pila               |
   | Tipo 3               | LR                   | (GR) Gramática Regular                    | (AF) Autómata Finito                |
   |----------------------+----------------------+-------------------------------------------+-------------------------------------|

   |----------------------+-------------------------------------------+---------------------------------------------------|
   | Lenguaje Formal (LF) | Gramática que genera al (LF)              | Relación con el Compilador                        |
   |----------------------+-------------------------------------------+---------------------------------------------------|
   | LI                   | (GI) Gramática Irrestricta                |                                                   |
   | LSC                  | (GSC) Gramática Sensible de Contexto      |                                                   |
   | LIC                  | (GIC) Gramática Independiente de Contexto | Sintáxis, las *Categorías Sintácticas* son (LICs) |
   | LR                   | (GR) Gramática Regular                    | las *Categorías Léxicas* (ó TOKENs) son (LRs)     |
   |----------------------+-------------------------------------------+---------------------------------------------------|
   
   |-----------+--------------------------------------------------------------------------------------------+-------------------------------------------------------|
   | Gramática | Restricción                                                                                | dato de color                                         |
   |-----------+--------------------------------------------------------------------------------------------+-------------------------------------------------------|
   | (GI)      | Ninguna                                                                                    |                                                       |
   | (GSC)     | Sea V->T una producción, el cardinal de V debe ser menor ó igual que el de T               | es una (GI) con restricción                           |
   | (GIC)     | Sea V->T una producción, debe haber un único (Vn) no terminal a izquierda de la producción |                                                       |
   | (GR)      | Sea V->T una producción, debe haber un único (Vn) no terminal a izquierda de la producción |                                                       |
   | (GQR)     |                                                                                            | es una (GR) que agrupó un conjunto de (Vt) en un (Vn) |
   |-----------+--------------------------------------------------------------------------------------------+-------------------------------------------------------|
** [TODO] Relación entre Operandos/Operadores con la Sintáxis y Semántica
   #+BEGIN_QUOTE
   La Sintáxis define la precedencia(prioridad) y asociatividad de los OPERADORES
   - La asociatividad
   - La precedencia
     
   (/Ej. la asociatividad del operador.../)

   La Semántica define la precedencia(prioridad) de los OPERANDOS
   (/Ej. la asociatividad del operador.../)
   #+END_QUOTE
* [WAITING] BNF de C
** [WAITING] Problema 1 (2019-02-25)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde la afirmación falsa con respecto a BNF:

   1. Es un *meta lenguaje*
   2. Posee *metasímbolos*
   3. Es útil para definir *LP*
   4. Puede describir cualquier *LF tipo 2*
   5. Puede describir el *LF identificadores de C*
   6. Puede describir el *LF expresiones de C semánticamente correctas*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: La BNF no puede describir un LF tipo 1 osea (LSC), no?
   me parece que no porque es una (GIC) y ésta no puede generar lo mismo que una (GSC)
   según la jerarquía de chomsky, no?
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) Verdadero, la BNF es un *meta lenguaje*

   (2) Verdadero, la BNF de C tiene como metasímbolo el ~:~ actúa como el ~->~ para las producciones,
   aunque no posee el ~|~ para las opciones se agregan en una nueva linea

   (3) Verdadero una BNF sirve para definir y documentar un LP

   (4) Verdadero, la BNF puede describir cualquier (LF) tipo 2 osea un (LIC),
   en la BNF de C se describen las *Categorias Léxicas* (TOKENS, son LRs)
   y las *Categorías Sintácticas* del lenguaje y sus restricciones

   (5) Verdadero

   (6) Falso, una BNF podría no representar ciertas restricciones que si podría una (GSC)
   #+END_QUOTE
** [WAITING] [#A] Problema 2 (2018-12-10)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todos los conceptos que se pueden definir con el *BNF del LF Expresiones de C*
   1. *Efecto de lado* de la expresión.
   2. *Precedencia* de los OPERADORES.
   3. *Asociatividad* de los OPERADORES.
   4. *Orden de evaluación* de los OPERANDOS.
   5. Aridad (cantidad de operandos) de los OPERADORES.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Donde está definido el efecto de lado de C? En el MROC?
   Yo creí que era Verdadero, porque.. como estaba la expresión de asignación (?)
   
   <<DUDA>>: La asociatividad y la precedencia, indican el orden de las operaciones (osea la *Secuenciación*) ?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (2) Verdadero, la BNF del LF expresiones de C define la precedencia de los OPERADORES (por cercanía o no al axioma)..
   Más cercano esté del axioma, menos precedencia(prioridad)

   (3) Verdadero, la asociatividad está marcada si la regla/producción es a izquierda ó derecha

   (4) FALSO. La BNF no define el *orden de evaluacion de los OPERANDOS*, sólo de los OPERADORES.

   (5) Verdadero, la regla lo indica explícitamente Ej. si el operador es unario tendrá sólo un operando
   #+END_QUOTE
** [#A] Problema 3 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la gramática
   sentencia-for:
   for ( expresión ; expresión ; expresión ) { sentencia }
   
   1. V/F? Representa las *sentencias-for de C*
   2. Calcule ~Primero(sentencia-for)~
   3. V/F? La ~sentencia-for~ con menor cantidad de TOKENS tiene siete TOKENS.
   4. V/F? El lenguaje que genera puede reconocerse con un *autómata de pila*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO, porque
   1. las tres expresiones que tiene la sentencia ~for~ deben ser opcionales, y ahi no lo son
   2. las llaves que indican el comienzo de una *sentencia compuesta* también debería ser opcional, y ahi no lo son
   3. no contempla que *la primera expresión pueda ser una Declaración*
       
   (2) Al calcular ~Primero(sentencia-for)~ obtenemos ~for~

   (3) FALSO, la sentencia-for con menor cantidad de TOKENs es ~for(;;);~ que tiene 11 TOKENs

   (4) Verdadero, porque al ser una *sentencia iteración* pertenece a una de las 3 *categorías sintácticas*,
   sabiendo que las Categorías Sintáctica son (LICs) generadas por (GICs) y pueden ser reconocidas por un (AP) Automáta de Pila
   #+END_QUOTE

   |----+-----------+----------------------------------|
   |    | Lexema    | Tipo de TOKEN (Categoría léxica) |
   |----+-----------+----------------------------------|
   |  1 | for       | palabra reservada                |
   |----+-----------+----------------------------------|
   |  2 | (         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   |  3 | expresion | *al menos 1 token*               |
   |----+-----------+----------------------------------|
   |  4 | ;         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   |  5 | expresion | *al menos 1 token*               |
   |----+-----------+----------------------------------|
   |  6 | ;         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   |  7 | expresion | *al menos 1 token*               |
   |----+-----------+----------------------------------|
   |  8 | )         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   |  9 | {         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   | 10 | sentencia | *al menos 1 token*               |
   |----+-----------+----------------------------------|
   | 11 | }         | caracter de puntuación           |
   |----+-----------+----------------------------------|
** Problema 4 (2021-08-04)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba el *BNF ó las reglas de la gramática* para un lenguaje que sea
   un *sublenguaje de las expresiones de C*, pero que solo tenga las operaciones de asignación y multiplicación.
   La de *mayor precedencia* es la multiplicación. La *asignación es asociativa de DI* y *la multiplicación de ID*
   Asuma que el noterminal ~ExpresiónPrimaria~ está definido.
   
   Algunos ejemplos de expresiones síntacticamente correctas son:
   a
   a*b
   a*b*c
   a=b
   a=b=c
   a=b*c
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Si la Multiplicación tiene mayor precedencia que la Asignación,
   entonces la producción de la Multiplicación debe estar lo más lejos del axioma (de la producción que genera las expresiones),
   y por tanto la Asignación estará lo más cerca posible del axioma
   
   Si la Multiplicación es *asociativa de Izquierda a Derecha*
   entonces es *recursiva a izquierda*, los valores son generados a izquierda de la primera expresión
   Ej.
   1. b*a
   2. c*b*a
   3. ...*c*b*a

   Si la Asignacion es *Asociativa de Derecha a Izquierda*,
   entonces es *recursiva a derecha*, los valores son generados a derecha de la primera expresión
   Ej.
   1. a=b
   2. a=b=c
   3. a=b=c=d
   4. a=b=c=d=....
   #+END_QUOTE
   
   #+BEGIN_QUOTE   
   <expresion> ->
     <expresionPrimaria> = <expresion> |
     <expresionMultiplicativa> |
     <expresionPrimaria>

   <expresionMultiplicativa> ->
      <expresionMultiplicativa> * <expresionPrimaria>
      <expresionPrimaria>
   #+END_QUOTE
** [WAITING] [#A] Problema 5 (2021-02-17)
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas sobre las características del lenguaje C:
    
    1. Es interpretado.
    2. Es de alto nivel.
    3. Es estáticamente tipado.
    4. Incluye el tipo de dato string (cadena).
    5. En tiempo de ejecución asocia un tipo a cada valor
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Necesito más justificaciones..
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Falso, el lenguaje C es un lenguaje compilado

   (2) Verdadero

   (3) Verdadero

   (4) Falso, el lenguaje C no incuye el tipo de dato String,
   se requiere de un puntero a char ó de un vector de char

   (5) Falso, el tipo de dato se asocian en tiempo de compilación
   #+END_QUOTE
** Problema 6 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~L={a^n b^n | n>0}~
   Escriba un BNF que lo genere.
   #+END_QUOTE
* [TODO] C vs C++ vs Otros
** Problema 1 (2020-03-03)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba un fragmento breve que sea sintáctimente válido tanto en C y como en C++, pero
   que tenga diferente semántica para cada LP.  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   struct Punto{double x,y;}; // <- la resolución sugiere esto, pero.. no se el porque (????)
   #+END_COMMENT
** Problema 2 (2020-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Ejemplifique brevemente un aspecto sintáctico en el cual el LP C es diferente a otro LP
   que usted conozca. Justifique.  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   En C podemos definir ~int edad~
   mientras que en javascript podriamos definirlo como ~var edad~
   sin indicar que es del tipo entero
   #+END_QUOTE
** [#A] Problema 3 (2020-02-12)
*** Pregunta
   #+BEGIN_QUOTE
   Indique y justifique el valor de verdad de la siguiente afirmación:
   Los LP C y C++ tienen la misma sintaxis.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Falso.
   1. En C++ permite el manejo de templates para funciones genéricas, en C no
   2. En C++ existen los operadores ~new~ y ~delete~ para alocar/desalocar espacio en memoria
   3. En C se usa ~malloc~ y ~free~ para alocar/desalocar espacio en memoria
   4. En C permite pasar parámetros por referencia ~&~ (/se agrega sólo en la firma de la función, pero no cuando se invoca/)
   #+END_QUOTE
   
   #+BEGIN_SRC C
     /*
      ,* Ejemplo en C++, de parámetro por referencia
      ,*/
     void incrementarSaldo(int &saldo, int cantidad){ // <- el & indica que le pasamos la referencia de la variable, aumenta el alcance
       saldo += cantidad;
     }

     int main(){
       int saldo = 0;
       // pasamos "saldo" por referencia, pero eso lo indicamos en la firma donde se utilice
       // genera efecto en "saldo"
       incrementarSaldo(saldo, 500);

       int numero = new int(5); // <-- operador new para alocar espacio en memoria, sólo en C++ existe
       delete numero;  // <-- operador delete para liberar espacio en memoria, sólo en C++ existe
     }
   #+END_SRC
* Gramáticas Ambiguas
** [#A] Problema (1) - 2020-12-21
*** Enunciado
   #+BEGIN_QUOTE
    En la especificación del Lenguaje de C está la siguiente gramática:
    
    selection-statement:
    if ( expression ) statement
    if ( expression ) statement else statement
    switch ( expression ) statement

    1. Indique el *conjunto primero* de ~selection-statement~
    2. Justifique si la *gramática es ambigua*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) El *conjunto primero* es ~{if,switch}~

   (2) La gramática dada es ambígua porque podemos llegar a ~if~ anidado con  ~if else~,
   con dos derivaciones distintas (aplicando distintas producciones)
   
   La ambíguedad se da cuando podemos obtener el mismo resultado de distintas maneras,
   como ocurre en el Lenguaje Natural, donde se pueden tener varias interpretaciones de una palabra.
   #+END_QUOTE
   
   
   |---+------------------------------------------------------+---------------------------|
   |   | Derivación Vertical por izquierda                    | produccion/regla aplicada |
   |---+------------------------------------------------------+---------------------------|
   | 1 | if(expresion) sentencia                              | regla 1                   |
   |---+------------------------------------------------------+---------------------------|
   | 2 | if(expresion) if(expresion) sentencia else sentencia | regla 2                   |
   |---+------------------------------------------------------+---------------------------|

   |---+------------------------------------------------------+---------------------------|
   |   | Derivación Vertical por izquierda                    | produccion/regla aplicada |
   |---+------------------------------------------------------+---------------------------|
   | 1 | if(expresion) sentencia else sentencia               | regla 2                   |
   |---+------------------------------------------------------+---------------------------|
   | 2 | if(expresion) if(expresion) sentencia else sentencia | regla 1                   |
   |---+------------------------------------------------------+---------------------------|
* Lenguajes Formales
** [WAITING] Problema 1 (2021-02-10)
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas acerca de los *LIC*
    
    1. Son generados por *GSC*
    2. Son representados por *ER*
    3. Son fundamentales para los *LP*
    4. Algunos se los puede *definir por extensión*
    5. Las *declaraciones de C* son un ejemplo de *LIC*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (2) detallar el porque
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Verdadero, porque los (LICs) son *Lenguajes Independientes de Contexto* generados por (GICs),
   y también pueden ser generados por (GSCs) según la jerarquía de chomsky..

   (2) FALSO, los (LICs) NO pueden ser representados por (ERs)

   (3) Verdadero, los (LICs) son necesarios en los (LPs) para poder definir la sintáxis del (LP)

   (4) Verdadero, aquellos (LICs) que sea finitos pueden ser definidos por extensión

   (5) Verdadero, las *declaraciones de C* son (LICs), es una de las tres categorías sintácticas.
   Las otras dos son las *sentencias* y las *expresiones*
   #+END_QUOTE
** Problema 2 (2021-02-17)
*** Enunciado
   #+BEGIN_QUOTE
   Indique todas las afirmaciones verdaderas sobre los *LR*:
   
   1. Juegan un rol importante en los *LP*.
   2. Siempre pueden representarse por *ER*.
   3. Siempre pueden *definirse por extensión*.
   4. Siempre pueden definirse mediante una *GIC*.
   5. Los literales-cadena de C son un ejemplo de *LR*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero, los (LRs) representan las *Categorías Léxicas* de un (LP)
   como son los Literales Cadena, Constantes numéricas enteras, Constantes numéricas reales,
   las Constantes caracter, los Identificadores, los Operadores y los Caracter de puntuación

   (2) Verdadero, los (LRs) siempre pueden representarse por un (ER)

   (3) FALSO, no todos los (LRs) pueden definirse por extensión,
   como es el caso de los (LRs) infinitos.

   (4) Verdadero, cualquier (LR) puede ser generado por una (GIC),
   según la jerarquía de Chomsky, donde el (LR) es el lenguaje formal más simple.

   (5) Verdadero, los *Literales Cadena de C* son (LRs), y es una de las *categorías léxicas*
   donde cada categoría léxica es un (LR)
   #+END_QUOTE
** Problema 3 (2021-02-24)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión, que es sintácticamente correcta, y luego responda:
   ~f(g(x))~
   
   1. Escriba una *GF* que genere un *LF* no regular al cual pertenezca la expresión.
      Asuma que ~Ident~, ~ParIzq~, ~ParDer~ son *terminales* definidos
   2. Derive la expresión dada de la *GIC* que haya definido.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE   
   La (GF) Gramática Formal "NO regular" que genera la expresión dada sería
   ~G=(Vn=S, Vt={Ident,ParIzq,ParDer},P={S->Ident ParIzq S ParDer, S->Ident}, S)~
   
   Las producciones de la gramática, la definimos observando que las subexpresiones
   que debe generar la gramática son las siguientes
   1. x
   2. g(x)
   3. f(g(x))

   Por tanto las producciones serían
   ~S -> Ident ParIzq S ParDer | Ident~

   Derivación por izquierda la expresión dada
   1. S
   2. f ( S )
   3. f ( g (  S ) )
   4. f ( g ( x ) )
      
   La gramática dada NO es regular, porque es recursiva a izquierda y a derecha al mismo tiempo,
   y una (GR) permite que sea recursiva a izquierda ó a derecha, pero no ambas.
   #+END_QUOTE
** Problema 4 (2020-12-14)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~L={a^m b^(2n+1) | m>=0, n>=0}~
   
   1. Escriba una *RegEx* que lo represente.
   2. Escriba las cuatro *palabras de menor longitud*
   3. Indique un cambio en la *definición de L* que lo haga *no regular*
   4. ¿Es este LF un sublenguaje de alguna *categoría léxica de C*? Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) La RegEx que lo representa sería: ~a*b(bb)*~

   (2) Las cuatro palabras de menor longitud serían ~{a,b,ab,abb}~

   (3) Un cambio en la definición que lo haga NO regular, sería que la *definición por comprensión*
   sólo us una constante en vez de dos ~m~ y ~n~.
   No se puede plantear lo siguiente, sea A y B un conjunto de caracteres, si A aumenta B aumenta,
   porque no se puede aumentar o disminuir la longitud de dos o más caracteres en simultaneo.
   Por definición, un LF es regular
   - si y solo si existe una GR que lo genere
   - si y solo si existe un AF que lo reconoce

   (4) Verdadero, éste es un sublenguaje de los *identificadores*,
   una de categorías léxicas de C
   #+END_QUOTE
** [WAITING] Problema 5 (2020-10-13)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~L={x^n y^(2n+1) | n>=0}~
   
   1. Escriba las *producciones* de una *gramática* que que lo genere.
   2. Indique la *intersección* de L con el *LF expresiones de C*
   3. Indique un *cambio en la definición de L* que lo haga *regular*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (3) La resolución sólo sugiere sacar el exponente de ~x~, pero agregar un exponente
   para ~x~ y otro para ~y~ no sería también otra solución?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Las producciones de una gramática que genere a dicho lenguaje serían
   ~S -> y | xSyy~

   (2) LF Expresiones INTERSECCIÓN L = L, es decir el propio lenguaje L
   ya que éste es un sublenguaje del LF de Expresiones,

   (3) Para hacer a L un LR, debería haber dos constantes, una para ~x~ y otra para ~y~
   Ej. ~L={x^n y^(2m+1) | n>=0, m>=0}~
   #+END_QUOTE
** [#A] Problema 6 (2020-03-03)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba una *RegEx (metaER)* que represente las *constantes hexadecimales sin sufijo* en C:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Regex: ~0[xX]([0-9-a-fA-F])+~

   1. Debe comenzar con un cero
   2. Seguido de una x (es indiferente si minúscula ó mayuscula)
   3. Seguido de al menos digito del 0 al 9 ó.. de una letra de la A a la F (es indiferente si es  minúscula ó mayuscula)
   #+END_QUOTE
** [#A] Problema 7 (2020-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba una *RegEx (MetaER)* que represente *los cuatro operadores aritméticos básicos*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Regex: ~\-\*\/\+~

   Es necesario usar la barra invertida ~\~ para considerar los símbolos como caracteres comunes,
   caso contrario actuarían como operadores (Ej. el * como la clausura de kleene, ó el + como la clausura positiva)
   #+END_QUOTE
** [WAITING] Problema 8 (2020-02-12)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas.
   Para demostrar que un *LF* es un *LR*, es suficiente con que
   
   1. su *cardinalidad* sea finita.
   2. sea procesable por un *ASDR*
   3. encontremos una *GF* que lo genere.
   4. lo podamos *definir por comprensión*
   5. encontremos un *AFN* que lo reconozca.
   6. encontremos una *ER* que lo represente.  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (2)FALSO, por que?
   Se que ASDR significa Análisis Sintáctico Descendente Recursivo,
   que parte de la raíz/axioma hasta llegar a la palabra,...?
   
   y.. como el *Analizador Sintáctico* entiende (LICs), puede que ese (LF) no sea un (LR) si no bien un (LIC), no?

   <<DUDA>>: (5) Verdadero,
   Si existe un AFN que reconozca al LF, entonces LF es LR
   además para todo AFD existe un AFN equivalente, no?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Verdadero, un LF finito puede ser representado por un LR
   Ej. las palabras reservadas, ó los caracteres de puntuación son LRs

   (3) FALSO, puede haber una (GF) Gramática Formal como lo es una (GIC) que genere al LF,
   y ésta no sería un (LR), si no un (LIC).

   (4) FALSO, si definimos el sig. lenguaje por comprensión ~L={x^n y^n / n>=0}~
   vemos que no es un LR porque no se puede generar ~x~ e ~y~ en simultaneo del mismo tamaño

   (6) Verdadero, un LF es LR siempre que haya una ER que lo represente
   #+END_QUOTE
** Problema 9 (2019-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~Σ={0,1}~ y el LF empiezan y terminan con 0, lo cual incluye la palabra 0:
   
   1. Escriba una *ER* que lo represente:
   2. Escriba una *ERX* ó *RegEx* que lo represente:
   3. Escriba un *BNF* que lo genere:
   4. Dibuje el *digrafo de un AFN* que lo reconozca:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) ER: ~0+0(0+1)*0~
   Usamos el ~+~ para la unión en las ER, y los ~()~ con ~+~ para agrupar y elegir uno

   (2) ERX: ~0|0[01]*0~
   Usamos el pipe ~|~ para la uión en las Regex y los ~[]~ para elegir uno de los caracteres

   (3)
   alternativa #1
   S -> 0  | 0N
   N -> 1N | 0N | 0

   alternativa #2
   S -> 0  | 0N0
   N -> 1N | 0N | epsilon

   El (AFN) Automáta Finito NO Determinístico que hicimos,
   es NO deterministico porque desde un estado va a otros dos
   con el mismo caracter donde la función de transición sería
   ~T(q0,a) = q1~ y ~T(q0,a) = q3+~
   #+END_QUOTE

   #+BEGIN_SRC plantuml :file img/automata1.png :exports results
     @startuml
     digraph foo {
      ' cambiamos la dirección: left to right
      rankdir=LR
      "q0-" -> "q1" [label=0]
      "q0-" -> "q3+" [label=0]
      "q1" -> "q1" [label="0,1"]
      "q1" -> "q2+" [label=0]
     }
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:img/automata1.png]]
** Problema 10 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
    Indique y justifique el valor de verdad de la siguiente afirmación:
    Las *operaciones unión, intersección, y complemento* son parte de las *regex*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   FALSO,
   - la *operación intersección* no forma parte de las *regex*
   - la *operación unión* se logra con el pipe ~|~
   - la *operación complemento* se logra con el ~^~
   #+END_QUOTE
** [TODO] Problema 11 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca de los *algoritmos de MUCH2012 volumen 3*
   
   1. El complemento de un LR siempre es un LR.
   2. Siempre se puede encontrar una ER para un GR.
   3. Siempre se puede encontrar una GIC para un ER.
   4. Siempre se puede encontrar un AFD para una ER.
   5. El algoritmo de Thompson siempre produce un AFD
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Chequear lo del AFD a ER, y el Algoritmo de Thompson a AFD
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Verdadero

   (2) Verdadero, si existe una GR que genera un LR, también hay un ER para esa GR

   (3) Verdadero, siempre hay una GIC para un ER,
   porque los ER representan LR y estos pueden ser generados por GICs,
   según la jerarquía de chomsky, donde los LRs son los más simples.

   (4) Verdadero, ..

   (5) FALSO
   #+END_QUOTE
** [DOING] Problema 12 (2019-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~P~ el ~LF~ nombres de los elementos de la tabla periódica,
   ~D~ el *LF declaraciones de C*,
   y ~O~ el *LF constantes enteras octales sin sufijo de C*

   1. Indique el tipo del LF ~P~. Justifique.
   2. Indique el tipo del LF ~D Union O~. Justifique.
   3. Escriba una ERX para el LF ~(P Interseccion D) Union O~:
   #+END_QUOTE
*** Respuesta
** [WAITING] Problema 13 (2019-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto a las ER:

   1. ~*a~ es una *ER*
   2. Tienen una sintaxis formal.
   3. Tienen *operadores con precedencia*
   4. Las ER son un *sublenguaje de las expresiones de C*
   5. Las *expresiones de C* son un *sublenguaje de las ER*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (4) la resolución decía FALSO.. Por que??

   yo había puesto que.. era Verdadero, porque como cada (ER) representa un (LR) como las *categorías léxicas*
   y las *expresiones de c* son (LICs) osea *categorías sintácticas* que son generadas por (GICs),
   entonces las (ER) representan a (LR) que pueden ser sublenguajes de las *expresiones de C*
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) FALSO, ~*a~ NO es una ER, ya que el operador ~*~ osea la clausura de kleene requiere un caracter a su izquierda

   (2) Verdadero, porque una ER representa a un LR y estos son LF

   (3) Verdadero, la precedencia de los operadores de una ER está dada así
   1. Potencia ~^~, ~*~ Clausura de Kleene y ~+~ Clausura Positiva (las tres tienen mayor precedencia)
   2. Concatenación
   3. Unión ~+~ (menor precedencia)

   (5) FALSO, las *expresiones de C* están formadas por (GICs)
   y las (ERs) representan (LR) que están generados por (GRs)
   estas últimas gramáticas generan los (LF) más simples
   mientras que las (GICs) representan (LF) más complejos
   #+END_QUOTE
* Autómatas
** [#A] Problema 1 (2021-06-23)
*** Enunciado
   #+BEGIN_SRC c
     while( EOF != (c=getchar()) ){
       switch(state){
       case INICIAL:
         switch(c){
         case 'a':
           state=INICIAL;
           continue;
           // ...
         }
         // ...
       }
      }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice el anterior fragmento de un programa C, asuma que se incluyó el header correspondiente.
   y que es parte de la implementación de una *máquina de estado*, responda
   considerando sólo la parte presentada:
   
   1. Indique el *tipo de máquina de estado*. Justifique.
   2. Indique a qué conjunto pertenece ~INICIAL~
   3. Indique a qué conjunto pertenece ~a~
   4. Escriba la o las *transiciones* que representa.
   5. Escriba una *ERX* análoga.
   6. Escriba una *producción* análoga.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Un (AFD) Autómata Finito Deterministico,
   - Finito porque tendremos un finito número de opciones en la *sentencia de selección switch*
   - Determinístico, porque sabemos cual será su comportamiento, es decir cuales serán las entradas y sus salidas

   (2) ~INICIAL~ pertenece al *conjunto de Estados* y a (Q) que suele representar al estado inicial

   (3) ~a~ pertenece al *Alfabeto* (Sigma), los caracteres que son leídas en cada transición

   (4) La transición sería ~T('a', INICIAL)=INICIAL~,

   (5) Una *ERX* análoga sería ~a*~,
   usamos el asterisco que representa la *clausura de kleene* porque la primera entrada
   podría haber sido *EOF* por tanto no haría la lectura del caracter ~a~

   (6) Una producción análoga sería ~S -> Sa | epsilon~,
   donde epsilon sería la palabra vacía, aunque también podríamos haber usado lambda
   #+END_QUOTE
** Problema 2 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
   Indique para cada lenguaje el ó los automatas capaces de reconocerlos.
   Elegir entre los sig. autómatas AFD, AFN, AP, MT
   
   1. Lenguaje "constantes enteras de C"
   2. ~{a^n b^n c^n | n>=1}~
   3. Lenguaje "sentencias de iteración de C"
   4. ~{a^n b^t | n>=1 ^ t>=1}~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Como puede ser reconocido por un AFD ó AFN,
   entonces también reconocido por un AP y MT, es decir todos.

   (2) por una (MT) *Maquina de Turing* porque todos tienen la misma constante ~n~,
   y sólo éste autómata podría realizar esa tarea compleja,
   de que se repita misma cant. de letras en simultaneo

   (3) por un (AP) *Autómata de Pila*, por el balanceo de los paréntesis
   por tanto también podría un (MT)

   (4) Como puede ser reconocido por un AFD ó AFN,
   entonces también reconocido por un AP y MT, es decir todos.
   #+END_QUOTE
** [TODO] Problema 3 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
   Indique la *secuencia de algoritmos* para obtener un *AFD a partir de una ER*
   #+END_QUOTE


*** Respuesta (resolución)
   #+BEGIN_QUOTE
   - Algortimo de Thompson
   - Algoritmo de Clausuras-ε o de Construccíon de Subconjuntos
   - Algoritmo de Minimización
   #+END_QUOTE
** [TODO] Problema 4 (2019-07-15)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la regex ~[ab]?~ dibuje el *AF obtenido mediante Thompson*
   #+END_QUOTE
** [TODO] Problema 5 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   Defina formalmente el AF que resulta de la intersección entre las constantes octales sin sufijo
   de C, las expresiones de C y el LF "números sin signo expresados en base dos".
   #+END_QUOTE
*** Respuesta (resolución)
   #+BEGIN_COMMENT
   Constantes Octales sin sufijo la ER: 0[0-9]
   Expresiones de C: más amplia
   Numeros sin signo en base dos: 

   A=>0=>B
   B=>0=>B
   B=>1=>B
   #+END_COMMENT
   
   #+BEGIN_QUOTE   
   M=({A,B},{0,1},{A⇒0⇒B,B⇒0⇒B,B⇒1⇒B},0,{B})
   #+END_QUOTE
