#+TITLE: Resumen de Finales - Lenguajes Formales + BNF de C + Autómatas
#+STARTUP: inlineimages
* BNF de C
** Problema 1 (2019-02-25)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde la afirmación falsa con respecto a BNF:

   1. Es un *meta lenguaje*
   2. Posee *metasímbolos*
   3. Es útil para definir *LP*
   4. Puede describir cualquier *LF tipo 2*
   5. Puede describir el *LF identificadores de C*
   6. Puede describir el *LF expresiones de C semánticamente correctas*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (resuelta) La BNF no puede describir un LF tipo 1 osea (LSC), no?
   me parece que no porque es una (GIC) y ésta no puede generar lo mismo que una (GSC)
   según la jerarquía de chomsky, no?
   
   *Rta:*: Claro, la BNF es similar a una (GIC) por tanto no puede generar lo mismo que una (GSC),
   se podría decir que no es tan potente
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) Verdadero, la BNF es un *meta lenguaje*

   (2) Verdadero, la BNF de C tiene como metasímbolo el ~:~ actúa como el ~->~ para las producciones,
   aunque no posee el ~|~ para las opciones se agregan en una nueva linea

   (3) Verdadero una BNF sirve para definir y documentar un LP

   (4) Verdadero, la BNF puede describir cualquier (LF) tipo 2 osea un (LIC),
   en la BNF de C se describen las *Categorias Léxicas* (TOKENS, son LRs)
   y las *Categorías Sintácticas* del lenguaje y sus restricciones

   (5) Verdadero

   (6) Falso, una BNF podría no representar ciertas restricciones que si podría una (GSC)
   #+END_QUOTE
** [#A] Problema 2 (2018-12-10)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todos los conceptos que se pueden definir con el *BNF del LF Expresiones de C*
   1. *Efecto de lado* de la expresión.
   2. *Precedencia* de los OPERADORES.
   3. *Asociatividad* de los OPERADORES.
   4. *Orden de evaluación* de los OPERANDOS.
   5. Aridad (cantidad de operandos) de los OPERADORES.
   #+END_QUOTE
*** Respuesta   
   #+BEGIN_QUOTE
   (2) Verdadero, la BNF del LF expresiones de C define la precedencia de los OPERADORES (por cercanía o no al axioma)..
   Más cercano esté del axioma, menos precedencia(prioridad)

   (3) Verdadero, la asociatividad está marcada si la regla/producción es a izquierda ó derecha

   (4) FALSO. La BNF no define el *orden de evaluacion de los OPERANDOS*, sólo de los OPERADORES.

   (5) Verdadero, la regla lo indica explícitamente Ej. si el operador es unario tendrá sólo un operando
   #+END_QUOTE
*** Dudas resueltas
**** Duda 1
   #+BEGIN_QUOTE
   Donde está definido el efecto de lado de C? En el MROC?
   Yo creí que era Verdadero, porque.. como estaba la expresión de asignación (?)
   
   *Rta:*
   La BNF de LF expresiones de C no puede definir el *efecto de lado* de la expresión,
   porque esto pertenece a la etapa de *Análisis Sintáctico*,
   el efecto de lado es un concepto *Semántico*
   #+END_QUOTE
** [#A] Problema 3 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la gramática
   sentencia-for:
   for ( expresión ; expresión ; expresión ) { sentencia }
   
   1. V/F? Representa las *sentencias-for de C*
   2. Calcule ~Primero(sentencia-for)~
   3. V/F? La ~sentencia-for~ con menor cantidad de TOKENS tiene siete TOKENS.
   4. V/F? El lenguaje que genera puede reconocerse con un *autómata de pila*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO, porque
   1. las tres expresiones que tiene la sentencia ~for~ deben ser opcionales, y ahi no lo son
   2. las llaves que indican el comienzo de una *sentencia compuesta* también debería ser opcional, y ahi no lo son
   3. no contempla que *la primera expresión pueda ser una Declaración*
       
   (2) Al calcular ~Primero(sentencia-for)~ obtenemos ~for~

   (3) FALSO, la sentencia-for con menor cantidad de TOKENs es ~for(;;);~ que tiene 11 TOKENs si agregamos 1 token por cada exp como minimo

   (4) Verdadero, porque al ser una *sentencia iteración* pertenece a una de las 3 *categorías sintácticas*,
   sabiendo que las Categorías Sintáctica son (LICs) generadas por (GICs) y pueden ser reconocidas por un (AP) Automáta de Pila
   #+END_QUOTE

   |----+-----------+----------------------------------|
   |    | Lexema    | Tipo de TOKEN (Categoría léxica) |
   |----+-----------+----------------------------------|
   |  1 | for       | palabra reservada                |
   |----+-----------+----------------------------------|
   |  2 | (         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   |  3 | expresion | *al menos 1 token*               |
   |----+-----------+----------------------------------|
   |  4 | ;         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   |  5 | expresion | *al menos 1 token*               |
   |----+-----------+----------------------------------|
   |  6 | ;         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   |  7 | expresion | *al menos 1 token*               |
   |----+-----------+----------------------------------|
   |  8 | )         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   |  9 | {         | caracter de puntuación           |
   |----+-----------+----------------------------------|
   | 10 | sentencia | *al menos 1 token*               |
   |----+-----------+----------------------------------|
   | 11 | }         | caracter de puntuación           |
   |----+-----------+----------------------------------|
** [#A] Problema 4 (2021-08-04)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba el *BNF ó las reglas de la gramática* para un lenguaje que sea
   un *sublenguaje de las expresiones de C*, pero que solo tenga las operaciones de asignación y multiplicación.
   La de *mayor precedencia* es la multiplicación. La *asignación es asociativa de DI* y *la multiplicación de ID*
   Asuma que el noterminal ~ExpresiónPrimaria~ está definido.
   
   Algunos ejemplos de expresiones síntacticamente correctas son:
   a
   a*b
   a*b*c
   a=b
   a=b=c
   a=b*c
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Si la Multiplicación tiene mayor precedencia que la Asignación,
   entonces la producción de la Multiplicación debe estar lo más lejos del axioma (de la producción que genera las expresiones),
   y por tanto la Asignación estará lo más cerca posible del axioma
   
   Si la Multiplicación es *asociativa de Izquierda a Derecha*
   entonces es *recursiva a izquierda*, los valores son generados a izquierda de la primera expresión
   S->aS | b, aaaaaaab
   Ej.
   1. b*a
   2. c*b*a
   3. ...*c*b*a

   Si la Asignacion es *Asociativa de Derecha a Izquierda*,
   entonces es *recursiva a derecha*, los valores son generados a derecha de la primera expresión
   Ej.
   1. a=b
   2. a=b=c
   3. a=b=c=d
   4. a=b=c=d=....
   #+END_COMMENT
   
   #+BEGIN_QUOTE   
   <expresion> ->
     <expresionPrimaria> = <expresion> |
     <expresionMultiplicativa> |
     <expresionPrimaria>

   <expresionMultiplicativa> ->
      <expresionMultiplicativa> * <expresionPrimaria>
      <expresionPrimaria>
   #+END_QUOTE
** Problema 6 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~L={a^n b^n | n>0}~
   Escriba un BNF que lo genere.
   #+END_QUOTE
* [TODO] C vs C++ vs Otros
** Problema 1 (2020-03-03)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba un fragmento breve que sea sintáctimente válido tanto en C y como en C++, pero
   que tenga diferente semántica para cada LP.  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   struct Punto{double x,y;}; // <- la resolución sugiere esto, pero.. no se el porque (????)
   #+END_COMMENT
** Problema 2 (2020-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Ejemplifique brevemente un aspecto sintáctico en el cual el LP C es diferente a otro LP
   que usted conozca. Justifique.  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   En C podemos definir ~int edad~
   mientras que en javascript podriamos definirlo como ~var edad~
   sin indicar que es del tipo entero
   #+END_QUOTE
** [#A] Problema 3 (2020-02-12)
*** Pregunta
   #+BEGIN_QUOTE
   Indique y justifique el valor de verdad de la siguiente afirmación:
   Los LP C y C++ tienen la misma sintaxis.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Falso.
   1. En C++ permite el manejo de templates para funciones genéricas, en C no
   2. En C++ existen los operadores ~new~ y ~delete~ para alocar/desalocar espacio en memoria
   3. En C se usa ~malloc~ y ~free~ para alocar/desalocar espacio en memoria
   4. En C permite pasar parámetros por referencia ~&~ (/se agrega sólo en la firma de la función, pero no cuando se invoca/)
   #+END_QUOTE
   
   #+BEGIN_SRC C
     /*
      ,* Ejemplo en C++, de parámetro por referencia
      ,*/
     void incrementarSaldo(int &saldo, int cantidad){ // <- el & indica que le pasamos la referencia de la variable, aumenta el alcance
       saldo += cantidad;
     }

     int main(){
       int saldo = 0;
       // pasamos "saldo" por referencia, pero eso lo indicamos en la firma donde se utilice
       // genera efecto en "saldo"
       incrementarSaldo(saldo, 500);

       int numero = new int(5); // <-- operador new para alocar espacio en memoria, sólo en C++ existe
       delete numero;  // <-- operador delete para liberar espacio en memoria, sólo en C++ existe
     }
   #+END_SRC
** [WAITING] [#A] Problema 4 (2021-02-17)
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas sobre las características del lenguaje C:
    
    1. Es interpretado.
    2. Es de alto nivel.
    3. Es estáticamente tipado.
    4. Incluye el tipo de dato string (cadena).
    5. En tiempo de ejecución asocia un tipo a cada valor
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Necesito más justificaciones..
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Falso, el lenguaje C es un lenguaje compilado,

   (2) Verdadero

   (3) Verdadero

   (4) Falso, el lenguaje C no incuye el tipo de dato String,
   se requiere de un puntero a char ó de un vector de char

   (5) Falso, el tipo de dato se asocian en tiempo de compilación
   #+END_QUOTE
* Gramáticas Ambiguas
** [#A] Problema (1) - 2020-12-21
*** Enunciado
   #+BEGIN_QUOTE
    En la especificación del Lenguaje de C está la siguiente gramática:
    
    selection-statement:
    if ( expression ) statement
    if ( expression ) statement else statement
    switch ( expression ) statement

    1. Indique el *conjunto primero* de ~selection-statement~
    2. Justifique si la *gramática es ambigua*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) El *conjunto primero* es ~{if,switch}~

   (2) La gramática dada es ambígua porque podemos llegar a ~if~ anidado con  ~if else~,
   con dos derivaciones distintas (aplicando distintas producciones)
   
   La ambíguedad se da cuando podemos obtener el mismo resultado de distintas maneras,
   como ocurre en el Lenguaje Natural, donde se pueden tener varias interpretaciones de una palabra.
   #+END_QUOTE
   
   
   |---+------------------------------------------------------+---------------------------|
   |   | Derivación Vertical por izquierda                    | produccion/regla aplicada |
   |---+------------------------------------------------------+---------------------------|
   | 1 | if(expresion) sentencia                              | regla 1                   |
   |---+------------------------------------------------------+---------------------------|
   | 2 | if(expresion) if(expresion) sentencia else sentencia | regla 2                   |
   |---+------------------------------------------------------+---------------------------|

   |---+------------------------------------------------------+---------------------------|
   |   | Derivación Vertical por izquierda                    | produccion/regla aplicada |
   |---+------------------------------------------------------+---------------------------|
   | 1 | if(expresion) sentencia else sentencia               | regla 2                   |
   |---+------------------------------------------------------+---------------------------|
   | 2 | if(expresion) if(expresion) sentencia else sentencia | regla 1                   |
   |---+------------------------------------------------------+---------------------------|
* Lenguajes Formales
** Problema 1 (2021-02-10)
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas acerca de los *LIC*
    
    1. Son generados por *GSC*
    2. Son representados por *ER*
    3. Son fundamentales para los *LP*
    4. Algunos se los puede *definir por extensión*
    5. Las *declaraciones de C* son un ejemplo de *LIC*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero, porque los (LICs) son *Lenguajes Independientes de Contexto* generados por (GICs),
   y también pueden ser generados por (GSCs) según la jerarquía de chomsky..

   (2) FALSO, los (LICs) NO pueden ser representados por (ERs)
   porque las (GRs) que generan los (LRs) que pueden ser representados por (ERs)
   no soportan generar la misma cantidad símbolos en simultáneo (característica que si soportan las GICs),
   en otras palabras *Una (GR) no puede hacer que si A aumenta N veces, B aumenta N veces también*
   llevándolo a C no soportan el balanceo de paréntesis por ejemplo ~EXP->( EXP ) | ...~

   (3) Verdadero, los (LICs) son necesarios en los (LPs) para poder definir la sintáxis del (LP)

   (4) Verdadero, aquellos (LICs) que sea finitos pueden ser definidos por extensión

   (5) Verdadero, las *declaraciones de C* son (LICs), es una de las tres categorías sintácticas.
   Las otras dos son las *sentencias* y las *expresiones*
   #+END_QUOTE
** Problema 2 (2021-02-17)
*** Enunciado
   #+BEGIN_QUOTE
   Indique todas las afirmaciones verdaderas sobre los *LR*:
   
   1. Juegan un rol importante en los *LP*.
   2. Siempre pueden representarse por *ER*.
   3. Siempre pueden *definirse por extensión*.
   4. Siempre pueden definirse mediante una *GIC*.
   5. Los literales-cadena de C son un ejemplo de *LR*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero, los (LRs) representan las *Categorías Léxicas* de un (LP)
   como son los Literales Cadena, Constantes numéricas enteras, Constantes numéricas reales,
   las Constantes caracter, los Identificadores, los Operadores y los Caracter de puntuación

   (2) Verdadero, los (LRs) siempre pueden representarse por un (ER)

   (3) FALSO, no todos los (LRs) pueden definirse por extensión,
   como es el caso de los (LRs) infinitos.

   (4) Verdadero, cualquier (LR) puede ser generado por una (GIC),
   según la jerarquía de Chomsky, donde el (LR) es el lenguaje formal más simple.

   (5) Verdadero, los *Literales Cadena de C* son (LRs), y es una de las *categorías léxicas*
   donde cada categoría léxica es un (LR)
   #+END_QUOTE
** Problema 3 (2021-02-24)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión, que es sintácticamente correcta, y luego responda:
   ~f(g(x))~
   
   1. Escriba una *GF* que genere un *LF* no regular al cual pertenezca la expresión.
      Asuma que ~Ident~, ~ParIzq~, ~ParDer~ son *terminales* definidos
   2. Derive la expresión dada de la *GIC* que haya definido.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE   
   La (GF) Gramática Formal "NO regular" que genera la expresión dada sería
   ~G=(Vn=S, Vt={Ident,ParIzq,ParDer},P={S->Ident ParIzq S ParDer, S->Ident}, S)~
   
   Las producciones de la gramática, la definimos observando que las subexpresiones
   que debe generar la gramática son las siguientes
   1. x
   2. g(x)
   3. f(g(x))

   Por tanto las producciones serían
   ~S -> Ident ParIzq S ParDer | Ident~

   Derivación por izquierda la expresión dada
   1. S
   2. f ( S )
   3. f ( g (  S ) )
   4. f ( g ( x ) )
      
   La gramática dada NO es regular, porque es recursiva a izquierda y a derecha al mismo tiempo,
   y una (GR) permite que sea recursiva a izquierda ó a derecha, pero no ambas.
   #+END_QUOTE
** Problema 4 (2020-12-14)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~L={a^m b^(2n+1) | m>=0, n>=0}~
   
   1. Escriba una *RegEx* que lo represente.
   2. Escriba las cuatro *palabras de menor longitud*
   3. Indique un cambio en la *definición de L* que lo haga *no regular*
   4. ¿Es este LF un sublenguaje de alguna *categoría léxica de C*? Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) La RegEx que lo representa sería: ~a*b(bb)*~

   (2) Las cuatro palabras de menor longitud serían ~{a,b,ab,abb}~

   (3) Un cambio en la definición que lo haga NO regular, sería que la *definición por comprensión*
   sólo us una constante en vez de dos ~m~ y ~n~.
   No se puede plantear lo siguiente, sea A y B un conjunto de caracteres, si A aumenta B aumenta,
   porque no se puede aumentar o disminuir la longitud de dos o más caracteres en simultaneo.
   Por definición, un LF es regular
   - si y solo si existe una GR que lo genere
   - si y solo si existe un AF que lo reconoce

   (4) Verdadero, éste es un sublenguaje de los *identificadores*,
   una de categorías léxicas de C
   #+END_QUOTE
** [#A] Problema 5 (2020-10-13)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~L={x^n y^(2n+1) | n>=0}~
   
   1. Escriba las *producciones* de una *gramática* que que lo genere.
   2. Indique la *intersección* de L con el *LF expresiones de C*
   3. Indique un *cambio en la definición de L* que lo haga *regular*
   #+END_QUOTE
*** Respuesta   
   #+BEGIN_QUOTE
   (1) Las producciones de una gramática que genere a dicho lenguaje serían
   ~S -> y | xSyy~

   (2) LF Expresiones INTERSECCIÓN L = L, es decir el propio lenguaje L
   ya que éste es un sublenguaje del LF de Expresiones,

   (3) Para hacer a L un LR, podrían haber dos constantes distintas, una para ~x~ y otra para ~y~
   ya que los (GRs) no soportan generar palabras en misma cantidad en simultáneo
   Ej. ~L={x^n y^(2m+1) | n>=0, m>=0}~
   
   (3) Otra alternativa sería sacar la constante ~n~ de ~x~ ó de ~y~
   quedando recursiva de un sólo lado, que si soportan las (GRs).
   Ej. ~L={x y^(2n+1) | n>=0}~ ó ~L={x^n y^(2+1) | n>=0}~
   #+END_QUOTE
*** Dudas resueltas
**** Duda 1
   #+BEGIN_QUOTE
   En la (3) La resolución sólo sugiere sacar el exponente de ~x~, pero agregar un exponente
   para ~x~ y otro para ~y~ no sería también otra solución?
   
   *Rta:*
   Si, sería otra solución, pero a lo que apunta la resolución es para que se recursiva a izquierda,
   de esa manera entonces también es (LR)
   #+END_QUOTE
** [#A] Problema 6 (2020-03-03)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba una *RegEx (metaER)* que represente las *constantes hexadecimales sin sufijo* en C:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Regex: ~0[xX]([0-9-a-fA-F])+~

   1. Debe comenzar con un cero
   2. Seguido de una x (es indiferente si minúscula ó mayuscula)
   3. Seguido de al menos digito del 0 al 9 ó.. de una letra de la A a la F (es indiferente si es  minúscula ó mayuscula)
   #+END_QUOTE
** [#A] Problema 7 (2020-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba una *RegEx (MetaER)* que represente *los cuatro operadores aritméticos básicos*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Regex: ~\-\*\/\+~

   Es necesario usar la barra invertida ~\~ para considerar los símbolos como caracteres comunes,
   caso contrario actuarían como operadores (Ej. el * como la clausura de kleene, ó el + como la clausura positiva)
   #+END_QUOTE
** [#A] Problema 8 (2020-02-12)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas.
   Para demostrar que un *LF* es un *LR*, es suficiente con que
   
   1. su *cardinalidad* sea finita.
   2. sea procesable por un *ASDR*
   3. encontremos una *GF* que lo genere.
   4. lo podamos *definir por comprensión*
   5. encontremos un *AFN* que lo reconozca.
   6. encontremos una *ER* que lo represente.  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero, un LF finito puede ser representado por un LR
   Ej. las palabras reservadas, ó los caracteres de puntuación son LRs

   (2) FALSO, porque un (ASDR) utiliza un Parser (analizador sintáctico)
   que entiende (LICs), y puede que ese (LF) no sea un (LR) si no bien un (LIC)
   
   (3) FALSO, puede haber una (GF) Gramática Formal como lo es una (GIC) que genere al LF,
   y ésta no sería un (LR), si no un (LIC).

   (4) FALSO, si definimos el sig. lenguaje por comprensión ~L={x^n y^n / n>=0}~
   vemos que no es un LR porque no se puede generar ~x~ e ~y~ en simultaneo del mismo tamaño

   (5) Verdadero, Si existe un AFN que reconozca al LF, entonces LF es LR
   además para todo AFD existe un AFN equivalente
   
   (6) Verdadero, un LF es LR siempre que haya una ER que lo represente
   #+END_QUOTE
** Problema 9 (2019-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~Σ={0,1}~ y el LF empiezan y terminan con 0, lo cual incluye la palabra 0:
   
   1. Escriba una *ER* que lo represente:
   2. Escriba una *ERX* ó *RegEx* que lo represente:
   3. Escriba un *BNF* que lo genere:
   4. Dibuje el *digrafo de un AFN* que lo reconozca:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) ER: ~0+0(0+1)*0~
   Usamos el ~+~ para la unión en las ER, y los ~()~ con ~+~ para agrupar y elegir uno

   (2) ERX: ~0|0[01]*0~
   Usamos el pipe ~|~ para la uión en las Regex y los ~[]~ para elegir uno de los caracteres

   (3)
   alternativa #1
   S -> 0  | 0N
   N -> 1N | 0N | 0

   alternativa #2
   S -> 0  | 0N0
   N -> 1N | 0N | epsilon

   El (AFN) Automáta Finito NO Determinístico que hicimos,
   es NO deterministico porque desde un estado va a otros dos
   con el mismo caracter donde la función de transición sería
   ~T(q0,a) = q1~ y ~T(q0,a) = q3+~
   #+END_QUOTE

   #+BEGIN_SRC plantuml :file img/automata1.png :exports results
     @startuml
     digraph foo {
      ' cambiamos la dirección: left to right
      rankdir=LR
      "q0-" -> "q1" [label=0]
      "q0-" -> "q3+" [label=0]
      "q1" -> "q1" [label="0,1"]
      "q1" -> "q2+" [label=0]
     }
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:img/automata1.png]]
** Problema 12 (2019-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~P~ el ~LF~ nombres de los elementos de la tabla periódica,
   ~D~ el *LF declaraciones de C*,
   y ~O~ el *LF constantes enteras octales sin sufijo de C*

   1. Indique el tipo del LF ~P~. Justifique.
   2. Indique el tipo del LF ~D Union O~. Justifique.
   3. Escriba una ERX para el LF ~(P Interseccion D) Union O~:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Tipos de Lenguajes, según la jerarquía de Chomsky
   - Tipo 0, (LI) Lenguaje Irrestricto
   - Tipo 1, (LSC) Lenguaje Sensible del Contexto
   - Tipo 2, (LIC) Lenguaje Independiente del Contexto <- tipo de LF que son las *constructos/categorías sintácticas*
   - Tipo 3, (LR) Lenguaje Regular <- el más simple, tipo de LF que son las *categorías léxicas* (ó TOKENs)
   
   (1) Como que los elementos de la tabla períodica sólo como palabras formadas por letras
   - es del TIPO 3 (por tanto es LR)
   - es FINITO, porque tiene una cantidad finita de palabras

   (2)
   Como el *LF de declaraciones de C* es una de las *categorías sintácticas*
   y como C define las *categorías sintácticas* en notación BNF y ésta representa un LIC,
   entonces es un (LIC)
   
   Como el *LF constantes enteras octales sin sufijo de C* es una de las *categorías léxicas* es un (LR),
   
   Como para cualquier (LR) existe una (GIC) que lo genere, y una GIC puede generar una BNF,
   entonces la unión entre un (LIC) y un (LR) es un (LIC),
   por tanto es del TIPO 2
   #+END_QUOTE
** [WAITING] [#A] Problema 13 (2019-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto a las ER:

   1. ~*a~ es una *ER*
   2. Tienen una sintaxis formal.
   3. Tienen *operadores con precedencia*
   4. Las ER son un *sublenguaje de las expresiones de C*
   5. Las *expresiones de C* son un *sublenguaje de las ER*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (4) la resolución decía FALSO.. Por que??

   yo había puesto que.. era Verdadero, porque como cada (ER) representa un (LR) como las *categorías léxicas*
   y las *expresiones de c* son (LICs) osea *categorías sintácticas* que son generadas por (GICs),
   entonces las (ER) representan a (LR) que pueden ser sublenguajes de las *expresiones de C*
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) FALSO, ~*a~ NO es una ER, ya que el operador ~*~ osea la clausura de kleene requiere un caracter a su izquierda

   (2) Verdadero, porque una ER representa a un LR y estos son LF

   (3) Verdadero, la precedencia de los operadores de una ER está dada así
   1. Potencia ~^~, ~*~ Clausura de Kleene y ~+~ Clausura Positiva (las tres tienen mayor precedencia)
   2. Concatenación
   3. Unión ~+~ (menor precedencia)

   (5) FALSO, las *expresiones de C* están formadas por (GICs)
   y las (ERs) representan (LR) que están generados por (GRs)
   estas últimas gramáticas generan los (LF) más simples
   mientras que las (GICs) representan (LF) más complejos
   #+END_QUOTE
** Problema 14 (2019-02-11)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto al uso de las ER:

   1. Pueden representar cualquier *LR*.
   2. Pueden representar el *LF sentencias*
   3. Pueden representar el *LF intersección de identificadores con expresiones*
   4. Pueden representar el *LF constantes* de forma más compacta que las ERX
   5. Pueden representar el *LF identificadores* de forma más compacta que las ERX.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   LI (tipo 0), LSC (tipo 1), LIC (tipo 2), LR (tipo 3)

   (1) Verdadero, las (ER) pueden representar cualquier (LR)
   
   (2) FALSO, el *LF de sentencias* es un (LIC) generado por una (GIC) por tanto es del tipo 2,
   y una (ER) sólo puede representar (LR) que son del tipo 3, según la jerarquía de chomsky
   además los (LICs) tienen la característica del *balanceo de paréntesis* que no soportan los (LR)

   (3) Verdadero, porque los *identificadores* son (LR) 
   y las *expresiones* son (LIC) por estar en notación BNF por tanto ser generado por una (GIC),
   por tanto lo único que tienen en común serán las palabras del (LF) más simple
   que en este caso sería (LR) que es del tipo 3

   (4) FALSO, una ER podría no representar al LF de constantes de forma más compacta que una ERX,
   por ejemplo la ER que representa a las constantes númericas octales sin sufijo sería ~0(0+1+..+7)*~
   mientras que la ERX sería ~0[0-7]*~

   (5) FALSO, por la misma razón que con las constantes,
   Ej. una ER que indicaría como puede empezar un identificador sería ~(_+(a+b+..+z+A+B+..+Z+0+1+..+9))~
   mientras que una ERX sería más compacta ~_|[a-zA-Z0-9]~
   #+END_QUOTE
** [WAITING] [#A] Problema 15 (2018-12-03)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto a los (LR)
   1. Son fundamentales para los (LP)
   2. Son representables mediante (ER)
   3. Son representables mediante BNF.
   4. Son *cerrados bajo la concatenación*
   5. Pueden *incluir sublenguajes que no son LR*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (5) en la resolución dice que es Verdadero, pero no lo justifica.. (?)
   
   yo había puesto que era Falso, que los (LR) no pueden incluir sublenguajes de otro tipo que no sea (LR),
   porque los (LR) son el tipo de (LF) más simple
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Verdadero, los (LR) son fundamenales para los (LP)
   Por ejemplo para las *categorías léxicas de C* que representan a
   los identificadores, las constantes numéricas enteras/reales, constantes de caracter, literales cadena,
   operadores y caracter de puntuación (punctuator)

   (2) Verdadero, las (ER) representan (LRs)

   (3) Verdadero, una BNF puede representar un (LR)
   porque la notación BNF es similar a una (GIC) y éstas pueden generar tanto (LIC) como (LR)
   según la jerarquía de chomsky

   (4) Verdadero, porque las (ER) que los representan a los (LR)
   son cerrados para las *operaciones básicas* (concatenación, unión, las Clausuras, ...)
   #+END_QUOTE
** Problema 16 (2018-12-03)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto a las (GR)
   1. Pueden *generar lenguajes infinitos*
   2. Generan lenguajes representables por RegEx.
   3. Sus *producciones pueden tener ε (epsilon)* en su derecha.
   4. Generan *LF reconocibles con autómatas con pila*
   5. Sus *producciones pueden tener terminales* en su izquierda.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero, las (GR) pueden generar *lenguajes infinitos* si tienen producciones recursivas
   Ej. ~S->Sa|b~ (recursiva a izquierda) ó ~S->aS|b~ (recursiva a derecha) ó ~S->SaS|b~

   (2) Verdadero, las (GR) pueden generar lenguajes que sean representables por una Regex,
   porque las (GR) generan (LR) que pueden ser representados por (ER)
   y las *Regex* (ó MetaER) son *Expresiones Regulares Extendidas* que se les agregaron nuevos operadores
   que pueden representar los mismos (LR) que una (ER) pero de manera más compacta

   (3) Verdadero, una (GR) puede tener *epsilon* a la derecha de las producciones (pero NO a su izquierda)

   (4) Verdadero, un (GR) puede generar un (LF) que puede reconocer un (AP) *Autómata de Pila*,
   porque un (AP) es capáz de reconocer un (LIC) por tanto también podría un (LR) generado por una (GR)
   podemos relacionarlo también con la *jerarquía de chomsky* donde un autómata de pila (AP) puede reconocer palabras
   de un autómata más simple como un (AF) que reconoce (LR)

   (5) FALSO, una (GR) NO puede tener (Vt) *terminales* a la izquierda de las producciones,
   las únicas gramáticas que lo soportan son la (GI) *Gramática Irrestricta* (sin restricciones)
   y la (GSC) *Gramática Sensible de Contexto* que no tiene restricciones del lado izquierdo ni derecho
   excepto que si V->T es una produccion ~|V|<=|T|~
   #+END_QUOTE
** [#A] Problema 17 (2018-10-03)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto a las GIC:
   1. Pueden generar *lenguajes finitos*
   2. Sus producciones pueden tener ε (epsilon) en su derecha.
   3. Generan *LF reconocibles autómatas con pila*
   4. Sus producciones pueden tener terminales en su izquierda.
   5. Generan *LF procesables por Parsers con (ASDR) Análisis Sintáctico Descendente Recursivo*
   #+END_QUOTE
*** Respuesta   
   #+BEGIN_QUOTE
   (1) Verdadero, las (GICs) pueden generar *lenguajes infinitos*

   (2) Verdadero, las (GICs) pueden tener epsilon a la derecha de las producciones (pero no a su izq)

   (3) Verdadero, las (GICs) pueden generar (LF) reconocibles por (AP) Autómatas de Pila

   (4) FALSO, las (GICs) NO pueden tener (Vt) *terminales* a la izquierda de las producciones,
   sólo las (GSC) y (GI) pueden tenerlos.
   #+END_QUOTE
*** Duda Resuelta
**** Duda 1
   #+BEGIN_QUOTE
   <<DUDA>>: En la (5) la resolución dice que es FALSo, por que?

   yo había puesto Verdadero, porque un Parser lee (LICs) que son generados por (GICs),
   que sea con (ASDR) *Análisis Sintáctico Descendente Recursivo* sólo indíca que el Parser
   realiza el *proceso de derivación* osea desde el axioma hasta la cadena final
   ó bien también desde el *árbol sintáctico* partiendo desde la raíz hasta las hojas

   *Rta:*
   Porque una GIC puede ser recursiva a izquierda, y como los (ASDR) usan LL(1) que no soportan recursividad a izq.,
   entonces podrían no ser procesables por un parser con ASDR ya que podrían ser GICs
   con recursividad por izquierda
   #+END_QUOTE
** Problema 18 (2018-07-30)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto a los AF, ER, y GR.
   1. Son *modelos matemáticos equivalentes*
   2. Están *asociados con los lenguajes tipo 3*
   3. Son *útiles para diseñar un analizador sintáctico*
   4. Siempre tienen un *equivalente en notación BNF*
   5. Pueden, respectivamente, reconocer, representar, y generar las palabras clave de C
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero

   (2) Verdadero, las (GRs) generan (LRs) que son representables por (ER) y reconocidos por (AF)

   (3) FALSO, un *analizador sintáctico* reconoce (LICs)
   son útiles para un *analizador léxico* que reconocen (LRs)

   (4) Verdadero, porque la *notación en BNF* es similar a una (GIC) pero con otros *metasímbolos*
   y una (GIC) puede generar lo mismo que una (GR), según la *jerarquía de chomsky*
   ya que el (LR) es el el (LF) más simple

   (5) Verdadero, las *palabras claves de c* es un (LR) finito, por tanto
   lo puede generar una (GR), ser representado por una (ER) y ser reconocido por un (AF)
   #+END_QUOTE
** Problema 19 (2018-07-16)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde la afirmación falsa con respecto a las ER:
   1) Poseen el *operador intersección*
   2) Pueden *representar lenguajes infinitos*
   3) Pueden *representar todo lenguaje de tipo 3*
   4) Son *útiles para diseñar un analizador léxico*
   5) Pueden *describir el LF cadenas literales de C*
   6) Pueden *describir el LF constantes enteras octales de C*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO, las (ER) no tienen el operador intersección.
   Sólo tienen: Concatenación, Unión , Potencia, Clausura de Kleene, Clausura Positiva

   (2) Verdadero, las (ER) pueden representar *lenguajes finitos*
   con la clausura de kleene y/o clausura positiva

   (3) Verdadero, las (ER) pueden representar cualquier *lenguaje de tipo 3*
   porque según la *jerarquía de chomsky* los (LRs) son del tipo 3
   - LI (tipo 0)
   - LSC (tipo 1)
   - LIC (Tipo 2)
   - LR (Tipo 3)

   (4) Verdadero, las (ER) son utiles para diseñar un analizador léxico (ó Scanner),
   porque las *categorías léxicas* son (LRs) y las (ER) justamente representan (LRs)

   (5) Verdadero, las (ER) pueden describir el LF de literales cadenas de C,
   porque ese LF es un (LR)

   (6) Verdadero, las (ER) pueden describir el LF constantes entras octales de C,
   porque dicho LF es un (LR)
   #+END_QUOTE
** [WAITING] [#A] Problema 20 (2018-07-16)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde la afirmación falsa con respecto a las GIC:
   1. Son *útiles para programar PAS*
   2. *Se las formaliza con una cuatro-upla*
   3. Siempre se *pueden traducir a notación BNF*
   4. Pueden *generar el lenguaje de Declaraciones*
   5. Son *útiles para diseñar un analizador sintáctico*
   6. Pueden *generar el lenguaje de las Expresiones sin errores de tipo*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: EN la (2) por que dice que no es falsa?
   yo había puesto FALSO, las (GIC) se formalizan en un (AP) *Automáta de pila* que es 7upa,
   se agrega el *alfabeto de la pila* y el *símbolo inicial de la pila*

   <<DUDA>>: En la (1) es Verdadero, pero.. por que son utiles para programar PAS?
   entiendo que (PAS) es *Procedimiento de Análisis Sintáctico* y que lo usa 
   el (ASDR) *Análisis Sintáctico Descendente Recursivo* (que es un Parser),
   y como este entiende (GICs).. es por eso (?)
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (3) Verdadero, una (GIC) siempre puede traducir a *notación BNF*
   porque se comporta igual, con la diferencia que tiene otros *metasímbolos*

   (4) Verdadero, una (GIC) puede generar el *LF de declaraciones*,
   porque éste (LF) es un (LIC) al estar en notación BNF,
   además es una de las tres *categorías sintácticas* (declaraciones, sentencias, expresiones)

   (5) Verdadero, las (GICs) son utiles para diseñar un *Analizador Sintáctico* (Parser),
   porque estos reconocen (LICs)

   (6) FALSO, las (GICs) NO pueden generar el LF de expresiones sin errores de tipo,
   porque los errores de tipo son *errores semánticos* no *sintácticos*
   #+END_QUOTE
** Problema 21 (2018-02-19)
*** Enunciado
   #+BEGIN_QUOTE
    Escriba la regex que representa al LF: ~L=(L1)^C INTERSECCION L2~
    con ~L1~ igual al *LF identificadores de C*
    y ~L2~  igual al *LF constantes enteras decimales sin sufijo de C*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   L1 Interseccion L2 = L2, entonces debemos hacer la regex de ~L2~

   regex: ~[1-9][0-9]*~
   #+END_QUOTE
* [TODO] [#A] LL
** Problema 1 (2018-12-17)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto a las LL(1):
   1. La GIC ~S -> a S | a~ es LL(1)
   2. La GIC ~S -> a b S | a~ es LL(1)
   3. Pueden tener *producciones recursivas*
   4. Pueden tener *producciones con épsilon del lado derecho*
   5. El *conjunto primero* de los *no terminales* deben ser vacíos
   #+END_QUOTE
*** Respuesta Resolución
   #+BEGIN_COMMENT
   <<DUDA>>: (1) porque *los conjuntos primeros no son disjuntos*
   Pero una solución para que sea LL(1) sería ~S->aR, R->aR | epsilon~ no?

   <<DUDA>> (2) por que?  si la primera produccion es ~ab~ y la otra ~a~,
   porque ambas empiezan con ~a~?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) FALSO,

   (2) FALSO

   (3) Verdadero

   (4) Verdadero

   (5) FALSO
   #+END_QUOTE
** Problema 2 (2018-02-26)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la gramática

   sentencia-if:
     if ( expresión ) sentencia
     if ( expresión ) sentencia else sentencia

   Indique si la gramática es *LL(1)*. Si lo es justifique, si no, reescríbala para que sí sea:
   #+END_QUOTE
*** Respuesta Resolución
   #+BEGIN_QUOTE
   No es LL(1) porque *los conjuntos primeros (o la función predice) no son disjuntos*.
   
   Pero si aplicamosel *algoritmo para eliminar prefijos comunes* (factorizar a izquierda)
   entonces nos quedaría LL(1)
   
   sentencia-if:
     if ( expresión ) sentencia else-opcional
     
   else-opcional:
     else sentencia
     ε
   #+END_QUOTE
** Problema 3 (2018-12-03)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente afirmación sobre las GIC LL(1):
   Dadas las *producciones de un no terminal*,
   los *conjuntos primeros de los lados derechos deben ser disjuntos*.
   ¿Está de acuerdo con la afirmación? ¿Por qué?
   #+END_QUOTE
*** Respuesta Resolución
   #+BEGIN_QUOTE
   Sí, porque si no son *disjuntos*
   no hay forma de seleccionar la producción a aplicar con
   sólo un (1) *símbolo de preanálisis* (siguiente token).
   #+END_QUOTE
** Problema 4 (desconocido)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la siguiente (GIC) encuentre una equivalente LL(1)
   
   S → SbD | ab
   D → a | az
   #+END_QUOTE
*** Respuesta Resolución (adaptada)
   #+BEGIN_QUOTE
   En ~S → SbD | ab~ observamos que
   - Recursividad a izquierda con ~α = bD~
   - y ~β = ab~
     
   En ~D → a | az~ vemos que
   - Prefijos comunes con ~α = a~ son ~β1 = ε~ y ~β2 = z~

   Entonces la (GIC) equivalente sería
   S → abS'
   S' → bDS' | ε
   
   D → aD'
   D' → z | ε
   #+END_QUOTE
* [WAITING] Match + Pas
** [WAITING] Problema 1 (2018-02-26)
*** Enunciado
   #+BEGIN_SRC C
     void S(){
       switch(GetProximoToken()){
       case A: Match(A); S(); Match(C); return;
       case B: Match(B); return;
       default: // TODO
       }
     }
   #+END_SRC

   #+BEGIN_QUOTE
   Dado el anterior PAS, resuelva los siguientes ítems:

   1. V/F? El PAS es *sintácticamente correcto*
   2. Dibuje el *árbol de expresión* de la *expresión de la sentencia etiquetada* con ~case B:~
   3. La *sentencia etiquetada* con ~default~ no fue desarrollada por el programador original, por
      eso tiene el comentario ~TODO~ (para hacer), complétela arriba, en el propio código.
   4. Defina el *conjunto de las producciones de la gramática* asociada al PAS:
   5. Escriba una *regex* que represente el asociado al PAS:
   6. Calcule ~Primero(S)~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (5) la resolución dice ~[A-C]~ pero no es recursiva a izquierda y derecha...?
   
   yo había puesto que, no existe una regex porque la gramática es un (GIC),
   y es recursiva a izquierda y a derecha al mismo tiempo,
   por tanto no existe una (GR) que genere ese (LR) y por tanto no hay una regex que lo represente

   <<DUDA>>: (6) como sería bien..?
   Primero(S) = Primero(A) U PRIMERO(B) = {A,B} ???
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Error Sintáctico luego ~default:~, no se esperaba unas ~}~ llaves que cierran,
   si no una expresión.

   (2) el árbol estaría formado así
   - raiz: ~()~
   - hojas
     - hoja izq: Match
     - hoja der: B
   
   (3) ErrorSintactico(GetProximoToken())

   (4)
   S->ASC
   S->B
   #+END_QUOTE
** Problema 2 (2019-12-11)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. Un *PAS* puede invocar al *scanner*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Verdadero,
   porque un PAS puede tener funciones tipo wrapper sobre el Scanner
   Ej. ~ProximoToken()~ y ~Match(t)~
   #+END_QUOTE
** Problema 3 (2018-07-16)
*** Enunciado
   #+BEGIN_QUOTE
   Calcule ~Primero(declaraciones) ⋂ Primero(sentencias-de-iteración)~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Vacío, porque no tienen nada en común
   #+END_QUOTE
** [WAITING] Problema 4 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~L={a^n b^n | n>0}~
   Codifique en C el o los PAS asociados:  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   S->aSb | ab
   #+END_QUOTE

   #+BEGIN_COMMENT
   <<DUDA>>: porque hace primero el Match(A) y luego el if? no es al revés?
   ó habrá querido asignarlo a una variable A ?
   #+END_COMMENT
   
   #+BEGIN_SRC C
     void S(){
       Match(A);
       
       if(proximoToken()==A){
         S();
         Match(b);
       }
     }

     // alternativa, si hubiera mas (Vn) no terminales
     void S(){
       Token t = getProximoToken();

       switch(t)
       case A:
         Match(A); S(); Match(b);
       break;
       default:
         InformarErrorSintactico();
     }
   #+END_SRC
*** Respuesta (Resolución)
   #+BEGIN_QUOTE
   void S(void){
     Match(A);
     
     if(A==GetNextToken())
       S();
     Match(B);
   }
   #+END_QUOTE
* Conjunto Primero
** [#A] Problema 1 (2018-02-19)
*** Enunciado
   #+BEGIN_QUOTE
   Calcule ~Primero(S)~, siendo ~S~ el no terminal del BNF de C, es decir, la gramática de
   las *sentencias de iteración de C*
   #+END_QUOTE
*** Respuesta
  #+BEGIN_QUOTE
  Primero(S) = {for,while,do}
  #+END_QUOTE
** [WAITING] Problema 2 (2018-07-30)
*** Enunciado
   #+BEGIN_QUOTE
   Dado los *LF expresiones y sentencias de C*, tilde la afirmación verdadera:

   1. Primero(expresiones) inclusion_estricta Primero(sentencias)
   2. Primero(expresiones) inclusion Primero(sentencias)
   3. Primero(expresiones) inclusion_al_reves Pimero(sentencias)
   4. Primero(expresiones) inclusion_al_reves ó igual Primero(sentencias)
   5. Primero(expresiones) interseccion Primero(sentencias) = enteros
   6. Primero(expresiones) interseccion Primero(sentencias) = flotantes
   #+END_QUOTE
   
   #+BEGIN_COMMENT
   la inclusion_estricta no lleva la rayita debajo del símbolo de inclusión,
   *A inclusion_estricta B*: algunos de A están en B, pero los B no están en A

   la inclusion normal, no lleva rayita debajo
   *A inclusion B*: algunos de A están en B, y viceversa
   #+END_COMMENT
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: La (2) dice que es FALSO, por que?
   yo había puesto verdadero porque era lo mismo que la (1)

   <<DUDA>>:
   Primero(expresiones) = expresion ?
   Primero(sentencias) = sentencia-seleccion, sentencia-iteracion, , ... ?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Verdadero, porque las sentencias pueden tener expresiones

   (3) FALSO

   (4) FALSO

   (5) FALSO

   (6) FALSO
   #+END_QUOTE
* Autómatas + Regex
** [#A] Problema 1 (2021-06-23)
*** Enunciado
   #+BEGIN_SRC c
     while( EOF != (c=getchar()) ){
       switch(state){
       case INICIAL:
         switch(c){
         case 'a':
           state=INICIAL;
           continue;
           // ...
         }
         // ...
       }
      }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice el anterior fragmento de un programa C, asuma que se incluyó el header correspondiente.
   y que es parte de la implementación de una *máquina de estado*, responda
   considerando sólo la parte presentada:
   
   1. Indique el *tipo de máquina de estado*. Justifique.
   2. Indique a qué conjunto pertenece ~INICIAL~
   3. Indique a qué conjunto pertenece ~a~
   4. Escriba la o las *transiciones* que representa.
   5. Escriba una *ERX* análoga.
   6. Escriba una *producción* análoga.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Un (AFD) Autómata Finito Deterministico,
   - Finito porque tendremos un finito número de opciones en la *sentencia de selección switch*
   - Determinístico, porque sabemos cual será su comportamiento, es decir cuales serán las entradas y sus salidas

   (2) ~INICIAL~ pertenece al *conjunto de Estados* y a (Q) que suele representar al estado inicial

   (3) ~a~ pertenece al *Alfabeto* (Sigma), los caracteres que son leídas en cada transición

   (4) La transición sería ~T('a', INICIAL)=INICIAL~,

   (5) Una *ERX* análoga sería ~a*~,
   usamos el asterisco que representa la *clausura de kleene* porque la primera entrada
   podría haber sido *EOF* por tanto no haría la lectura del caracter ~a~

   (6) Una producción análoga sería ~S -> Sa | epsilon~,
   donde epsilon sería la palabra vacía, aunque también podríamos haber usado lambda
   #+END_QUOTE
** Problema 2 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
   Indique para cada lenguaje el ó los automatas capaces de reconocerlos.
   Elegir entre los sig. autómatas AFD, AFN, AP, MT
   
   1. Lenguaje "constantes enteras de C"
   2. ~{a^n b^n c^n | n>=1}~
   3. Lenguaje "sentencias de iteración de C"
   4. ~{a^n b^t | n>=1 ^ t>=1}~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Como puede ser reconocido por un AFD ó AFN,
   entonces también reconocido por un AP y MT, es decir todos.

   (2) por una (MT) *Maquina de Turing* porque todos tienen la misma constante ~n~,
   y sólo éste autómata podría realizar esa tarea compleja,
   de que se repita misma cant. de letras en simultaneo

   (3) por un (AP) *Autómata de Pila*, por el balanceo de los paréntesis
   por tanto también podría un (MT)

   (4) Como puede ser reconocido por un AFD ó AFN,
   entonces también reconocido por un AP y MT, es decir todos.
   #+END_QUOTE
** [TODO] Problema 4 (2019-07-15)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la regex ~[ab]?~ dibuje el *AF obtenido mediante Thompson*
   #+END_QUOTE
** [TODO] Problema 5 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   Defina formalmente el (AF) que resulta de la intersección entre *las constantes octales sin sufijo de C*,
   *las expresiones de C* y el LF "números sin signo expresados en base dos".
   #+END_QUOTE
*** Respuesta (resolución)
   #+BEGIN_COMMENT
   *Constantes Octales sin sufijo la ER:* 0[0-9]
   Expresiones de C: más amplia
   *Numeros sin signo en base dos:* ..?

   A=>0=>B
   B=>0=>B
   B=>1=>B

   |---+---+---|
   | TT| 0 | 1 |
   |---+---+---|
   | A | B | - |
   | B | B | B |
   |---+---+---|
   #+END_COMMENT
   
   #+BEGIN_QUOTE   
   M=({A,B},{0,1},{A⇒0⇒B,B⇒0⇒B,B⇒1⇒B},0,{B})
   #+END_QUOTE
** Problema 6 (2019-02-11)
*** Enunciado
   #+BEGIN_QUOTE
   Dado ~Σ={a,b}~ y el LF empiezan y terminan con ~a~:
   
   1. Escriba una *ERX* que lo represente:
   2. Dibuje el *digrafo de un AFN* que lo *reconozca*:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) ERX: ~a|a[ab]*a~

   (2) El dígrafo del AFN sólo sería
   1. un estado inicial ~q0~ que vaya a dos estados (q1 ó q2) para leer ~a~
   2. uno de los estados (q1) es un estado final (ó de aceptación)
   3. otro de los estados (q2)
      - tiene una transición a si mismo para leer ~a~ ó ~b~
      - tiene otra transición a otro estado (q3) que es un estado final para leer ~a~

   Sería un (AFN) Autómata Finito NO Determinístico porque desde el estado inicial (q0) se lee la misma letra ~a~
   cuando se hace la transición a dos estados diferentes.
   
   En la (TT) *Tabla de Transición* veríamos dos estados
   pudiendo ser la *función de transición* de la sig manera ~T(q0, a)={q1,q2}~
   #+END_QUOTE

   #+BEGIN_SRC plantuml :file img/afn21090211.png :exports results
     @startuml
     digraph foo {
       ' cambiamos la dirección: left to right
       rankdir=LR

       "-0" -> "+1" [label=a]

       "-0" -> 2 [label= a]
       2 -> 2 [label= "a,b"]
       2 -> "+3" [label= a]
     }
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:img/afn21090211.png]]

** Problema 7 (2018-12-10)
*** Enunciado
   #+BEGIN_QUOTE
   Sea el LF intersección entre los *LF Constantes enteras decimales sin sufijo de C* y *Expresiones de C*
   1. *Defina formalmente el AF*
   2. Escriba una *RegEx* que lo represente
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Como el *LF Constantes enteras decimales sin sufijo de C* es un (LR),
   y el *LF de Expresiones de C* es un (LIC),
   la intersección entre un (LR) y un (LIC) será el (LF) más simple entre ellos,
   además un (LR) no soporta el *balanceo de paréntesis* que si puede la (GIC) que genera un (LIC)

   Por tanto la intersección entre ambos (LF) será el (LR) de las *constantes enteras decimales sin sufijo*
   
   (1) Como la *definición forma de un AF es* ~A=(conjunto_estados, alfabeto, transiciones, estado_inicial, estados_finales_o_aceptacion)~
   entonces la definición del autómata pedido sería..
   ~A=({q0,q1},{0,1,2,..,9}, {q0->"digitos sin cero"->q1, q1->"digitos"->q1}, q0, {q1})~

   Teniendo
   - un *estado inicial* ~q0~, y un *estado final ó de aceptación* ~q1~
   - como alfabeto los números naturales del 0 al 9

   (2) ERX: ~[1-9][0-9]*~
   empezando con al menos un número del 1 al 9,
   seguido ó no de números del 0 al 9
   #+END_QUOTE
** Problema 8 (2018-07-16)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde la afirmación falsa con respecto a los AF:
   1) Se *formalizan con una 5-upla*
   2) Siempre *tienen una ER equivalente*
   3) Siempre *tienen un único estado inicial*
   4) Sus estados deben tener transiciones salientes para todo símbolo de Σ.
   5) La *función transición puede no estar definida para todo par estado-carácter*
   6) Existe un AF que reconoce la intersección entre los LF Expresiones e Identificadores de C
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero, los (AF) se formalizan en una 5-upla
   La definición formal de un autómata es ~A=(ConjuntoEstados, Alfabeto, EstadoInicial, Estados_Aceptacion_oFinales, FuncionDeTransicion)~

   (2) Verdadero, un (AF) siempre tiene un ER equivalente

   (3) Verdadero, un (AF) tienen un único estado inicial, su definición lo dice así

   (4) FALSO, un (AF) puede tener un estado sin ninguna transición saliente,
   como puede ser un *estado de aceptación/final*

   (5) Verdadero, es el caso anterior

   (6) Verdadero, existe un AF que reconoce la intersección entr el LF expresiones y LF identificadores de C,
   ya que dicha intersección es un (LR) por tanto puede ser reconocido por un (AF).
   
   La intersección es un (LR) porque el (LF) de expresiones es un (LIC) y el LF de identificadores un (LR),
   y la intersección entre ambos es el más simple osea el (LR)
   #+END_QUOTE
* Regex
** [TODO] Problema 1 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba la regex resultante de la intersección entre las *constantes enteras decimales de C* y el
   LF representado por la regex ~[0-9]*|a~
   #+END_QUOTE
** Problema 10 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
    Indique y justifique el valor de verdad de la siguiente afirmación:
    Las *operaciones unión, intersección, y complemento* son parte de las *regex*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   FALSO,
   - la *operación intersección* no forma parte de las *regex*
   - la *operación unión* se logra con el pipe ~|~
   - la *operación complemento* se logra con el ~^~
   #+END_QUOTE
** [TODO] Problema 1 (2020-10-14)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión C: ~s.a[s.i]~
   Puede esta *expresión* considerarse una *regex*? Justifique
   #+END_QUOTE
*** Respuesta
  #+BEGIN_QUOTE
  Si, si se leyera como una regex representaría al (LR) que
 1. empieza con ~s.a~ (s, punto, a)
 2. seguido de ~s~ ó ~.~ ó ~i~ (sólo uno de los caracteres)
  #+END_QUOTE
* [TODO] Automatas
** Problema 1
*** Enunciado
   #+BEGIN_SRC c
     while( EOF != (c=getchar()) ){
       switch(state){
       case INICIAL:
         switch(c){
         case 'a':
           state=INICIAL;
           continue;
           // ...
         }
         // ...
       }
      }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Asuma que el anterior fragmento es parte de la implementación de una *máquina de estado*, responda
   considerando sólo la parte presentada:
   
   1) Indique el *tipo de máquina de estado*. Justifique.
   2) Indique a qué conjunto pertenece ~INICIAL~
   3) Indique a qué conjunto pertenece ~a~
   4) Escriba la o las *transiciones* que representa.
   5) Escriba una *ERX* análoga.
   6) Escriba una *producción* análoga.
   #+END_QUOTE
* [TODO] Algoritmos de Muchnik
** Problema 1 (2018-10-03)
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto a los algoritmos de MUCH2012 volumen 3:
   
   1. Siempre se puede encontrar un AF para una ER.
   2. Siempre se puede encontrar una ER para un AFD.
   3. Siempre se puede encontrar un AFD para un AFN.
   4. Siempre se puede encontrar una ER para una GIC.
   5. Siempre se puede encontrar el AFD mínimo dado un AF.
   #+END_QUOTE

** Problema 2 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca de los *algoritmos de MUCH2012 volumen 3*
   
   1. El complemento de un LR siempre es un LR.
   2. Siempre se puede encontrar una ER para un GR.
   3. Siempre se puede encontrar una GIC para un ER.
   4. Siempre se puede encontrar un AFD para una ER.
   5. El algoritmo de Thompson siempre produce un AFD
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Chequear lo del AFD a ER, y el Algoritmo de Thompson a AFD
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Verdadero

   (2) Verdadero, si existe una GR que genera un LR, también hay un ER para esa GR

   (3) Verdadero, siempre hay una GIC para un ER,
   porque los ER representan LR y estos pueden ser generados por GICs,
   según la jerarquía de chomsky, donde los LRs son los más simples.

   (4) Verdadero, ..

   (5) FALSO
   #+END_QUOTE
** Problema 3 (2018-02-26)
*** Enunciado
   #+BEGIN_QUOTE
   1. V/F Para llegar al AFD mínimo desde una ER es necesario aplicar exactamente tres algoritmos.
   2. V/F  Dadas dos ER, el algoritmo del AFD mínimo es útil para determinar si representan el mismo LF.
   #+END_QUOTE

** Problema 4 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
   Indique la *secuencia de algoritmos* para obtener un *AFD a partir de una ER*
   #+END_QUOTE
*** Respuesta (resolución)
   #+BEGIN_QUOTE
   - Algortimo de Thompson
   - Algoritmo de Clausuras-ε o de Construccíon de Subconjuntos
   - Algoritmo de Minimización
   #+END_QUOTE
