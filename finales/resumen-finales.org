#+TITLE: Resumen Finales
#+BEGIN_COMMENT
Chequear por "sintesis" del compilador
#+END_COMMENT
* [WAITING] BNF de C
** Problema 1 (2019-02-25)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde la afirmación falsa con respecto a BNF:

   1. Es un *meta lenguaje*
   2. Posee *metasímbolos*
   3. Es útil para definir *LP*
   4. Puede describir cualquier *LF tipo 2*
   5. Puede describir el *LF identificadores de C*
   6. Puede describir el *LF expresiones de C semánticamente correctas*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: La BNF no puede describir un LF tipo 1 osea (LSC), no?
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) Verdadero, la BNF es un *meta lenguaje*

   (2) Verdadero, la BNF de C tiene como metasímbolo el ~:~ actúa como el ~->~ para las producciones,
   aunque no posee el ~|~ para las opciones se agregan en una nueva linea

   (3) Verdadero una BNF sirve para definir y documentar un LP

   (4) Verdadero, la BNF puede describir cualquier (LF) tipo 2 osea un (LIC),
   en la BNF de C se describen las *Categorias Léxicas* (TOKENS, son LRs)
   y las *Categorías Sintácticas* del lenguaje y sus restricciones

   (5) Verdadero

   (6) Falso, una BNF podría no representar ciertas restricciones que si podría una (GSC)
   #+END_QUOTE
** [WAITING] [#A] Problema 2 (2018-12-10)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todos los conceptos que se pueden definir con el *BNF del LF Expresiones de C*
   1. *Efecto de lado* de la expresión.
   2. *Precedencia* de los OPERADORES.
   3. *Asociatividad* de los OPERADORES.
   4. *Orden de evaluación* de los OPERANDOS.
   5. Aridad (cantidad de operandos) de los OPERADORES.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Donde está definido el efecto de lado de C? En el MROC?
   Yo creí que era Verdadero, porque.. como estaba la expresión de asignación (?)
   
   <<DUDA>>: La asociatividad y la precedencia, indican el orden de las operaciones (osea la *Secuenciación*) ?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (2) Verdadero, la BNF del LF expresiones de C define la precedencia de los OPERADORES (por cercanía o no al axioma)..
   Más cercano esté del axioma, menos precedencia(prioridad)

   (3) Verdadero, la asociatividad está marcada si la regla/producción es a izquierda ó derecha

   (4) FALSO. La BNF no define el *orden de evaluacion de los OPERANDOS*, sólo de los OPERADORES.

   (5) Verdadero, la regla lo indica explícitamente Ej. si el operador es unario tendrá sólo un operando
   #+END_QUOTE
** [#A] Problema 3 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la gramática
   sentencia-for:
   for ( expresión ; expresión ; expresión ) { sentencia }
   
   1. V/F? Representa las *sentencias-for de C*
   2. Calcule ~Primero(sentencia-for)~
   3. V/F? La ~sentencia-for~ con menor cantidad de TOKENS tiene siete TOKENS.
   4. V/F? El lenguaje que genera puede reconocerse con un *autómata de pila*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO, porque
   1. las tres expresiones que deben ser opcionales
   2. las llaves que indican el comienzo de una sentencia compuesta también debería ser opcional
   3. no contempla que *la primera expresión pueda ser una Declaración*
       
   (2) Al calcular ~Primero(sentencia-for)~ obtenemos ~for~

   (3) FALSO, la sentencia-for con menor cantidad de TOKENs es ~for(;;);~ que tiene 11 TOKENs
   |    |           | Tipo de TOKEN          |
   |----+-----------+------------------------|
   |  1 | for       | palabra reservada      |
   |----+-----------+------------------------|
   |  2 | (         | caracter de puntuación |
   |----+-----------+------------------------|
   |  3 | expresion | *al menos 1 token*     |
   |----+-----------+------------------------|
   |  4 | ;         | caracter de puntuación |
   |----+-----------+------------------------|
   |  5 | expresion | *al menos 1 token*     |
   |----+-----------+------------------------|
   |  6 | ;         | caracter de puntuación |
   |----+-----------+------------------------|
   |  7 | expresion | *al menos 1 token*     |
   |----+-----------+------------------------|
   |  8 | )         | caracter de puntuación |
   |----+-----------+------------------------|
   |  9 | {         | caracter de puntuación |
   |----+-----------+------------------------|
   | 10 | sentencia | *al menos 1 token*     |
   |----+-----------+------------------------|
   | 11 | }         | caracter de puntuación |
   |----+-----------+------------------------|

   (4) Verdadero, porque al ser una *sentencia iteración* pertenece a una de las 3 *categorías sintácticas*
   y éstas (LICs) que son generadas por (GICs) y pueden ser reconocidas por un (AP) Automáta de Pila
   #+END_QUOTE
* Evaluar expresiones
** Problema 1 (2020-12-14)
*** Enunciado
   #+BEGIN_SRC C
     int f(int c){
       int d = c-7;
       printf("%d",d);
       return d;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior función:
   Indicar de las siguientes expresiones su valor y su salida por ~stdout~
   1) ~f(7)-f(7)~
   2) ~f(8) || f(7)~
   3) ~f(7) || f(8)~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   El valor de retorno y la salida por stdout de las expresiones dadas serian
   (1) para ~f(7)-f(7)~
    - el valor de retorno es ~0~ (al evaluar la expresión, realiza una operación arimética 7-7 = 0)
    - la salida por stdout es ~00~ (al evaluar la expresión, invoca dos veces a f pasandole 7 como parámetro)
        
   (2) para ~f(8)||f(7)~
    - el retorno sería ~1~ (al evaluar la exp, y realiza una operación lógica que finaliza luego evalúar la primera subexpresion f(8) que la hace verdadera)
    - la salida ~1~ (como sólo evalúa la primera subexpresión osea f(8), se invoca sólo una vez a f pasandole 8 como parámetro)
        
   (3) para ~f(7)||f(8)~
    - el retorno sería ~1~ (al evaluar la exp. el operando de la derecha hace verdadera la expresión, por tanto devuelve 1)
    - la salida ~01~ (como el operando de la izquierda es falso, evalúa el de la derecha, por tanto se invoca dos veces a f y hace dos printf)
   #+END_QUOTE
** Problema 2 (2020-12-09)
*** Enunciado
   #+BEGIN_SRC C
     int f(int c){
       int d = c-'A';
       printf("%d",d);
       return d;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior función:
   
   Analice las siguientes expresiones. Indique su valor y su salida por stdout, si la salida no se puede
   determinar, indique "Indeterminada":
   #+END_QUOTE

   | Expresión            | Valor | Salida por stdout o "Indeterminada" |
   |----------------------+-------+-------------------------------------|
   | f('A')-f('A')        |       |                                     |
   | f('B')llf('A')       |       |                                     |
   | f('A')llf('B')       |       |                                     |
   | f('A')?f('B'):f('C') |       |                                     |
*** Respuesta
   #+BEGIN_QUOTE
   Al evaluar la exp ~f('A')-f('A')~
   - El valor de retorno es ~0~ (/realiza la operación arimética 0-0 = 0/)
   - La salida por stdout es ~00~ (/se invoca dos veces la función f, por tanto se ejecuta dos veces el printf haciendo 'A'-'A'/)
   
   Al evaluar la exp ~f('B')||f('A')~
   - El valor de retorno es ~1~ (/sólo evalúa la primera subexpresion f('B') hace verdadera a la expresión, y no se sigue evaluando el operando derecho/)
   - La salida por stdout es ~1~ (/como sólo evalúa el operando izquierdo, se ejecuta una única vez el printf que hace 'B'-'A' = 1/)
   
   Al evaluar la exp ~f('A')||f('B')~
   - El valor de retorno es ~1~
   - La salida por stdout es ~01~ (/como el operando izquierdo no hace verdadera la expresión OR, evalúa el operando derecho, por tanto se invoca dos veces f y también el printf/)
   
   Al evaluar la exp ~f('A')?f('B'):f('C')~
   - El valor de retorno es ~2~ (/como la condición del operador ternario es falsa, se invoca f('C') y 'C'-'A' = 2/)
   - La salida por stdout es ~02~ (/porque evalúa la exp de la condicion que es f('A') y luego f('C'), por tanto invoca a la función f dos veces y también printf/)
   #+END_QUOTE

   #+BEGIN_QUOTE
   La evaluación de la expresión ~f('A')-f('A')~ es de Izq. a Derecha porque
    - la asociatividad del operador aritmético ~-~ es de Izq. a Der.
    - no hay otras subexpresiones con operadores de mayor precedencia (Ej. el operador * de multiplicación)
    - tampoco se usaron paréntesis para alterar la precedencia con otras subexpresiones
     
   La evaluación de la expresión ~f('B')||f('A')~ es de Izq. a Derecha porque
   - La asociatividad del operador lógico OR ~exp1||exp2~ es de Izq. a Der. (tanto AND como OR)

   La evaluación de la expresión ~f('A')?f('B'):f('C')~ es de Izq. a Derecha porque
   - La asociatividad del operador ternario ~exp1?exp2:exp3~ es de Izq a Der.
   #+END_QUOTE
** Problema 3 (2019-07-015)
*** Enunciado
   #+BEGIN_QUOTE
   Sea la función ~int f(int a,int b){return&a==&b?b:a;}~, calcule ~f(x,y)~ siendo ~x~ e ~y~ *expresiones de tipo int*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   El resultado es valor ~x~ porque ~&a==&b ? b : a~ porque
   1. Verifica si dirección de memoria de ambos parámetros es la misma
   2. El resultado de ~&a==&b~ será ~0~ (false) porque no se cumple la condición
   3. El operador ternario ~exp1:exp2?exp3~ evalúa la expresion3 porque el valor de la expresion1 es 0 (false)
   #+END_QUOTE
** Problema 4 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
    Dada la *declaración* ~int x=0,a=2;~ evalúe cada expresión, indique su valor y el valor resultante
    de la variable ~a~.
    1) ~x && ++a~
    2) ~x<'a' ? x+'a' : a+=40~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
    (1) De la expresión ~x && ++a~
    - Su valor es ~0~ (porque al evaluarla, detecta que el primer operando es ~0~ por tanto no sigue evaluando) 
    - El valor de ~a~ es ~2~ (porque como sólo evalúa el valor del primer operando que no satisface la condición, no se evalúa la segunda expresión que incrementa el valor de ~a~)
       
    (2) ~x<'a' ? x+'a' : a+=40~
    - Su valor es ~'a'~ porque se cumple la condición de que ~x~ es menor que el valor ~'a'~ (según la tabla ascii)
    - El valor de ~a~ se mantiene en ~2~
   #+END_QUOTE
* Nivel Léxico + Sintactico + Semántico
** Conceptos básicos
*** Constructos de un (LP)
   - Los *constructos* ó *constructos sintácticos* se refieren a las *restricciones sintácticas*
   - Un constructo es una *secuencia de tokens* que forman una *categoría sintáctica* (Ej. expresiones, sentencias, declaraciones)
   - Los TOKENS son (LR)
*** Analizador Léxico (Scanner)
   - El Scanner usa ~getchar()~ para leer caracter a caracter de una secuencia de caracteres
   - El Scanner usa ~ungetc()~ para ...
*** Expresión
   - Una expresión es una secuencia de operandos y operadores que producen un valor y pueden producir efecto de lado
*** Declaración
   - Es una *sentencia* donde se específica atributos para darles un significado (Ej. tipo de dato) a uno ó varios identificadores.
   - Pasa a ser *definición* si esta implíca reservar memoria
   - Cuando declaramos una variable (/objeto/) también la estamos definiendo a menos que usemos ~extern tipoDato identificador~ ahí sólo declaramos
*** Punctuator - Caracter de Puntuación
   #+BEGIN_QUOTE
   *Según la BNF de C*
   
   punctuator -> uno de
     [ ] ( ) { } . -> ++ -- & * + -  ̃ !
     / % << >> < > <= >= == != ˆ | && ||
     = *= /= %= += -= <<= >>= &= ˆ= |=
     ? : ; ... , # ##
   #+END_QUOTE
*** Operador Vs Caracter de Puntuación
   |----------+---------------------------------------------------------+------------------------------------------|
   | Caracter | Operador                                                | Caracter de Puntuación                   |
   |----------+---------------------------------------------------------+------------------------------------------|
   | ','      | Separador de expresiones (/Ej. en una sentencia/)       | Separar parámetros en una función        |
   |----------+---------------------------------------------------------+------------------------------------------|
   | '(', ')' | Invocar una función                                     | Declarar ó definir una función           |
   |          | Agrupar expresiones                                     |                                          |
   |          | Conversión de datos explícita (typecasting)             |                                          |
   |          | Modificar precedencia de los *OPERADORES*               |                                          |
   |          | (Ej. al evaluar la expresión ~(1+1)*2 != 1+1*2~)        |                                          |
   |----------+---------------------------------------------------------+------------------------------------------|
   | '[', ']' | Acceder a un elemento de un array                       | Declarar una variable del tipo array     |
   |----------+---------------------------------------------------------+------------------------------------------|
   | '='      | Asignar un valor a una variable                         | Inicializar una variable                 |
   |          | (que ya estaba declarada, osea fuera de la declaración) | Definir una constante enumeración        |
   |          |                                                         | (Ej. ~enum mes{Enero=1, Febrero=2,...}~) |
   |----------+---------------------------------------------------------+------------------------------------------|
** Problema 1 (2021-06-23)
*** Enunciado
   #+BEGIN_SRC c
     while( EOF != (c=getchar()) ){
       switch(state){
       case INICIAL:
         switch(c){
         case 'a':
           state=INICIAL;
           continue;
           // ...
         }
         // ...
       }
      }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice el anterior fragmento de un programa C, asuma que se incluyó el header correspondiente:   
   
   Analice Léxica, Sintáctica, y Semánticamente el anterior fragmento:
   1. Indique cuántos *tokens* tiene la *expresión* que controla el while.
   2. Enumere las *operaciones que tiene esa expresión*
   3. Indique los *efectos de lado de la expresión*
   4. Declare ~state~ e ~INICIAL~
   5. Declare la variable ~c~. Justifique el tipo.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Tokens:
   1) ~!=~ <- operador desigualdad
   2) ~(~ <- caracter puntuación
   3) ~c~ <- identificador
   4) ~=~ <- operador de asignación
   5) ~getchar~ <- palabra reservada
   6) ~()~ -> operador invocar función
   7) ~)~ <- caracter de puntuación

   Cant. de operaciones:
   - son tres el ~!=~, ~=~ y ~()~

   Los efectos de lado:
   1) se asigna el retorno de ~getchar()~ que recibe la entrada del stdin, y se asigna como valor a ~c~ con el operador ~=~
   #+END_QUOTE

   #+BEGIN_SRC C
     // Alternativa #1 sin typedef, en una sola declaración
     // enum {INICIAL, ...} state;

     // Alternativa #2 con typedef, se puede reciclar para varias declaraciones
     typedef enum {INICIAL, ...} ESTADO;
     ESTADO state;

     state = INICIAL;

     // debe ser numérico porque el primer valor de un enum inicia en 0
     // (apesar de ser entero, podemos asignar c='a')
     int c;
   #+END_SRC
** Problema 2 (2021-08-04)
*** Enunciado
   #+BEGIN_SRC C
     function calcular(){
       var x;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice el anterior fragmento, siguiendo las reglas de C:
   
   1) ¿En qué cambiaría el resultado del *análisis léxico* si el anterior fragmento se escribe en solo una línea?
   2) ¿Cuántos *errores léxicos* tiene?
   3) ¿Cuántos *tokens keyword* tiene?
   4) Independientemente del contexto, ¿es *sintácticamente correcto*? ¿Por qué?
   5) En función a su respuesta anterior, ¿es *semánticamente correcto*? ¿Por qué?
   6) Introduzca al contexto del anterior fragmento *declaraciones typedef* que hagan cambiar su respuesta al punto 4.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   1) Ninguno, el Scanner lee la secuencia de caracteres
   2) NO tiene errores léxicos, habría error si el Scanner detecta en el fragmento un lexema que no es un TOKEN válido (categoría léxica)
   3) NO tiene ningún token keyword
   4) Tiene errores sintácticos porque no se puede derivar de la BNF de C
      - ~function~ no es especificador de tipo válido para definir una función
      - ~var~ tampoco es un espcificador de tipo válido para declarar una variable
   5) No es semanticamente correcto, al no ser sintacticamente correcto
   6) ~typedef int function, var;~
   #+END_QUOTE
** Problema 3 (2021-09-24)
*** Enunciado
   #+BEGIN_QUOTE
    Escriba el *prototipo en C* de la *función transición de un AFD*. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     typedef struct { /* ... */ } ESTADO;

     // - Hace una transición a un Estado, y lee un caracter
     // - Retorna el siguiente estado
     ESTADO transicion(ESTADO estado, char caracterLeido);
   #+END_SRC
** Problema 4 (2021-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el siguiente fragmento: ~a<b<c~
   
   1. Indique la *secuencia de caracteres* devueltos por ~ungetc~ durante el *Análisis Léxico*
   2. Indique la asociatividad mediante *paréntesis redundantes*.
   3. Para cada situación pedida a continuación escriba una declaración que haga…
      - … *Semánticamente inválido* al fragmento.
      - … cero al valor resultante sin usar el tipo int.
      - … uno al valor resultante sin usar el tipo int.
      
   4. Escriba una *expresión* que evalúe si un valor b está dentro del intervalo abierto ~(a, c)~. Agregue
   la *declaración* que haga *semánticamente válida* a esa expresión, no es necesario *inicializar*
   
   5. Presente un contexto *semántico* donde la anterior expresión, aunque *semánticamente correcta*,
   no pueda ser utilizada. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Durante el *analisis léxico* la secuencia de caracteres devueltos por ~ungetc~ es ~<b<c~
   1) devuelve ~<~ <-- porque al leer con ~getchar()~ el caracter ~a~ sabe que es identificador y el ~<~ no pertenecía a ese TOKEN
   2) devuelve ~b~ <-- porque al leer con ~getchar()~ el caracter ~<~ sabe que es un operador y ~b~ no pertenecía a ese TOKEN
   3) devuelve ~<~ <-- porque al leer ~b~ sabe que es un identificador y ~<~ no pertenecía a ese TOKEN
   4) devuelve ~c~ <-- porque al leer ~<~ sabe que es un operador y que ~c~ no pertenecía a ese TOKEN

   Si remarcamos la asociatividad de ~a<b<c~ quedaría ~(a<b)<c~
   porque la asociatividad del operador relacional ~<~ es de izquierda a derecha
   según la sintáxis de C (ésta especifica la asociatividad/precedencia de los operadores)
   #+END_QUOTE

   #+BEGIN_SRC C
     // - Esto haría semánticamente incorrecto la expresion "a<b<c" porque
     // los structs no se pueden comparar con el operador <
     struct { /*...*/ } a,b,c;

     // La siguiente declaración, e inicialización de las variables
     // hará que a<b<c retorne 0
     // 1) 'a' < 'a' < 0
     // 2) 0 < 0
     // 3) 0
     char a = 'a', b = 'a' , c = 0;

     // alternativa #2 para que a<b<c devuelva 0
     // 1) 0<0<-1
     // 2) 0<-1
     // 3) 0
     unsigned a = 0, b = 0, c = -1;

     // La siguientes declaraciones, e inicialización de las variables
     // hará que a<b<c retorne 1
     unsigned a, b, c;
     a = b = c = 1;

     char a, b, c;
     a = b = c = 'a';

     // expresiones que evalúan si b está entre (a,c)
     a < b && b < c;

     a < b && c > b;

     b > a && b < c;

     // las expresiones de las últimas 3 sentencias anteriores no podrían
     // ser utilizadas en los siguientes contextos

     // lo usamos para asignarlo a un valor que no es lvalue (Ej. una constante entera)
     42 = a < b && b < c;

     // ó al revés, donde éste no es un lvalue
     a < b && b < c = 42;
   #+END_SRC
** Problema 5 (2021-03-10)
*** Enunciado
   #+BEGIN_SRC C
     int f(int x, int y){
       int z=1;
       for(int i=1;i<=y;++i)
         z*=x;
       return z;
     }
   #+END_SRC

   #+BEGIN_QUOTE
   Dada la definición de ~f~
   
   *Analice Léxicamente*
   1. Indique la cantidad de *tokens* de la tercera expresión de la *sentencia* ~for~
   2. Indique la cantidad de veces que el símbolo ~=~ es un *lexem*. Justifique.
      
   *Analice Sintácticamente:*
   1. Indique si faltan llaves para que ~f~ sea *sintácticamente correcta*. Justifique.
   2. Indique la cantidad de *declaraciones* en la *sentencia compuesta*
   3. Indique la cantidad de *expresiones completas* en la definición
   
   *Analice Semánticamente:*
   1. Indique si la tercera expresión del ~for~ debiera ser ~i++~. Justifique.
   2. Considerando como único contexto la definición dada, escriba una *declaración* que use ~f~ y sea *semánticamente correcta*
   3. Indique el alcance de ~f~ y ~z~
   4. Indique los valores de ~x~ e ~y~ que hacen que la función retorne

   *Analice pragmáticamente* 
   Analice la función y luego escriba un nuevo *prototipo* para ~f~ que sea
   superador, es decir que sea mejor según sus propios criterios. Puede cambiar el *identificador de la función*
   y los tipos de datos. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   *Análisis Léxico*
   La expresión ~++i~ tiene 2 *tokens*
   1. ~++~ (operador incremento como prefijo)
   2. ~i~ (identificador)

   El símbolo ~=~ es un *lexema* en 2 ocasiones
   1. en ~z=1~
   2. en ~i=1~
   3. Pero no es lexema en ~i<=y~, ~z*=x~ porque representan otros operadores
   #+END_QUOTE
   
   #+BEGIN_QUOTE
   *Análisis Sintáctico*
   ~f~ no necesita de llaves adicionales, es sintácticamente correcta porque declara los parámetros
   y define su cuerpo con la sentencia compuesta que está delimitada por las llaves

   la *sentencia compuesta* que es el cuerpo de ~f~ tiene 2 declaraciones
   1. ~int z=1~
   2. ~int i=0~

   (/una expresión es una secuencia de operandos y operadores que producen un valor y pueden producir efecto de lado/)
   las *expresiones completas* del cuerpo de la función ~f~ son
   1. ~int z=1~
   2. ~int i=1~
   3. ~i<=y~
   4. ~++i~
   5. ~z*=x~
   6. ~return z~
   #+END_QUOTE
      
   #+BEGIN_QUOTE
   *Análisis Semántico*

   Es indiferente si la 3º expresión del ~for~ tiene al operador de incremento ~++~ como prefijo ó sufijo sobre ~i~
   distinto hubiera sido si.. si hubiera usado en alguna expresión como ~a=i++~ ó ~a=++i~
   en ~a=i++~ se genera efecto en ~i~ luego de evaluar la expresión ~a=i~,
   mientras que ~a=++i~ se genera efecto sobre ~i~ previo a evaluar ~a=i~

   La declaración ~int x = f(0,0)~ sería semánticamente correcta

   El alcance/scope de ~f~ es la (UT) Unidad de traducción (etapa que se integra el archivo fuente .c y los archivos cabecera .h),
   el alcance de ~z~ es dentro del cuerpo de la función ~f~ (sentencia compuesta delimitada por las llaves { ... })

   Cualquiera sea el valor de ~x~ e ~y~, la función ~f~ retornará un entero
   #+END_QUOTE

   #+BEGIN_QUOTE
   *Análisis Pragmático*
   ~int numeroElevadoAExponente(int numero, int exponente);~
   #+END_QUOTE
** [WAITING] Problema 6 (2021-02-24)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión, que es sintácticamente correcta, y luego responda:
   ~f(g(x))~
   
   1. Indique el primer *token* resultante del *análisis léxico*
   2. Declare un *tipo de dato* capaz de _contener toda la información_ necesaria para representar
      cualquiera de los *tokens* de la expresión.
   3. Enumere en orden los caracteres retornados por ~ungetc~
   4. Escriba una *declaración* que haga a la expresión *semánticamente correcta*
   5. ¿Es posible declarar que ~g~ retorne un *arreglo*? ¿Por qué?
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: En la resolución dice ~(,(,)~ y yo puse ~(,g,(,x,)~
   porque.. después de ~f(~ podría haber sido el ~f()~ osea el operador ()
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) ~f~ identificador

   (3) La secuencia de caracteres retornados por ~ungetc~ sería
   1. ~(~ --> porque el anterior era ~f~ (identificador) y ~(~ no pertenece a ese TOKEN
   2. ~(~ --> porque el anterior era ~g~ (identificador) y ~(~ no pertenece a ese TOKEN
   3. ~)~ --> porque el anterior era ~x~ idem que los dos anteriores
   
   (4) Una posible declaración sería ~int f(int), g(int);~

   (5) Una función no puede retornar un arreglo, pero si puede retornar un puntero a la primera dirección
   de un bloque de memoria que fue reservada para el arreglo, apuntando a su primer elemento.
   #+END_QUOTE

   #+BEGIN_SRC C
     typedef enum {IDENTIFICADOR, OPERADOR, PUNCTUATOR/*...*/} TIPO_TOKEN;
     typedef struct {TIPO_TOKEN tipo, char* valor} TOKEN;

     // Ej.
     TOKEN apertura_parentesis;
     apertura_parentesis.tipo = PUNCTUATOR;
     apertura_parentesis.valor = "(";

     TOKEN cierre_parentesis;
     cierre_parentesis.tipo = PUNCTUATOR;
     cierre_parentesis.valor = ")";
   #+END_SRC
** [WAITING] Problema 7 (2020-12-21)
*** Enunciado
   #+BEGIN_SRC C
   char user[1000];
   assert(0==strcmp("cjkent",CopyUser(user,"cjkent@dailyplanet.com")));
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice el anterior fragmento C que prueba una función
   
   1. Indique la cantidad de *tokens* en la declaración del fragmento anterior.
   2. Indique cuantos *literales y constantes* hay en la sentencia del fragmento anterior.
   3. Escriba una *expresión* que use user y que sea *semánticamente incorrecta*. Justifique.
   4. Indique el *prototipo* de CopyUser.
   5. Escriba la *definición* de CopyUser
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>:
   la resolución no consideró la "declaración" como una "sentencia expresión", por que?

   <sentencia> ->
     <sentencia expresión> |
     <sentencia compuesta> |
     <sentencia de selección> |
     <sentencia de iteración> |
     <sentencia etiquetada> |
     <sentencia de salto>
   
   <sentencia expresión> ->
     <expresión>? ;

   <nombre de tipo> está descripto más adelante, en la secciónDeclaraciones.
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Una declaración es una sentencia donde se específica atributos para darles un significado (Ej. tipo de dato) a uno ó varios identificadores.
   Por tanto existe sólo una declaración en ese fragmento y es ~char user[1000]~ que tiene 5 tokens
   1. ~char~ (palabra reservada)
   2. ~user~ (identificador)
   3. ~[~ (caractacter de puntuación)
   4. ~1000~ (constante numérica entera)
   5. ~]~ (caractacter de puntuación)
   6. ~;~ (caracter de puntuación) <---

   (2) La *sentencia expresión* de la segunda linea tiene 1 constante, y 2 literales cadena
   1. ~0~ (constante entera)
   2. ~"cjkent"~ (literal cadena)
   3. ~"cjkent@dailyplanet.com"~ (literal cadena)
   #+END_QUOTE

   #+BEGIN_SRC C
     // las siguientes sentencias tienen expresiones que son semanticamente incorrectas

     user++; // el operando 'user' no es lvalue válido para el operador de incremento ++

     42 = user[0]; // la constante 42 no es un operando lvalue válido para el operador de asignación

     user[0.1]; // la constante real 0.1 no es un operando lvalue válido para el operador []

     // --------------------------

     char* CopyUser(char*, const char*);

     char* CopyUser(char* usuario, const char* email){
       // aux apuntará a la primera dirección del bloque de memoria reservado para usuario
       char* aux = usuario;

       // - nos desplazamos por ambas cadenas como punteros, y los desreferenciamos para la asignación
       // - el centinela es el @
       while(*email != '@') *aux++ = *email++;
       // agregamos el caracter nulo, que representa fin de cadena
       ,*aux= '\0';

        // alternativa al puntero aux
        // int i; for(i =0; email[i] != '@'; i++) cadena[i] = email[i];
        // cadena[i] = '\0';
       return usuario;
     }


   #+END_SRC
** Problema 8 (2020-12-14)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~wiehl()--x;~   
   
   1. Enumere en orden los caracteres que son devueltos al flujo mediante ~ungetc~ durante el *Análisis Léxico*:
   2. Realice un *análisis de sintáctico* de izquierda a derecha y justifique si es una *sentencia*
      *sintácticamente correcta*. Si hay *error sintáctico*, reescríbala con el error encontrado corregido:
   3. Escriba una *declaración* que haga la sentencia anterior, ya se a la original o la corregida,
   *semánticamente correcta*:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Los caracteres devueltos mediante el ~ungetc~ por el Scanner son
   1. ~(~ porque cuando estaba leyendo la cadena ~wiehl~ (identificador) detectó que ~(~ no pertenece a ese TOKEN
   2. ~;~ porque cuando estaba lyendo la ~x~ (identificador) detectó que el ~;~ no pertenece a ese TOKEN

   (2) Tiene error sintáctico, el operador ~--~ que está como sufijo, necesita un operando que sea lvalue y ~wiehl()~ no lo es.
   1. Lee la cadena ~wiehl()~ que es derivable de la BNF de C (/la invocación de una función/)
   2. Cuando lee ~wiehl()++~ detecta que no se puede derivar, porque no esperaba un operador de incremento
   Posible soluciones serían, suponiendo que son valores numericos
   1. ~wiehl()*--x;~ (/una sentencia expresión, con una expresión de dos valores multplicandose, donde el 2do operando de decrementa previo a evaluar la multiplicación/)
   2. ~wiehl(),--x;~ (/dos expresiones en una sentencia expresión, separadas por la coma como operador/)
   3. ~wiehl();--x;~ (/dos sentencias expresión usando el punto y coma como operador para indicar el fin de cada expresión/)

   (3) Una posible declaración sería ~int wiehl(), x;~
   #+END_QUOTE
** [WAITING] Problema 9 (2020-12-14)
*** Enunciado
   #+BEGIN_SRC C
     int f(int c){
       int d = c-7;
       printf("%d",d);
       return d;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior función:
   
   1. Analice sintácticamente el cuerpo de la función e indique:
      - Cantidad de *sentencias*
      - Cantidad de *expresiones completas*
      - Cantidad de *declaraciones*
   2. ¿Explique para qué usaría la keyword ~union~ en la *construcción de scanners*?
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: habia considerado la declaración ~int d = c-7;~ como sentencia expresión,
   pero la resolución indicaba que había sólo 2, al derivar de la gramatica de la BNF
   ésta no resulta como sentencia expresión entonces?

   <<DUDA>>: La resolución dice que hay 3 expresiones completas, cuales son? y cuales serian no completas(?)
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Cant. de sentencias: 2
   1. ~printf(...);~ (sentencia expresión)
   2. ~return d;~ (sentencia expresión)

   Cant. de declaraciones: 1
   1. ~int d = c-7;~

   (2) Podría usar la palabra reservada ~union~ para darle un significado (valor semántico) a los *TOKENS*,
   de la misma forma como usaría un ~struct~
   #+END_QUOTE

   #+BEGIN_SRC C
     typedef enum {IDENTIFICADOR, OPERADOR, ...} TIPO_TOKEN;
     typedef union{ TIPO_TOKEN tipo; char* valor; } TOKEN;
   #+END_SRC
** Problema 10 (2020-10-14)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión C: ~s.a[s.i]~
   
   1. Enumere en orden los caracteres devueltos por ~ungetc~ durante el *análisis léxico*
   2. Escriba una *declaración* para que la *expresión* sea del *tipo puntero a char*
   3. Escriba una *declaración que haga semánticamente incorrecta* a la expresión.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) el Scanner (analizador léxico) devuelve los sig. caracteres con ~ungetc~
   1. ~.~ (porque luego de leer con getchar ~s~ (identificador) detecta que ~.~ no pertenece a ese TOKEN, then retrocede
   2. ~[~ (luego de leer ~a~ (identificador) detecta que ~[~ no pertenece a esa Categoria Léxica, then retrocede
   3. ~.~ idem cuando lee ~s~
   4. ~]~ idem cuando lee ~i~
   #+END_QUOTE

   #+BEGIN_SRC c
     struct {
       char* a; // puntero a char (requerimiento)
       int i; // evitamos error semántico, será valido para el operador [] en a[s.i]
     }s;

     // - el operador exp1[exp2] para acceder a un elemento de un array,
     // espera como operando exp2 un entero, caso contrario arrojará error (semántico)
     struct {
       char* a;
       double i; // esto la haría la expresión s.a[s.i] semánticamente incorrecta
     }s;
   #+END_SRC
** Problema 11 (2020-10-13)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión C: ~lim( x --> 0 )~
   
   1. Si es *sintácticamente correcta* entonces escriba una *declaración* que lo haga también
      *semánticamente correcto*, si no, justifique.
   2. ¿La *expresión* calcula el límite de una función cuando x tiende a 0? Justifique.
   3. ¿Agregar o quitar un espacio en algún lugar podría cambiar la *cantidad de lexemas*?
   Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Si la función ~lim~  recibe por parámetro un entero, entonces podría ser *sintacticamente correcta*
   Una posible declaración sería ~int x, lim(int);~
   
   (2) Falso, la expresión no calcula el limite, porque no existe el operador ~-->~
   en la expresión dada son dos operadores, el decremental ~--~ y el relacional ~>~

   (3) Si, depende en donde coloquemos los espacios, las únicas que varían la cantidad, no sin sintácticamente correctas
   1. Si agregamos un espacio entre ~--~ y ~>~ no habria diferencia, seguiría habiendo 7 lexemas {lim,(x,--,>,0,)}
   2. Otras posibilidades aunque con errores sintácticos (porque no se podrían derivar de la BNF de C) serían
      - Si la dejamos como ~lim(x - - > 0)~ habría 8 lexemas {lim, x,-,-,>,0}
      - Si la dejamos como ~lim(x - -> 0)~ habría 8 lexemas {lim, x,-,->,0}
      - Si agregamos espacio entre alguno de los caracteres del identificador ~lim~ tendriamos más identificadores, por tanto más lexemas
   #+END_QUOTE
** [WAITING] [#A] Problema 12 (2020-03-03)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el fragmento: ~0xF+F0x+0L+L0~
   
   1. Indique cuantos *tokens* tiene:
   2. Indique cuantos *tipos de tokens o categorías léxicas* tiene. Justifique:
   3. Indique cuantas invocaciones a ~getchar~ se necesitan para su análisis:
   4. Indique cuantas invocaciones a ~ungetc~ se necesitan para su análisis:
   5. Indique la *categoría sintáctica* a la que pertenece el fragmento (Declaración, Expresión, Sentencia o Error sintáctico)
   6. Escriba la o las *declaraciones* necesarias para que sea un fragmento *semánticamente correcto*
      con tipo ~double~ y valor 15.
   7. Escriba la o las *declaraciones* necesarias para que sea un fragmento *semánticamente incorrecto*
      por *error de tipo*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>:
   El scanner para leer ~0xF+F0x+0L+L0~ hace 7 invocaciones a ungetc según la resolución, y yo veo 6
   el 7 será el EOF?
   #+END_COMMENT

   #+BEGIN_QUOTE
   (3) (4) el scanner hace 20 invocaciones a ~getchar~ (cant. de invocaciones nos da 4+2+4+2+3+2+2 = 20)
   - una invocación por cada caracter leído,
   - dos invocaciones a ~getchar~
     - si el siguiente caracter no pertenece al TOKEN del anterior
     - hace ~ungetc~ para retroceder y volver a leer ese caracter
   
   La secuencia de lectura para ~0xF+F0x+0L+L0~ sería
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | Secuencia de caracteres leídos | Cant. lecturas | Caracter devuelto por ~ungetc~ | Motivo para invocar a ~ungetc~                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | 0xF+                           |              4 | +                              | invoca a ~ungetc~ porque ~+~ no pertenece al tipo de TOKEN identificadores |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | +F                             |              2 | F                              | invoca a ~ungetc~ porque ~F~ no pertenece al tipo de TOKEN operadores      |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | F0x+                           |              4 | +                              | ungetc por ~+~                                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | +0                             |              2 | 0                              | ungetc por ~0~                                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | 0L+                            |              3 | +                              | ungetc por ~+~                                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | +L                             |              2 | L                              | ungetc por ~L~                                                             |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   | L0                             |              2 |                                |                                                                            |
   |--------------------------------+----------------+--------------------------------+----------------------------------------------------------------------------|
   
   (1) Tiene 7 tokens (categorías léxicas)
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | Secuencia de Caracteres | Tipo de Token (ó Categoría Léxica a la que pertenece)                                                            |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~0xF~                   | Constante entera hexadecimal                                                                                     |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~+~                     | Operador                                                                                                         |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~F0x~                   | Identificador (/empiezan con una letra o guión bajo, seguido ó no de numeros,letras,guiones en cualquier orden/) |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~+~                     | Operador                                                                                                         |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~0L~                    | Constante entera octal                                                                                           |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~+~                     | Operador                                                                                                         |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|
   | ~L0~                    | Identificado (/por empezar con una letra/)                                                                       |
   |-------------------------+------------------------------------------------------------------------------------------------------------------|

      
   (2) tiene 3 tipos de tokens (identificador, constante entera, operador)

   (5) el fragmento ~0xF+F0x+0L+L0~ pertenece a la ctegoria sintáctica Expresión,
   ya que una expresión es una secuencia de operandos y operadores,
   en este caso los operadores son sólo tres ~+~
   y los operandos son identificadores (F0, L0) y constantes enteras (0xF, 0L)
   #+END_QUOTE

   #+BEGIN_SRC C
     // - La siguiente declaración hace a la expresión semánticamente correcta,
     // porque F0x y L0 son identificadores (por empezar con una letra)
     // - Inicializamos en 0, para que el resultado sea 15 (requerimiento)
     double F0x=0, L0=0;

     // 15 + 0 + 0 + 0, resultado = 15
     0xF+F0x+0L+L0;

     // - La siguiente declaración hace a la expresión anterior
     // semanticamente incorrecta, ya que el tipo struct no es un operando
     // válido para usar con el operador '+'
     struct {} F0x, L0;
   #+END_SRC
** [WAITING] [#B] Problema 13 (2020-02-18)
*** Enunciado
   #+BEGIN_SRC C
     {
       int f; // renglón #1
       f+=42; // renglón #2
       f(); // renglón #3
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Dada la anterior *sentencia compuesta*
   
   1. *Analice léxicamente* los tres renglones. Indique cuantos *tokens* hay:
   2. *Analice sintáctimente* cada renglón y clasifique como Error sintáctico, Expresión, Sentencia, ó Declaración.
   3. *Analice semánticamente* la *sentencia compuesta*. Indique si hay un *error semántico* o no y
      justifique. En el caso de haber error semántico indique en qué renglón lo detecta el compilador.
   4. *Analice pragmáticamente* el renglón #2 en el contexto del renglón #1. Indique si hay un error
   pragmático o no. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: El scanner siempre detecta a los caracteres ~(~ y ~)~ como punctuator?,
   en algún momento sabe que son operador ~()~ ?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Cant. de TOKENS: 11
    1. ~int~ (palabra reservada)
    2. ~f~ (identificador)
    3. ~;~ (caracter de puntuación)
    4. ~f~ (identificador)
    5. ~+=~ (operador)
    6. ~42~ (constante entera decimal)
    7. ~;~ (caracter de puntuación)
    8. ~f~ (identificador)
    9. ~(~ (caracter de puntuación)
    10. ~)~ (caracter de puntuación)
    11. ~;~ (caracter de puntuación)

   (2) Usamos de referencia que en Categorías Sintácticas están las Declaraciones, Expresiones, Sentencias
   - Renglon 1: declaración
   - Renglon 2: sentencia expresión
   - Renglon 3: sentencia expresión

   (3) Hay error semántico en el renglon 3, al evaluar la expresión ~f()~,
   ya que el identificador ~f~ se usó previamente para declarar una variable,
   y el operador ~()~ para invocar funciones sólo puede tener como operando el identificador de una función,
   no el de una variable.
   
   (4) En la declaración ~int f~, al no inicializar ~f~ y hacer ~f+=42~,
   lo que hará será sumarle 42 a un valor basura que tiene por defecto ~f~
   #+END_QUOTE
** [WAITING] [#A] Problema 14  (2020-02-12)
*** Enunciado
   #+BEGIN_SRC C
     int f(int x){
       if(0)return 1;
       return 42;
     }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Analice la anterior función:
   
   1. Dentro del *cuerpo de la función*, sin contar las llaves:
      1. Indique cuántas *expresiones* hay
      2. Indique en total cuantas *sentencias* y *subsentencias* hay
      3. Indique cuántas *declaraciones* hay
      4. Indique cuántas invocaciones a ~ungetc~ son necesarias para *analizar léxicamente* el cuerpo de la función
      5. Indique cuantas invocaciones a ~getchar~ son necesarias para detectar el *lexema* ~42~
   2. Escriba y justifique un posible error pragmático (i.e., warning) que un compilador pueda informar. Justifique.
   3. Escriba y justifique otro posible error pragmático. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   Antes de resolverlo, recordamos la sintáxis según la BNF de C de algunas de las sentencias es:

   La sentencia de Seleccción:
   ~<sentencia de seleccion> -> if(exp) <sentencia> | if(<exp>) <sentencia> else <sentencia> | switch(<exp>) <sentencia>~

   La sentencia de Expresión:
   ~<sentencia expresion> -> <exp>?;~

   La sentencia de salto:
   ~<sentencia de salto> -> continue; | break; | return <expresion>? | goto <identificador>;~
   #+END_QUOTE

   #+BEGIN_COMMENT
   <<DUDA>>: No estoy seguro si estará ok el de ungetc y getchar, la respuesta coincide con la resolución
   pero la misma sólo da la cantidad, no detalla
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1)
   Cant. de expresiones: 3
   1. dos expresiones en la primera sentencia, y en la subsentencia: ~if(exp1)return exp2~
   2. una expresión en la segunda sentencia: ~return exp3~
   
   Cant. de sentencias: 2, Cant de Subsentencias: 1
   1. sentencia de selección: ~if(0)return 1;~
   2. subsentencia (sentencia de salto) ~return 1;~
   3. sentencia de salto ~return 42;~

   Cant. de declaraciones: 0

   Cant. de invocaciones a ~ungetc~: seis
   |-------------------------+------------------------------------------------------------------------------|
   | Secuencia de caracteres | Motivo por el que el Scanner invocó al ~ungetc~                              |
   |-------------------------+------------------------------------------------------------------------------|
   | f(                      | ungetc por el ~(~ no pertenece al tipo de Token Identificador                |
   |-------------------------+------------------------------------------------------------------------------|
   | (0                      | ungetc por el ~0~ no pertenece al tipo de Token Caracter de Puntuación       |
   |-------------------------+------------------------------------------------------------------------------|
   | 0)                      | ungetc por el ~)~ no pertenece al tipo de Token Caracter de Constante Entera |
   |-------------------------+------------------------------------------------------------------------------|
   | )r                      | ungetc por la ~r~ no pertenece al tipo de Token Caracter de Puntuación       |
   |-------------------------+------------------------------------------------------------------------------|
   | 1;                      | ungetc por ~;~ no pertenece al tipo de Token Constante Entera                |
   |-------------------------+------------------------------------------------------------------------------|
   | 2;                      | ungetc por el ~;~ no pertenece al tipo de Token Constante Entera             |
   |-------------------------+------------------------------------------------------------------------------|

   Cant. de invocaciones a ~getchar~ para leer el lexema ~42~: tres
   |-------------------------+-------------------------------------------------------------------------------------------|
   | Secuencia de caracteres |                                                                                           |
   |-------------------------+-------------------------------------------------------------------------------------------|
   | ~4~                     | 1º invocación, lee la constante entera 4                                                  |
   |-------------------------+-------------------------------------------------------------------------------------------|
   | ~2~                     | 2º invocación, lee la constante entera 2                                                  |
   |-------------------------+-------------------------------------------------------------------------------------------|
   | ~;~                     | 3º invocación, cuando detecta el caracter de puntuación ~;~ sabe que terminó la secuencia |
   |-------------------------+-------------------------------------------------------------------------------------------|
   
   (2) Que el parámetro con identificador ~x~ no se está utilizando, en el cuerpo de la función
   
   (3) Que el comportamiento de ~f~ es retornar siempre 42, ya que la condición de if nunca se cumple al pasarle ~0~
   #+END_QUOTE
** Problema 15 (2019-12-18)
*** Enunciado
   #+BEGIN_SRC C
     /*1*/ int h(int x){
       /*2*/ int y=0;
       /*3*/ y=f(x);
       /*4*/ y=g(y);
       /*5*/ return y;}
   #+END_SRC
   
   #+BEGIN_QUOTE
   Considerando ~int f(int),g(int);~ con ~f~ y ~g~ definidas, analice la anterior función:
   
   1. Indique cuantas *sentencias* tienen la *sentencia compuesta* de la función ~h~.
   2. Analice la *sentencia* de la línea 3:
      1. Enumere cada operación realizada e indique la *precedencia*, uno es la menor.
      2. Escriba en renglones diferentes las *subexpresiones que tiene la expresión*
   3. El compilador emite en la línea tres el mensaje: “se asigna un valor que no es utilizado”.
      1. Si coincide con el mensaje categorice el tipo de error. Justifique.
      2. Proponga una solución para evitar el error. Justifique. 
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Cant. de sentencias del cuerpo de la función h: 3
   1. sentencia expresión: ~y=f(x);~ (/que contiene una expresión de asignación/)
   2. sentencia expresión: ~y=g(y);~ (/que contiene una expresión de asignación/)
   3. sentencia de salto ~return y;~

   (2) Las operaciones de la sentencia expresión ~y=f(x);~
   - La secuencia es
     1. Se invoca a la función ~f~ pasandole un parámetro ~x~ con ~f(x)~
     2. Se le asigna el retorno de ~f(x)~ a ~y~ con ~y=f(x)~
   - La precedencia de los operadores es
     1. precedencia=1 (menor prioridad) el ~=~ operador de asignación de un valor a una variable
     2. precedencia=2 (mayor prioridad) el ~()~ operador para invocar una función
   - Hay 4 subexpresiones en la expresión de asignación ~y=f(x)~
     1) ~y~ es una *expresión primaria* (si derivamos <expresión unaria> -> <expresion sufijo> -> <expresion primaria> -> <identificador>)
     2) ~f~ es una *expresión primaria* (por ser identificador)
     3) ~x~ es una *expresión primaria* (por ser identificador)
     4) ~f(x)~ es una *expresión sufijo* (por invocar una función)
      
   (3) Sería un *error pragmático*, y surje de la declaración del renglón 2 que inicializa ~y~ con el valor ~0~,
   ese valor no se utiliza, sólo se pisa con el resultado que devuelve ~f(x)~.
   Una posible solución sería reducir las sentencias en una única *sentencia de salto* ~return g(f(x));~
   #+END_QUOTE

   #+BEGIN_QUOTE
   Agregamos parte de la BNF de C, relacionada con ~y=f(x)~ ya que ésta es una *expresión de asignación*,
   si nos guíamos con la gramática de la BNF (reglás sintácticas de C) vemos que los identificadores ~y~, ~f~ y ~x~ son *expresiones primarias*
   ~<expresión unaria> --> <expresion sufijo> --> <expresion primaria> --> <identificador>~
   
   y que ~f(x)~ es una *expresión sufijo* 
   ~<expresión unaria> --> <expresion sufijo> --> <expresión sufijo> (<lista de argumentos>?)~
   
   <expresión de asignación> ->
     <expresión condicional> |
     <expresión unaria> <operador asignación> <expresión de asignación>
     
   <expresión unaria> ->
     <expresión sufijo> |
     ++ <expresión unaria> |
     -- <expresión unaria> |
     <operador unario> <expresión de conversión> |
     sizeof <expresión unaria> |
     sizeof (<nombre de tipo>)
     
   <expresión sufijo> ->
     <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --
     
   <expresión primaria> ->
     <identificador> |
     <constante> |
     <constante cadena> |
     (<expresión>)
   #+END_QUOTE
** [WAITING] Problema 16 (2019-12-18)
*** Enunciado
   #+BEGIN_QUOTE
   1. Indique el orden de las *etapas fuera y dentro del proceso de compilación*, donde uno (1) es la
      primera. Si no corresponde indíquelo con un guión:
      - Vinculación.
      - Análisis léxico.
      - Previnculación.
      - Análisis sintáctico.
      - Preprocesamiento.
      - Análisis semántico.
      - Generación de código
   2. Tilde todas las afirmaciones verdaderas acerca de C:
      - Una *definición de variable* implica reserva de memoria.
      - Una *declaración de variable* implica reserva de memoria.
      - Las *variables static (estáticas)* de tipo int se inicializan por defecto en cero cuando no tienen *inicializador explícito*
      - Las *variables static (estáticas)* definidas externamente (fuera de toda función) siempre son accesibles desde toda la UT.
      - Para compilar con éxito una *unidad de traducción (UT)* debe tener las *definiciones de todos los identificadores* que aparecen en la misma  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Chequear con alguien las respuestas 2.2, 2.4, y 2.5
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) etapas
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   |   | Nombre de etapa      | Realizada por | Descripción                                                                                               |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 1 | Preprocesamiento     | Preprocesador | Por el preprocesador, aplica las directivas (#if, #else, #define, #include, ...), remueve los comentarios |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 2 | Análisis léxico      | Compilador    | Lee la secuencia de caracteres de los archivos, los agrupa (lexemas) y los clasifica por tipo de TOKEN    |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 3 | Análisis sintáctico  | Compilador    | Recibe los TOKENs generados por el Analizador Lexico                                                      |
   |   |                      |               | Analiza si el conjunto de TOKENs se pueden derivar de las reglas sintácticas BNF de c                     |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 4 | Análisis semántico   | Compilador    | Recibe los Lexemas generados por el Analizador Lexico                                                     |
   |   |                      |               | Analiza el contexto (Ej. redeclaración, la invocación de una función coincide con su firma, ...)          |
   |   |                      |               | Analiza las reglas semánticas (Ej. el operando del operador [] debe ser una constante entera)             |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 5 | Generación de código |               | Los archivos fuente (.c) y archivos de cabecera (.h) en objetos (.o)                                      |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
   | 6 | Vinculación          | Linker        | El Linker/Enlazador enlaza los objetos (.o) con las bibliotecas externas, ...                             |
   |---+----------------------+---------------+-----------------------------------------------------------------------------------------------------------|
      
    No existe la etapa de Previnculación

   (2)
   1) VERDADERO, porque definir una variable implíca memoria. (Ej. ~int edad = 5;~)
   2) FALSO, porque declarar una variable no implíca reserva de memoria (Ej. declaramos una variable del tipo struct, ~struct {} a;~)
   3) VERDADERO, porque las variables ~static~ se inicializan en 0 por defecto, si no se inicializan explicitamente
   4) FALSO, porque las variables definidas ~static~ sólo se pueden usar (scope/ámbito) en el archivo fuente donde se definió,
      no en toda la (UT) *Unidad de Traducción* que está formado por uno ó varios .c con uno ó varios archivos .h
   5) FALSO, la (UT) puede tener sólo las declaraciones de los identificadores para compilar correctamente
   #+END_QUOTE
** [#A] Problema 17 (2019-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~char v[]="ABC";~ tilde todas las expresiones que sí son *ValorL*:
   
   1. v
   2. *v
   3. v+1
   4. v[3]
   5. v<v+1
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | v     | SI es un lvalue porque es una dirección de memoria, pero es un *lvalue NO MODIFICABLE* (/no podemos asignarle un valor ej. v=1/)    |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | v+1   | SI es un lvalue porque también es una dir. de memoria, pero es un *lvalue NO MODIFICABLE* (/mismo caso que con el identificador v/) |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | *v    | SI es lvalue, es una expresión de direccionamiento que apunta al primer elemento del arreglo es equivalente a ~v[0]~                |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | v[3]  | SI es lvalue, es una expresión de subindice [] que no evalúa al arreglo completo, es equivalente a ~*(v+3)~                         |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   | v<v+1 | NO es lvalue, porque devuelve una constante entera como resultado de la expresión                                                   |
   |-------+-------------------------------------------------------------------------------------------------------------------------------------|
   #+END_QUOTE
** [WAITING] [#A] Problema 18 (2019-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todos los conceptos que se pueden definir con el *BNF del LF Expresiones de C*:
   
   1. *Efecto de lado* de la expresión.
   2. *Precedencia* de los operadores.
   3. *Asociatividad* de los operadores.
   4. *Orden de evaluación* de los operandos.
   5. *Aridad* (cantidad de operandos) de los operadores
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Donde está definido el efecto de lado de C? En el MROC?
   
   <<DUDA>>: La asociatividad y la precedencia, indican el orden de las operaciones (osea la *Secuenciación*) ?

   <<DUDA>>: yo tenía anotado que...
   la SEMÁNTICA especifíca el orden de evaluación de los operandos ?
   y la SINTAXIS especifíca la asociatividad y precedencia de los operadores ?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) FALSO

   (2) VERDADERO

   (3) VERDADERO

   (4) FALSO, de los operadores
   
   (5) VERDADERO
   #+END_QUOTE
** Problema 19 (2019-09-24)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión: ~a[i]+s.m~      
   
   1) A nivel sintáctico: Enumere los *operadores* y su *precedencia* relativa en la expresión dada; cero es la menor precedencia:
   2) A nivel semántico: Escriba las declaraciones que hagan semánticamente correcta a la expresión:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1)  (a[i])  + (s.m)
   |-------------+----------|
   | Precedencia | Operador |
   |-------------+----------|
   |         0   | +        |
   |         1   | .        |
   |         1   | []       |
   |-------------+----------|
   #+END_QUOTE

   #+BEGIN_SRC C
     int i, a[10];
     struct { int m; } s;
   #+END_SRC
** Problema 20 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
   Sea la expresión ~++automata->finales[i]~
   
  1. Reescriba la *expresión* con *paréntesis redundantes* que expliciten la *precedencia y la asociatividad*
  2. Escriba las *declaraciones* para que sea *semánticamente correcta*
   #+END_QUOTE
*** Respuesta
  #+BEGIN_QUOTE
  | 1 | ++automata->finales[i]     |                                                                                    |
  |---+----------------------------+------------------------------------------------------------------------------------|
  | 2 | ++(automata->finales)[i]   | el ~->~ tiene más precedencia que los tres, accede al miembro del puntero a struct |
  |---+----------------------------+------------------------------------------------------------------------------------|
  | 3 | ++((automata->finales)[i]) | el ~[]~ tiene más precedencia que ~++~, accede al elemento del arreglo             |
  |---+----------------------------+------------------------------------------------------------------------------------|
  | 4 | ++((automata->finales)[i]) | el ~++~ es el de menor precedencia                                                 |

  Por tanto la expresión quedaría ~++ ( ( automata -> finales ) [i])~
  #+END_QUOTE

  #+BEGIN_SRC C
    // otra manera..: struct { int finales; } *automata;

    int i;
    struct Estado{ /*...*/ };
    struct { Estado* finales; } Automata;
    Automata* automata;
  #+END_SRC
** Problema 21 (2019-07-15)
*** Enunciado
   #+BEGIN_QUOTE
   Sea la declaración ~int x=3,y=7;~ analice la expresión ~y+=x++<=3~
   
   1. Enumere los tokens.
   2. Indique si tiene *efectos sobre variables*, en ese caso, descríbalos.
   3. Indique el *tipo y el valor de la expresión*
   #+END_QUOTE
*** Respuesta
  #+BEGIN_QUOTE
  (1) Tokens de ~y+=x++<=3~ son seis
  |--------+-------------------------------------|
  | lexema | tipo de token                       |
  |--------+-------------------------------------|
  | y      | identificador                       |
  | +=     | operador                            |
  | x      | identificador                       |
  | ++     | operador (incremento como postfijo) |
  | <=     | operador (relacional)               |
  | 3      | constante (entera)                  |
  |--------+-------------------------------------|

  (2) Los efectos que se producen en ~y+=x++<=3~ son
  | expresión | descripción del efecto producido                                                                    |
  |-----------+-----------------------------------------------------------------------------------------------------|
  | x++       | incrementa en 1 el valor de ~x~ luego de evaluar la expresión donde está contenida                  |
  | y+=x++<=3 | se incrementa el valor de ~y~ en 1, si el ~++~ estuviera como prefijo se mantendría el valor de ~y~ |
  |-----------+-----------------------------------------------------------------------------------------------------|

  (3) El resultado de evaluar ~y+=x++<=3~ es un dato del tipo entero, y su valor es 8
  1. y+=x++<=3
  2. y+=3<=3
  3. y+=1
  4. y=7+1
  5. y=8
  #+END_QUOTE
** Problema 22 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   Dado el siguiente fragmento de código C: ~x.1==1LU++LU~
   
   1. Enumere los *lexemas* en orden de aparición y separados por coma.
   2. Justifique si el fragmento es una *expresión sintácticamente correcta* o no.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: En la resolución dice que "luego del operador sufijo ~++~ no se espera una expresión",
   no se referirá a que no espera antes del operador una "constante real"?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Los lexemas de ~x.1==1LU++LU~ son
   | Lexema | Tipo de Token (no lo pide)                      |
   |--------+-------------------------------------------------|
   | x      | identificador                                   |
   | .1     | constante real (es double, porque no tiene ~f~) |
   | ==     | operador                                        |
   | 1LU    | constante entera (long unsigned)                |
   | ++     | operador                                        |
   | LU     | identificador                                   |

   (2) La expresión ~x.1==1LU++LU~ NO es sintacticamente correcta,
   porque al derivarla de las reglas sintácticas (BNF) luego del identificador ~x~ no se espera una constante real ~.1~,
   por lo cual el compilador arroja un error sintáctico y no sigue evaluando el resto de la expresión.
   #+END_QUOTE
** [WAITING] Problema 23 (2019-02-25)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente declaración: ~int var;~
   
   1. Lexicamente. ¿Cúantas invocaciones a ~getchar~ son necesarias para realizar su *análisis léxico*?
      Asuma que todas las invocaciones son exitosas y que la última retorna ~EOF~. Justifique.
   2. ¿Es semánticamente correcta? Justifique.
   3. Lexicamente y Sintacticamente, si se eliminan los espacios, ¿sigue siendo un *constructo sintáctico válido*? Justifique.
   4. Sintacticamente, si el *lexema* ~int~ se reemplaza por ~T~ ¿sigue siendo una *declaración*? Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: si los identificadores de las variables, funciones, comparten el mismo namespaces,
   porque si tengo una función y una variable con mismo identificador no rompe al compilar?

   <<DUDA>>: si los identificadores y las constantes de enumeración y los alias de tipo (typedef)
   comparten namespace porque no rompe al compilar?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Para la declaración ~int var;~ se necesitan 11 invocaciones a ~getchar~
   
   | Lexema  | Cant. invocaciones a ~getchar~ | Motivo                                                            |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | int     | 3 invocaciones                 | una invocacion por cada caracter                                       |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | espacio | 2 invocaciones                 | dos porque en la 1ra invocación hizo ungetc al no ser un Identificador |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | var     | 3 invocaciones                 | una invocacion por cada caracter                                       |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | ;       | (2 invocaciones                | dos porque en la 1ra invocación hizo ungetc al no ser un Identificador |
   |---------+--------------------------------+------------------------------------------------------------------------|
   | EOF     | (1 invocación                  |                                                                        |
   |---------+--------------------------------+------------------------------------------------------------------------|

   (2) Es semánticamente correcta, según el contexto apesar que sea sintácticamente correcta (se puede derivar de las reglas sintacticas de la BNF),
   - Es semánticamente incorrecta si... en el mismo *Scope/Ambito/Alcance* hay otra variable con el mismo identificador
   - Es semánticamente incorrecta si... en el *Espacio de Nombres* se repite el nombre

   (3) Si, Lexicamente sería un identificador ~intvar~ seguido de un Caracter de Puntuación ~,~
   y Sintácticamente pasaría de ser una *Declaración* a una *Sentencia Expresión* donde ~intvar~ es una *expresión primaria* (identificador)
   Suponemos que previamente se declaró una variable ~intvar~

   (4) Sintacticamente ~T var;~ sería correcto, suponiendo que previamente se usó un ~typedef~ para crear el alias ~T~
   a un tipo de dato ó estructura, y si seguiría siendo una *declaración*
   #+END_QUOTE
** Problema 24 (2019-02-25)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la expresión ~a.b[42].c~
   
   1. Enumere los operadores
   2. Escriba las *declaraciones* para que sea una *expresión* ~int~
   3. Resuelva el anterior ítem utilizando una sola *declaración*, que no use ~typedef~, y haga
   que el valor de expresión sea cero.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Los operadores de la expresión ~a.b[42].c~ son tres
   1. ~.~ (para acceder a un miembro de una estructura ó union)
   2. ~[]~ (para accedera un elemento de un arreglo)
   3. ~.~ (para acceder a un miembro de una estructura ó union)
   #+END_QUOTE

   #+BEGIN_SRC C
     // (2)
     struct B{ int c; };
     struct{ struct B b[42+1]; }a;

     // (3)
     struct{ struct { int c; }b[42+1]; }a = {0};
   #+END_SRC
** Problema 25 (2019-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la siguiente sección de código C: ~x=f(4)[2]~
   
   1. Indique cuantos ~ungetc~ son necesarios para detectar los *lexemas*
   2. Si es una *expresión sintáctimante correcta* escriba una *declaración* que la
      haga *semánticamente correcta*, si no, justifique.
   3. Escriba una *definición de f* que haga que la sección sea *semánticamente correcta*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Se necesita invocar cinco veces a ~ungetc~
   |--------------+----------------------------------------------------------------------------|
   | lexema leído | motivo para invocar ~ungetc~                                               |
   |--------------+----------------------------------------------------------------------------|
   | x=           | ungetc por el ~=~ no pertenece al token de los Identificadores             |
   |--------------+----------------------------------------------------------------------------|
   | =f           | ungetc por ~f~  no pertenece al token de los Operadores                    |
   |--------------+----------------------------------------------------------------------------|
   | f(           | ungetc por ~(~   no pertenece al token de los Identificadores              |
   |--------------+----------------------------------------------------------------------------|
   | 4)           | ungetc por ~)~  no pertenece al token de las constantes numericas enteras  |
   |--------------+----------------------------------------------------------------------------|
   | 2]           | ungtec por ~]~   no pertenece al token de las constantes numericas enteras |
   |--------------+----------------------------------------------------------------------------|
   #+END_QUOTE

   #+BEGIN_SRC C
     // (2)
     char x, *f(int);

     // (3) -> Solución semanticamente correcta
     char* f(int x){
       static char* palabra = "hola";
       return palabra + 1;
     }

     // (3) -> Solución semanticamente correcta, pero pragmaticamente dudosa
     char* f(int x){
       char* ptr; return ptr;
     }
   #+END_SRC
** [WAITING] Problema 26 (2019-02-11)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente declaración: ~int f ( int ) ;~

   1. A nivel léxico, indique cuantos *lexemas* tiene si se remueven todos los espacios:
   2. Escriba, con la mínima cantidad de *tokens*, una *sentencia semánticamente correcta* que use ~f~
   3. Escriba una *expresión* que use ~f~ pero que sea *semánticamente incorrecta*. Justifique: 
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Si el identificador de un arreglo porque apunta a una dirección de memoria
   se considera lvalue no modificable..
   
   el identificador de una función también apunta a una dir. de memoria, pero no es lvalue,
   por tanto sería una excepción a ser lvalue?
   Ej. Si f es una función entonces en estas expresiones f no es lvalue, no? f++; f=1;

   <<DUDA>>:
   porque las sig. definición, y la sentencia no arrojan error de tipo incompatibles?
   int x="hola";
   int f(int x){}; f("hola");
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Si a la declaración ~int f ( int ) ;~ le removemos los espacios,
   nos queda la siguiente sentencia expresión ~intf(int);~ que contiene 5 lexemas
   1. ~intf~ <-- identificador
   2. ~(~ <-- caracter de puntuación
   3. ~int~ <-- palabra reservada
   4. ~)~ <-- caracter de puntuación
   5. ~;~ <-- caracter de puntuación
   #+END_QUOTE

   #+BEGIN_SRC C
     // (2)
     // - sentencia expresión que usa la minima cant. de tokens (identificador y caracter de puntuación)
     // - la expresión que contiene es un identificador que representa la dir. de memoria de la variable `f`
     f;

     // (2)
     // otra alternativa, invocar la función pero.. usaríamos 2 tokens más
     f(0);


     // (3) - Las sig. sentencias contienen expresiones que son semanticamente incorrectas,
     // usando el contexto de que `f` es una función

     f++; // error semántico, f no es un lvalue
     f=1; // error semántico, f no es un lvalue
     f[0]; // error semántico, f no es un arreglo
     f.a; // error semántico, f no es un struct ó union
   #+END_SRC
** [WAITING] [#A] Problema 27 (2018-12-17)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión: ~a[i]=f(i)~
   1. Nivel léxico — Indique por lo menos tres *tokens* que no requieran ~ungetc~ para su detección
   2. Nivel sintáctico — Enumere los *operadores* y su *precedencia* relativa en la expresión dada; cero es la menor precedencia
   3. Nivel semántico — Escriba una *declaración* que haga *semánticamente correcta* a la expresión
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (1) la resolución dice que son: [, ], (, )
   pero yo detecté que era a,=,) y.. que algunos de los que menciona si requerían ungetc para ser detectados
   1. a[ <-- ungetc por [ <--
   2. [i <-- ungetc por i
   3. i] <-- ungetc por ] <--
   4. ]=f <-- ungetc por f
   5. f( <-- ungetc por ( <--
   6. (i <-- ungetc por i
   7. i) <-- ungetc por )
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (2) Los operadores de ~a[i]=f(i)~ son
   |----------+-----------------------|
   | operador |           precedencia |
   |----------+-----------------------|
   | =        | 0 (menor precedencia) |
   |----------+-----------------------|
   | []       |                     1 |
   |----------+-----------------------|
   | ()       |                     1 |
   |----------+-----------------------|
   #+END_QUOTE

   #+BEGIN_SRC C
     int i, a[10], f(int);
   #+END_SRC
** Problema 28 (2018-07-30)
*** Enunciado
   #+BEGIN_QUOTE
   2. Sea ~char a[]="SSL";~ tilde todas las *expresiones* que sí son *ValorL modificable*:
   1. ~a~
   2. ~a+1~
   3. ~a[3]~
   4. ~*(a+3)~
   5. ~*(3+a)~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO. La *expresión primaria* ~a~ es un valorL NO modificable
   porque no podemos evaluar la expresión de asignación ~a='z'~
      
   (2) FALSO. La expresión ~a+1~ es un valorL NO modificable,
   porque no podemos evaluar la expresión de asignación ~a+1='c'~
      
   (3) Verdadero. La expresión ~a[3]~ es un valorL modificable,
   por ser una expresión de [] con subindice que no declara un arreglo completo
   (Ej. podemos hacer a[3]="\0")
      
   (4) Verdadero. La expresión ~*(a+3)~ es un valorL modificable,
   se está desreferencia última posición del arreglo, que contiene el caracter especial '\0'
   que indica el fin de una cadena
      
   (5) Verdadero. La expresión ~*(3+a)~ se repite la situación anterior,
   ya que el operador ~+~ es conmutativo
   #+END_QUOTE
* Nivel Léxico
** Problema 1
*** Enunciado
   #+BEGIN_QUOTE
   Analizar la siguiente declaración: ~int f ( int ) ;~
   e indique cuantos *lexemas* tiene si se remueven todos los espacios:   
   #+END_QUOTE
*** Respuesta   
   #+BEGIN_QUOTE
   1. intf
   2. (
   3. int
   4. )
   5. ;
   #+END_QUOTE
** [WAITING] Problema 2 (2021-02-10) <- pendiente lex/flex
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas acerca del *análisis léxico*
    
    1. Es realizado por *lex/flex*
    2. Detecta a ~"hola\"~ como *léxicamente correcto*
    3. Reconoce a ~main~ como *palabra clave (keyword)*
    4. Puede generar un mismo *token* a partir de diferentes *lexemas*
    5. Puede diferenciar cuando un símbolo actúa como *operador, punctuator, ó separador* .
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (2) La secuencia de caracteres ~"hola\"~ no es léxicamente correcta,
   al usar el ~\~ se escapa las comillas dobles y las toma como un caracter común,
   para ser *literal cadena* los caracteres deben estar delimitadas entre comillas dobles
   
   (3) El *lexema* ~main~ NO es una *palabra reservada*,
   podríamos escribir la sig. declaración sin problema ~struct main{ int x; }~

   (4) A partir de diferentes *lexemas* (Ej. for, while, ...) puede generar el mismo TOKEN,
   Ej. for, while son lexemas diferentes pero se genera el mismo TOKEN (palabra reservada)
   
   (5) El *analizador léxico* no sabe si un símbolo actúa como *operador* ó *caracter de puntuación*,
   porque no sabe del contexto, ni la sintáxis del lenguaje.
   Este sólo lee caracter por caracter de una secuencia de caracteres
   según el contexto se podría saber si actúa como *punctuator* u *operador* pero.. el Scanner no sabe de eso.

   Notas:
   1) En C el scanner (analizador léxico) NO puede almacenar/buscar en la (TS) *tabla de símbolos*
   2) En LP simples, el analizador léxico podría almacenar/buscar en la (TS)
   #+END_QUOTE

   #+BEGIN_COMMENT
   <<DUDA>>: Las últimas dos preguntas, estarán ok?
   #+END_COMMENT
** [TODO] Problema 3 (2021-02-17) <- pendiente lex/flex
*** Enunciado
   #+BEGIN_QUOTE
   Indique todas las afirmaciones verdaderas sobre el *análisis léxico*:
   
   1. Lo puede realizar la salida de lex/flex.
   2. Utiliza *lexemas* para construir *tokens*.
   3. Detecta a ~'\''~ como *léxicamente correcto*
   4. Reconoce a ~printf~ como *palabra clave (keyword)*
   5. Detecta cuando el asterisco (*) actúa como *operador binario* o *unario*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (2) Verdadero. El *analizador léxico* lee una secuencia de caracteres, caracter por caracter
   y genera *lexemas*. Usa los *lexemas* para construir *tokens* (que usará el analizador sintáctico)

   (3) Verdadero. El Scanner lee el lexema ~'\''~ como una *constante caracter*,
   porque al usar el ~\~ escapa la comilla simple y lo interpreta como un caracter común
   
   (4) FALSO. El lexema ~printf~ NO es una *palabra reservada*,
   si lo fuera no podriamos realizar la siguiente declaración ~struct printf{ }~
   
   (5) FALSO. El Analizador léxico, no sabe del contexto ni sintáxis,
   por tanto no sabe si el operador ~*~ actúa como operador binario o unario,
   sólo sabe que es un operador
   #+END_QUOTE
** [WAITING] Problema 4 (2019-12-11)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis léxico*
   
   1. Puede implementarse con un *AF*
   2. Procesa su entrada caracter a caracter.
   3. ~s(printf)~ es siempre *léxicamente correcto*
   4. Un *lexema* dado puede generar diferentes *lexemas*
   5. Diferencia entre *identificadores* y *palabras clave (keywords)*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: Como justificar mejor la 4, 5 (?)
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) VERDADERO, el Scanner (analizador léxico) se puede implementar con un AF,
   donde la transición de un estado a otro depende de la secuencia de caracteres leídos
   
   (2) VERDADERO, porque el Scanner lee caracter a caracter

   (3) VERDADERO, porque ~s(printf)~
   - cada palabra pertenece a un LR de las Categorías Léxicas (Identificador, Operador, ...)
   - si clasificamos esos lexemas por tipo de Token tenemos identificador,punctuator,identificador,punctuator

   (4) FALSO, 

   (5) VERDADERO, son son distintos LRs
   #+END_QUOTE

   #+BEGIN_QUOTE
   Para tener de referencia, nos guiamos con la siguiente *Gramática Léxica* para los TOKENs
   
   <token> ->
     <palabra reservada> |
     <identificador> |
     <constante> |
     <literal de cadena> |
     <punctuator>
   
   <token de preprocesamiento> ->
     <nombre de encabezado> |
     <identificador> |
     <número de preprocesador>|
     <constante carácter> |
     <literal de cadena> |
     <punctuator> |
     cada uno de los caracteres no-espacio-blanco que no sea uno de los anteriores

   <palabra reservada> -> una de
      auto break case char const continue default do
      double else enum extern float for goto if
      int long register return short signed sizeof static
      struct switch typedef union unsigned void volatile while

   <identificador> -> <no dígito> | <identificador> <no dígito> | <identificador> <dígito>
     <no dígito> -> uno de _ a b c d e f g h i j k l m n o p q r s t u v
       w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
     <dígito> -> uno de 0 1 2 3 4 5 6 7 8 9
   #+END_QUOTE
** Problema 5 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis léxico*
   
   1. *Recibe lexemas* y *genera tokens*
   2. ~ungetc~ devuelve al flujo el último token leido.
   3. Un *token* puede ser generado por *diferentes lexemas*
   4. En C, ~prontf("hola")~, es siempre *léxicamente correcto*
   5. Se puede determinar el operador que representa el lexema asterisco (*).
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO, el Scanner recibe una secuencia de caracteras y genera tokens (para el Parser) y lexemas (para el analizador semantico)

   (2) FALSO, cuando el Scanner invoca el ~ungetc~, éste devuelve el último caracter leído,
   suponiendo que éste no pertenece al tipo de TOKEN de la secuencia de caracteres leidos que le precede

   (3) VERDADERO, un TOKEN del tipo Identificador podría ser generador por varios lexemas
   (Ej. estos tres lexemas edad, nombre, apellido son identificadores)

   (4) VERDADERO, ~prontf("hola")~ para el Scanner está formado por identificador,punctuator,literal cadena, punctuator
   porque lee caracter por caracter invocando ~getchar~ y por cada caracter que no pertenece a la gramática de la secuencia leida
   invoca a ~ungetc~ y continúa leyendo, por tanto reconoceria cada lexema

   (5) FALSO, el Scanner no sabe del contexto y no puede determinar que tipo de operador es
   el lexema asterisco ~*~ solo reconoce el tipo de TOKEN, en este caso operador
   #+END_QUOTE
** [WAITING] Problema 6 (2018-10-03)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente función: ~int f(void){return 1<*p++;}~
   1. Indique cuantos *tokens* hay
   2. Indique los tres *tokens* que pertenecen a un *LF infinito*
   3. Indique por lo menos tres *tokens* que no requieran ~ungetc~ para su detección
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (2) Los identificadores son LF infinitos porque apesar de que tiene un número finito de caracteres el alfabeto,
   se pueden tener un número infinito de palabras?

   <<DUDA>>: (2) Las constantes numéricas, son LF infinitos por lo mismo de arriba?

   <<DUDA>>: (3) porque la resolución dice que el (, ), no necesitan ungetc?
   1. f( <-- getchar f, getchar (, ungetc por (
   2. (v <-- getchar (, getchar v, ungetc por v
   3. d) <-- getchar d, getchar ), ungetc por )
   4. {r <-- getchar {, getchar r, ungetc por r
   5. 1< <-- getchar 1, getchar <, ungetc por <
   6. *p <-- getchar *, getchar p, ungetc por p
   7. p++ <-- getchar p, getchar ~++~, ungetc por ~++~
   
   yo había puesto... int, f, {
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (2) Los TOKENs de la sentencia compuesta que pertenecen a un LF infinito son:
   1. f -> Identificador
   2. 1 -> Constante numérica (entera)
   3. p -> Identificador
   
   (1) En ~int f(void){return 1<*p++;}~ hay 14 tokens
   | Lexema | Tipo de Token               |
   |--------+-----------------------------|
   | int    | Palabra Reservada           |
   |--------+-----------------------------|
   | f      | Identificador               |
   |--------+-----------------------------|
   | (      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | void   | Palabra Reservada           |
   |--------+-----------------------------|
   | )      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | {      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | return | Palabra Reservada           |
   |--------+-----------------------------|
   | 1      | Constante numérica (entera) |
   |--------+-----------------------------|
   | <      | Operador (relacional)       |
   |--------+-----------------------------|
   | *      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | p      | Identificador               |
   |--------+-----------------------------|
   | ++     | Operador                    |
   |--------+-----------------------------|
   | ;      | Caracter de Puntuación      |
   |--------+-----------------------------|
   | }      | Caracter de Puntuación      |
   |--------+-----------------------------|
   #+END_QUOTE
* Nivel Sintáctico
** [WAITING] Problema 1 (2021-03-10)
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas acerca del *Análisis Sintáctico*
    
    1. Recibe una *secuencia de tokens*
    2. Un *parser* diferencia *expresiones de sentencias*
    3. Puede detectar el error de variable no declarada.
    4. ~printf(main)~ es siempre *sintácticamente correcto*
    5. Aplica el *orden de evaluación* del *operador ternario* ~?:~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   El Parser no sabe si una variable fue declarada o no, porque no conoce el contexto
   (el analizador semántico si, por tanto si ocurriera sería un error semántico)
   #+END_QUOTE

   #+BEGIN_COMMENT
   <<DUDA>>: está ok esto?
   El *analizador sintáctico* recibe una secuencia de *TOKENS*
   (generados por el analizador léxico, pero los guarda el Parser en la TS TAbla de Simbolos (???) <- no?
   
   <<DUDA>>: está ok esto?
   El Parser diferencia entre *expresiones* y *sentencias*, porque es parte de las reglas sintácticas de la BNF de c <--- no?  (???)

   <<DUDA>>: está ok esto?
   la expresión ~printf(main)~ es sintácticamente correcta porque se puede derivar de la BNF de C,
   pero es semanticamente incorrecta porque la firma de printf espera una cadena de caracteres como primer argumento
   
   <<DUDA>>: está ok esto?
   C especifica que el *orden de evaluación del operador ternario* ~exp1 ? exp2 : exp3~ es de de izq. a derecha,
   el Parser evalúa de Izq a Der ó Der a Izq según la precedencia/asociatividad de los operadores en las
   reglas sintácticas de la BNF de c
   #+END_COMMENT
** [TODO] Problema 2 (2021-02-17) <- pendiente yacc/bison
*** Enunciado
   #+BEGIN_QUOTE
   Indique todas las afirmaciones verdaderas sobre el *análisis sintáctico*:
   
   1. Detecta un error en ~printf()~
   2. Recibe una *secuencia de caracteres*
   3. Lo puede realizar la salida de *yacc/bison*
   4. Puede diferenciar si un *token* se usa como *puntuación* u *operador*
   5. Puede detectar un error en la cantidad de argumentos usados al invocar una función.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) FALSO. Es un error semántico, que lo detecta el Analizador Semántico

   (2) FALSO. El analizador sintáctico recibe una secuencia de TOKENs (generados por el analizador léxico)

   (4) VERDADERO. En las reglas sintácticas de la BNF de C (ó constructos sintácticos)

   (5) FALSO. Es el analizador semántico, que chequea la cant. de argumentos de invocar una función,
   comparando con la firma de la función
   #+END_QUOTE

   #+BEGIN_COMMENT
   <<DUDA>>: La última estará ok (???)
   #+END_COMMENT
** [TODO] Problema 3 (2020-03-03)
*** Enunciado
   #+BEGIN_QUOTE
   1. Indique el valor de verdad de la siguiente afirmación y justifique:
      *La sintaxis de C especifica el orden de evaluación de los operandos* y *la precedencia de los operadores*
   2. Escriba un fragmento breve que sea sintáctimente válido tanto en C y como en C++, pero
      que tenga diferente semántica para cada LP.  
   #+END_QUOTE
*** Respuesta
** [TODO] Problema 4 (2020-02-12) (2020-02-18)
*** Enunciado
   #+BEGIN_QUOTE
   1. Ejemplifique brevemente un aspecto sintáctico en el cual el LP C es
      diferente a otro LP que usted conozca. Justifique.
   2. Indique y justifique el valor de verdad de la siguiente afirmación:
      Los LP C y C++ tienen la misma sintaxis.
   #+END_QUOTE
** [WAITING] [#A] Problema 5 (2019-12-11) <- pendiente PAS
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. Un *parser* procesa *expresiones*
   2. Un *PAS* puede invocar al *scanner*
   3. ~s(printf)~ es siempre *sintácticamente correcto*
   4. El *operador de acceso a miembro* ~(.)~ *es conmutativo*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (1) está ok la justificación?

   <<DUDA>>: (3) como la derivamos de la BNF?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) FALSO, procesa una secuencia de TOKENs (son lexemas, que el Scanner generó según las reglas léxicas de una secuencia de caracteres)
   
   (3) VERDADERO, la expresión ~s(printf)~ la podemos derivar de la BNF de C
   
   (4) FALSO, el operador ~.~ de acceso a miembro no es conmutativo,
   el operando de la derecha es el miembro al que se accederá del operando de la izquierda
   (/Ej. struct { int x, y; } pos; no es lo mismo pos.x que x.pos/)
   #+END_QUOTE

   #+BEGIN_QUOTE
   <expresión> ->
     <expresión de asignación> |
     <expresión> , <expresión de asignación>
     
   <expresión de asignación> ->
     <expresión condicional> |
     <expresión unaria> <operador asignación> <expresión de asignación>
     
   <operador asignación> -> uno de
     = *= /= %= += -= <<= >>= &= ^= |=

   <expresión unaria> ->
     <expresión sufijo> |
     ++ <expresión unaria> |
     -- <expresión unaria> |
     <operador unario> <expresión de conversión> |
     sizeof <expresión unaria> |
     sizeof (<nombre de tipo>)
     <expresión sufijo> ->

   <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --

   <expresión primaria> ->
     <identificador> |
     <constante> |
     <constante cadena> |
     (<expresión>)
   #+END_QUOTE
** [TODO] Problema 6 (2019-12-04) <- pendiente YACC
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. *Yacc* es un *parser*
   2. Un parser procesa una *secuencia de tokens*
   3. En C, ~prontf("hola")~ es siempre *sintácticamente correcto*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (2) VERDADERO, el Parser ó Analizador Sintáctico lee una secuencia de tokens (generados por el Scanner)

   (5) VERDADERO
   #+END_QUOTE
** [WAITING] Problema 7 (2019-02-11)
*** Enunciado
   #+BEGIN_QUOTE
   Indique con Verdadero/Falso los *conceptos asociados a la sintaxis*
   
   1. BNF.
   2. Orden de tokens.
   3. Valor-l modificable.
   4. Precedencia de operadores.
   5. Orden de evaluación de operandos  
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: En la (2) es Verdadero... sería el orden en que los recibe/lee?

   <<DUDA>>: la (3) y (5) esta ok la justificación?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   (1) Verdadero, la BNF contiene las reglas/constructos sintácticas del lenguaje

   (3) Falso, si un valorl es modificable o no, es a nivel semántico.

   (4) Verdadero, la sintaxis indica la precedencia de los operadores en la BNF.
   Más cerca está del axioma, menos es su precedencia(prioridad).

   (5) Falso, la sintaxis no especifíca el orden de evaluación de los operandos,
   pero si el de los operadores en la BNF.
   #+END_QUOTE
** [WAITING] Problema 8 (2018-10-03)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente función: ~int f(void){return 1<*p++;}~
   Dentro de la sentencia compuesta:
   1. Indique cuantas *declaraciones* hay
   2. Indique el *operador* con menor *precedencia*
   3. Indique cuántas *expresiones*, contando las *subexpresiones*, hay; por ejemplo 40+2 tiene tres expresiones
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (3) porque no consideró como expresiones a ~*p~ y ~1<*p~ ?
   la resolución solo dice que hay cinco.. 1, p, p++, *p++, 1<*p++
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) En la sentencia compuesta ~{return 1<*p++;}~ no hay declaraciones

   (2) Para la predencia operadores de ~{return 1<*p++;}~
   usamos paréntesis redundantes para identificar la precedencia de cada operador ~return 1 < ((*p)++)~
   
   |----------+-----------------------|
   | Operador | Precedencia           |
   |----------+-----------------------|
   | <        | 0 (menor precedencia) |
   | ++       | 1                     |
   | *        | 2 (mayor precedencia) |
   |----------+-----------------------|

   (3) Las expresiones que contiene la sentencia compuesta ~{return 1<*p++;}~ son siete
   1. 1  <-- es una *expresión primaria* (por ser constante numérica)
   2. p  <-- es una *expresión primaria* (por ser identificador)
   3. ~*p~ <-- es una *expresión unaria* (por ser el operador de indirección * un operador unario)
   4. *p++
   5. p++ <-- es una *expresión unaria* (al tener el operador ++ lo hace una expresión sufijo)
   6. 1<*p
   7. 1<*p++

   Nota: ~return~ es una *palabra reservada*, no forma parte de las expresiones
   #+END_QUOTE

   #+BEGIN_QUOTE
   Dejamos una parte de la BNF de las expresiones como referencia
   
   <expresión unaria> ->
     <expresión sufijo> |
     ++ <expresión unaria> |
     -- <expresión unaria> |
     <operador unario> <expresión de conversión> |
     sizeof <expresión unaria> |
     sizeof (<nombre de tipo>)
     
   <nombre de tipo> 
   
   <operador unario> -> uno de & * + - ~ !
   
   <expresión sufijo> ->
     <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --
     
   <expresión primaria> ->
     <identificador> |
     <constante> |
     <constante cadena> |
     (<expresión>)
   #+END_QUOTE
* Nivel Semántico
** Problema 1 (2021-08-04)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba *declaraciones* que hagan que la siguiente expresión sea *semánticamente válida* y que
   la expresión a la derecha de la asignación sea un *valor-l no modificable*
   
   ~c = a[1].b~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     int c;
     const struct { int b; } a[10]; // declaramos un vector 'a' del tipo de un struct anónimo

     // - la expresión a[1].b es un valor-l NO modificable
     // - es lvalue porque b es un miembro del struct a, y es un operando
     // válido para el operador de asignacion =
     // - no es modificable porque el struct lo impide, es de sólo lectura por ser const
     c = a[1].b;
   #+END_SRC
** Problema 2 (2021-03-10)
*** Enunciado
   #+BEGIN_QUOTE
    Indique todas las afirmaciones verdaderas acerca del *Análisis Semántico*
    
    1. Utiliza la *tabla de símbolos*
    2. Detecta un error en ~for-while~
    3. Puede _detectar argumentos faltantes_
    4. Debe detectar si una *variable se usa sin inicializar*
    5. ~struct S{struct S m;};~ puede ser *semánticamente correcto*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   El *Analizador Semántico* usa la *tabla de símbolos*

   En la expresión ~for-while~ el que encuentra error es el *Analizador sintáctico* (Parser),
   porque no se puede derivar usando las *reglas sintácticas de la BNF de C*
   
   Como el *analizador semántico* conoce el contexto, entonces puede revisar
   las firmas de las funciones y detectar si faltan o no argumentos,
   cuando son invocadas.
   #+END_QUOTE

   #+BEGIN_COMMENT
   <<DUDAS>>:
   No es responsabilidad del *analizador semántico* detectar si una variable se usa sin inicializar,
   pero si debe validar la redeclaración de una variable, ó redefinición de una función, por ej.
   
   la sentencia expresión ~struct S{struct S m;};~ NO es semánticamente correcta,
   porque... (?)
   #+END_COMMENT
** Problema 3 (2021-02-17)
*** Enunciado
   #+BEGIN_QUOTE
   Indique todas las afirmaciones verdaderas sobre el *análisis semántico*:
   
   1. Lee la *tabla de símbolos*
   2. Detecta un error en ~if()~
   3. Puede detectar el uso de una *variable no declarada*
   4. Debe detectar si una variable se declara pero no se usa.
   5. La declaración ~int v[5];~ es siempre *semánticamente correcta*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) Verdadero

   (2) Falso. Es un error sintáctico, se deduce al tratar de derivar la expresión
   usando la BNF de C

   (3) Verdadero. Si se utiliza en una expresión, y ésta no fue declarada previamente, es un error semántico

   (4) Falso.

   (5) Falso. Se debe evaluar el contexto donde fue declarada..
   Ej. No sería semánticamente correcta si ya fue declarada previamente una variable con el identificador ~v~
   #+END_QUOTE

   #+BEGIN_COMMENT
   La (4) es un warning que arroja el compilador,
   se necesita saber más detalle de eso?
   #+END_COMMENT
** Problema 4 (2019-12-11)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis semántico*
   
   1. Tiene en cuenta el contexto.
   2. Hay un *error semántico* en ~while++~
   3. Detecta errores de programación (bugs).
   4. Usa los *prototipos* para validar las invocaciones.
   5. ~s(printf)~ es siempre *semánticamente correcto*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) VERDADERO, en el Análisis Semántico se chequea el contexto (Ej. puede analizar si al invocar una función, ésta respeta su firma)

   (2) FALSO, ~while++~ es un *error SINTACTICO*,
   porque el Parser al derivar de la BNF sabe que luego del ~while~ no espera un operador ~++~

   (3) FALSO,

   (4) VERDADERO, en el Analisis Semántico se usa los prototipos para validar las invocaciones
   porque se tiene en cuenta el contexto

   (5) FALSO, ~s(printf)~ podría no ser *semanticamente correcto* si el prototipo de ~s~ es ~int s(int)~ ó ~int s(char)~
   pero sería válido si fuese ~int s()~ ó ~int s(int(*) (const char*, ...))~
   #+END_QUOTE
** Problema 5 (2019-12-04)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis semántico*
   
   1. Es parte del compilador.
   2. Detecta un error en ~printf("%d")~ <-- Ojo..!
   3. Vincula con las funciones de biblioteca.
   4. Detecta inconsistencias de tipo de dato.
   5. En C, ~prontf("hola")~ es siempre *semánticamente correcto*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) VERDADERO, es la 3º etapa (1ro léxico, 2do sintáctico, 3ro semántico)

   (2) FALSO, devuelve un valor basura

   (3) FALSO, es el Linker/Enlazador quien vincula con funciones de biblioteca

   (4) VERDADERO, el Analizador Semantico verifica si el operador espera un tipo especifico de operando
   (Ej. un error semántico sería ~int a[5];~  porque el operador ~[]~ espera una *constante entera* no una *constante real*)

   (5) FALSO, depende del contexto, ~prontf("hola")~ puede ser semánticamente incorrecto,
   si el prototipo de ~prontf~ espera otro tipo que no sea una cadena de caracteres
   #+END_QUOTE
** Problema 6 (2019-07-29)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba un ejemplo de una *expresión C* con por lo menos un *error semántico*. Justifique
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     // Tiene error semántico, porque al invocar printf debe coincidir con su prototipo
     // y espera al menos una cadena de caracteres como primer parámetro
     printf();

     printf(1); // error semántico, idem anterior

     // Tiene error semántico porque el `1` es una constante entera por tanto
     // no es un lvalue válido para el operador `++`
     1++;

     // Tiene error semántico porque se está declarado dos veces el mismo identificador
     // en el mismo scope/ámbito
     int a; char a;

     int n;
     n[0]; // error semántico porque `n` no es vector ni puntero

     char* opcion;
     switch(opcion); // error semántico porque `opcion` no es un entero

     struct {} X;
     X++; // error semántico, un `struct` no es un tipo válido como operando para `++`

     5 = 10; // el `5` no es un lvalue válido para `=`
   #+END_SRC
** [WAITING] [#A] Problema 7 (2019-07-15)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba un ejemplo de una *declaración C* con por lo menos un *error semántico*. Justifique.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Los dos de abajo son de la resolución, deberian estar bien, pero no son errores sintácticos?
   
   <<DUDA>>: ~int double valor;~ no es error sintactico? // <-- multiples tipos en los especificadores de tipo de la declaración (es int ó double, no ambos)
   
   <<DUDA>>: ~static auto int edad;~ no es error sintáctico? // <-- multiples clases de almacenamiento en el especificador de la declaración (es static ó auto, no ambos)
   #+END_COMMENT
   
   #+BEGIN_SRC C
     // redeclaración de un identificador en el mismo scope
     int a, a;
     struct {int x; int x;} X;

     // el tamaño del vector no es un tipo entero
     int b[0.5];
   #+END_SRC
** [#A] Problema 8 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   *Declare un arreglo* y luego dé un *ejemplo semánticamente correcto de valor-l NO MODIFICABLE*
   que use ese arreglo
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     int x[5];

     // las siguientes sentencias son semanticamente correctas,
     // y tienen expresiones lvalue NO MODIFICABLES

     x; // apunta a la dirección del principio de `x` pero no se le puede asignar un valor Ej. x=1

     x+1; // apunta a la dirección siguiente de fin del arreglo, pero tampoco se le puede asignar un valor
   #+END_SRC
** [WAITING] [#A] Problema 9 (2019-05-23)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la declaración ~struct{double x,y;}p;~ escriba una *expresión semánticamente incorrecta*
   utilizando como *operandos solo constantes (literales)* y los *identificadores* declarados en la
   anterior *declaración*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: El enunciado pide "como operandos constantes (literales) y en la resolución
   hace ~0=p.x+p.y~ dónde está la constante literal ahi..?
   #+END_COMMENT
   
   #+BEGIN_SRC C
     p.x="y";
     p.y="b";
   #+END_SRC
** Problema 10 (2018-12-17)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~int i=0,j=1,*p=&i;~ analice cada una de las siguientes *expresiones* y si es *semánticamente incorrecta* describa el error,
   si no escriba correcto:
   1) ~&i=&j~
   2) ~&p=&i~
   3) ~p=&i.j~
   3) ~p[0]==&i[0]~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   1) ~&i=&j~ <- error semántico, porque ~&i~ no es un lvalue
   2) ~&p=&i~ <- error semántico, porque ~&p~ no es un lvalue
   3) ~p=&i.j~ <- error semántico, al evaluar ~&i.~ porque ~&i~ no es un tipo struct, no es un operando válido para el operador ~.~
   4) ~p[0]==&i[0]~ <- error semántico al evaluar ~i[0]~ porque ~i~ no es un puntero ni tampoco un arreglo
   #+END_QUOTE
** [WAITING] [#A] Problema 11 (2018-12-10)
*** Enunciado
   #+BEGIN_QUOTE
   Indique cuál error no es detectable durante el análisis semántico:
   1. Redefinición de variable.
   2. Identificador no declarado.
   3. Desreferencia de puntero nulo.
   4. Asignación a expresión que no es l-value modificable.
   5. Demasiados argumentos con respecto a la declaración ó prototipo.
   6. Operador punto aplicado a expresión que no es estructura ni unión.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: La (2) según la resolución no se detectaen el analisis semántico, por que?
   Si se utiliza un identificador que no fue declarado, no es error semántico, porque debe analizar el contexto?
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) La redefinición de variable es un error detectable en el fase del Analisis Semantico,
   porque debe ver el contexto..

   (3) Desreferenciar un puntero nulo, también es un error que se detecta en el Analisis semántico
   porque debe conocer el contexto para saber si es nulo

   (4) La asignación a expresión que no es lvalue modificable, es un error que se detecta en la fase de Analisis semántico,
   Ej. chequea en el contexto si el operando izquierdo es const

   (5) Si no coincide la cantidad de argumentos entre la declaración y prototipo de una función,
   es un error que se detecta en el Analisis Semántico,
   porque al invocar la funcion, se revisa el prototipo de la misma.

   (6) Si la expresión no es estructura ni unión y se usa como operando del operador punto,
   se detecta como error en el Analisis semántico,
   porque debe ver en el contexto el tipo de dato del operando cuando se declaró
   #+END_QUOTE
** Problema 12 (2018-12-03)
*** Enunciado
   #+BEGIN_QUOTE
   Sea ~int i=1;void*p=&i;~ describa el *error semántico* en cada *sentencia* o escriba correcto si no lo hay:
   1. ~{ ++p; }~
   2. ~{ *p=i; }~
   3. ~{ double i=42; i=p*i; }~
   4. ~{ int *p=malloc(sizeof i); }~
   5. ~Describa el posible error pragmático de una de las sentencias.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_QUOTE
   (1) ~{ ++p; }~
   *NO se puede determinar al siguiente objeto al que apuntará el puntero*

   (2) ~{ *p=i; }~
   ERROR semantico, NO se puede desreferenciar un puntero a void..
   pero.. se puede castear puntero a un tipo y luego desreferenciar ese tipo (Ej. ~*(int*)p=i~ )

   3. ~{ double i=42; i=p*i; }~
   ERROR semántico, el operador binario ~*~ sólo opera con tipos ariméticos
   pero.. se podría primero desreferenciar el puntero (Ej. ~i=*p*i~)

   4. ~{ int *p=malloc(sizeof i); }~
   *MEMORY LEAK..* NO se puede liberar los recursos asignados al puntero luego de esa sentencia compuesta
   #+END_QUOTE
** Problema 13 (2018-10-03)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente función: ~int f(void){return 1<*p++;}~
   1. Agregue antes de la función una *declaración* que haga *semánticamente correcta* a la función
   2. Agregue antes de la función una *declaración* que haga *semánticamente incorrecta* a la función
   3. Justifique su anterior respuesta:
   #+END_QUOTE
*** Respuesta
   #+BEGIN_SRC C
     // (2) - Declaración que hace semánticamente correcta la definición de la función `f`
     int*p;

     // (2) # alternativa
     int i, *p=&i;


     // (3) - Declaración que hace semánticamente incorrecta la definición de la función `f`
     // - La hace incorrecta, porque declaramos a `p` como entero
     // y al evaluar `*p` arroja un error semántico ya que `p` no es puntero ni arreglo
     int p;

     // (3) # alternativa
     // - También la hace semanticamente incorrecta, porque un puntero a void
     // no se puede desreferenciar (a menos que se castee a un puntero a un tipo, previo a desreferenciar)
     void* p;
   #+END_SRC
* Errores de Compilación
** Mix
   #+BEGIN_SRC C
     printf("%d");  // OK, devuelve un valor basura

     struct{ } printf; // no produce error, `printf` no es una keyword
     struct{ } main; // no produce error, `main` no es una keyword

     int a(){ }
     a; // no produce error
     
     int b(int x){ return x; }
     b; // no produce error
     b('a'); // no produce error, porque 'a' es un caracter y representa un valor númerico de la tabla ascii
   #+END_SRC
** Errores Léxicos
** Errores Sintácticos
   #+BEGIN_QUOTE
   <sentencia> -> <sentencia expresión> | <sentencia compuesta> | <sentencia de selección> | <sentencia de iteración> | <sentencia etiquetada> | <sentencia de salto>
   
   <sentencia de selección> ->
     if (<expresión>) <sentencia> |
     if (<expresión>) <sentencia> else <sentencia> |
     switch (<expresión>) <sentencia>
     La expresión e controla un switch debe ser de tipo entero.
   
   <sentencia expresión> -> <expresión>? ;
   #+END_QUOTE
   
   #+BEGIN_SRC C
          // - no es error sintáctico porque se puede derivar de la BNF
          // - es error semántico, porque el prototipo de printf espera una cadena de caracteres como primer parámetro
          printf(main); 
          printf(); // idem que el anterior
          printf(printf); // idem que el anterior

     // ERROR sintáctico, al derivar de la BNF no espera el operador `-` seguido de la keyword `for`,
     for-while ;     
   #+END_sRC
** Errores Semánticos
   #+BEGIN_SRC C
     printf("%d"); // Ok, no produce error, imprime un valor basura
     
     // - NO es error semántico. Es error sintáctico, debe ser del tipo `while(exp) sentencia` ó `while(exp){ sentencia }`
     while++;

     // Es error semántico según el contexto, Ej. si fue declarada previamente en el mismo scope/ámbito
     int v[5];

     // Es error semántico según el contexto,
     // - ERROR semántico si el prototipo de s es `int s(char);`
     // - NO es error si el prototipo de s es `int s()`
     // - NO es error si el prototipo de es `s(int(*) (const char*, ...))`
     s(printf);


     // -----------------------------------------------------------------------------------------------------

     // - ERROR Semántico, porque tiene que ser del tipo `if(expresion)`
     if();

     // - estos otros no producen error porque son del tipo `if(expresion)`
     if(1); if(0.5); if('a'); if("abc"); // ok
     int* ptr; if(ptr); // ok
     int v[5]; if(v); // ok

     // -----------------------------------------------------------------------------------------------------

     // - ERROR Semántico, tipo de dato incompleto. NO es error sintáctico porque puede derivar
     struct S{struct S m;};

     // - No produce error, se declaró la estructura `P` y luego se declaró `x` que es del tipo `struct P`
     struct P{}; struct { struct P x; } p;

     // -----------------------------------------------------------------------------------------------------

     int b(int x){ return x; }
     b; // no arroja error, es una sentencia semanticamente correcta, que usa la minima cantidad de TOKENs
     b(0); // sentencia expresión
     b("hola"); // ERROR semántico, la invocación de `b` no coincide con su prototipo

     // -----------------------------------------------------------------------------------------------------

     prontf("hi"); // Es error semántico según el contexto, arroja error si el prototipo de `prontf` no coincide con su invocación

     // - es error semántico, porque el prototipo de printf espera una cadena de caracteres como primer parámetro
     printf(main);
     printf(); // idem que el anterior

               // -----------------------------------------------------------------------------------------------------

               // - La expresión `c = a[1].b` es semánticamente válida
               // - La expresión `a[0].b` es un lvalue NO MODIFICABLE
     int c;
     const struct { int b; } a[10];
     c = a[1].b;

     // -----------------------------------------------------------------------------------------------------

     // Alternativa #1 - No produce error semántico en `c=a[1].b`
     int c; struct { int b; } a[10];
     c = a[1].b; // no es error semańtico, por el contexto

     // Alternativa #2 - ERROR semántico en `c=a[1].b`
     // - porque `a` no es un arreglo del tipo struct
     int c, a;
     c = a[1].b; // ERROR semańtico, por el contexto
   #+END_SRC
* Tips
** Operador Vs Caracter de Puntuación
*** Ejemplo 1
   - Si te piden de ~f()+1~ los TOKENs (nivel léxico), tenés
     1) f  <-- identificador
     2) (  <-- caracter de puntuación
     3) )  <-- caracter de puntuación
     4) +  <-- operador
     5) 1  <-- constante numérica entera
   - Si te piden de ~f()+1~ los operadores, tenés
     1) ()
     2) +
*** Ejemplo 2
   - Si te piden de ~x[0]=1~ los TOKENs (nivel léxico), tenés
     1. x  <-- identificador
     2. [  <-- caracter de puntuación
     3. 0  <-- constante numérica entera
     4. ]  <-- caracter de puntuación 
     5. =  <-- operador
     6. 1  <-- constante numérica enteraaaa
   - Si te piden de ~x[0]=1~ los operadores, tenés
     1) []
     2) =
*** Ejemplo 3
   - Si te piden de la expresión ~a[i]+s.m~ los operadores, y su precedencia (siendo 0 la menor)
     1) + (precedencia=0)
     2) . (precedencia=1)
     3) [] (precedencia=1)
   - Si te piden de la expresión ~a[i]+s.m~ los TOKENs
     1) a  <-- identificador
     2) [  <-- caracter de puntuación
     3) i  <-- identificador
     4) ]  <-- caracter de puntuación
     5) +  <-- operador
     6) s  <-- identificador
     7) .  <-- caracter de puntuación (?)
     8) m  <-- identificador
** Categorias sintácticas
   - Las Categorías Sintácticas son las Declaraciones, Expresiones, Sentencias
   - Son generadas por (GICs) Gramáticas Independientes del Contexto, y presentan (LICs)

   #+BEGIN_SRC C
   // En el siguiente fragmento tenemos 2 sentencias de expresión, y 1 declaración
   
   int f;
   f+=42;
   f(); // error semántico, no se puede invocar una variable
   #+END_SRC
** GIC - Gramática BNF de C - Constructos/Categorías/Reglas Sintácticas
*** Declaración
   #+BEGIN_QUOTE
   <declaración> ->
     <especificadores de declaración> <lista de declaradores>?
   
   <especificadores de declaración> ->
     <especificador de clase de almacenamiento> <especificadores de declaración>? |
     <especificador de tipo> <especificadores de declaración>? |
     <calificador de tipo> <especificadores de declaración>?

   <lista de declaradores> ->
     <declarador> |
     <lista de declaradores> , <declarador>
     
   <declarador> ->
     <decla> |
     <decla> = <inicializador>
     
   <inicializador> ->
     <expresión de asignación> | /* Inicialización de tipos escalares */
     {<lista de inicializadores>} | /* Inicialización de tipos estructurados */
     {<lista de inicializadores> , }

   <especificador de clase de almacenamiento> -> uno de
     typedef static auto register extern
     * No más de un <especificador de clase de almacenamiento> puede haber en una declaración

   <especificador de tipo> -> uno de
     void char short int long float double signed unsigned
     <especificador de "struct" o "union">
     <especificador de "enum">
     <nombre de "typedef">
   
   <calificador de tipo> -> const | volatile
   
   <especificador de "struct" o "union"> ->
     <"struct" o "union"> <identificador>? {<lista de declaraciones "struct">} |
     <"struct" o "union"> <identificador>
     
   <"struct" o "union"> -> struct | union
   
   <decla "struct"> ->
     <decla> |
     <decla>? : <expresión constante>
   
   <decla> -> <puntero>? <declarador directo>
   
   <puntero> ->
     * <lista calificadores tipos>? |
     * <lista calificadores tipos>? <puntero>
   #+END_QUOTE
*** Expresión
   #+BEGIN_QUOTE
   <expresión> ->
     <expresión de asignación> |
     <expresión> , <expresión de asignación>
     <expresión de asignación> ->
     <expresión condicional> |
     <expresión unaria> <operador asignación> <expresión de asignación>
   
   <expresión condicional> ->
     <expresión O lógico> |
     <expresión O lógico> ? <expresión> : <expresión condicional>
     
   <operador asignación> -> uno de
     = *= /= %= += -= <<= >>= &= ^= |=
     
   <expresión O lógico> ->
     <expresión Y lógico> |
     <expresión O lógico> || <expresión Y lógico>
     
   <expresión Y lógico> ->
     <expresión O inclusivo> |
     <expresión Y lógico> && <expresión O inclusivo>
     
   <expresión O inclusivo> ->
     <expresión O excluyente> |
     <expresión O inclusivo> | <expresión O excluyente>
     
   <expresión O excluyente> ->
     <expresión Y> |
     <expresión O excluyente> ^ <expresión Y>
     
   <expresión Y> ->
     <expresión de igualdad> |
     <expresión Y> & <expresión de igualdad>
     
   <expresión de igualdad> ->
     <expresión relacional> |
     <expresión de igualdad> == <expresión relacional> |
     <expresión de igualdad> != <expresión relacional>
     
   <expresión relacional> ->
     <expresión de corrimiento> |
     <expresión relacional> < <expresión de corrimiento> |
     <expresión relacional> > <expresión de corrimiento> |
     <expresión relacional> <= <expresión de corrimiento> |
     <expresión relacional> >= <expresión de corrimiento>
     
   <expresión aditiva> ->
     <expresión multiplicativa> |
     <expresión aditiva> + <expresión multiplicativa> |
     <expresión aditiva> - <expresión multiplicativa>
     
   <expresión multiplicativa> ->
     <expresión de conversión> |
     <expresión multiplicativa> * <expresión de conversión> |
     <expresión multiplicativa> / <expresión de conversión> |
     <expresión multiplicativa> % <expresión de conversión>
     
   <expresión de conversión> ->
     <expresión unaria> |
     (<nombre de tipo>) <expresión de conversión>
     
   <expresión unaria> ->
     <expresión sufijo> |
     ++ <expresión unaria> |
     -- <expresión unaria> |
     <operador unario> <expresión de conversión> |
     sizeof <expresión unaria> |
     sizeof (<nombre de tipo>)
     
   <nombre de tipo> 
   
   <operador unario> -> uno de & * + - ~ !
   
   <expresión sufijo> ->
     <expresión primaria> |
     <expresión sufijo> [<expresión>] | /* arreglo */
     <expresión sufijo> (<lista de argumentos>?) | /* invocación */
     <expresión sufijo> . <identificador> |
     <expresión sufijo> -> <identificador> |
     <expresión sufijo> ++ |
     <expresión sufijo> --
     
   <expresión primaria> ->
     <identificador> |
     <constante> |
     <constante cadena> |
     (<expresión>)
   #+END_QUOTE
*** Sentencia
   #+BEGIN_QUOTE
   <sentencia> ->
     <sentencia expresión> |
     <sentencia compuesta> |
     <sentencia de selección> |
     <sentencia de iteración> |
     <sentencia etiquetada> |
     <sentencia de salto>
   
   <sentencia expresión> ->
     <expresión>? ;
   
   <sentencia compuesta> ->
     {<lista de declaraciones>? <lista de sentencias>?}
     
   <lista de declaraciones> ->
     <declaración> |
     <lista de declaraciones> <declaración>
     
   <lista de sentencias> ->
     <sentencia> |
     <lista de sentencias> <sentencia>
     - La sentencia compuesta también se denomina bloque.

   <sentencia de selección> ->
     if (<expresión>) <sentencia> |
     if (<expresión>) <sentencia> else <sentencia> |
     switch (<expresión>) <sentencia>
     La expresión e controla un switch debe ser de tipo entero.
   
   <sentencia de iteración> ->
     while (<expresión>) <sentencia> |
     do <sentencia> while (<expresión>) ; |
     for (<expresión>? ; <expresión>? ; <expresión>?) <sentencia>
     
   <sentencia etiquetada> ->
     case <expresión constante> : <sentencia> |
     default : <sentencia> |
     <identificador> : <sentencia>
     Las sentencias case y default se utilizan solo dentro de una sentencia switch.
     
   <sentencia de salto> ->
     continue ; |
     break ; |
     return <expresión>? ; |
     goto <identificador> ;
     - La sentencia continue solo debe aparecer dentro del cuerpo de un
     ciclo. La sentencia break solo debe aparecer dentro de un switch
     o en el cuerpo de un ciclo. La sentencia return con una expresión
     no puede aparecer en una función void.
   #+END_QUOTE 
* Etapas compilación
** [TODO] Problema 1 (2019-07-29)
   #+BEGIN_QUOTE
   Indique cuál es la entrada a la parte (o proceso) de *síntesis de un compilador*
   #+END_QUOTE
** [WAITING] [#A] Problema 2 (2019-07-15)
*** Enunciado
   #+BEGIN_QUOTE
   Indique las *fases de la parte de análisis de un compilador*
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   Me parece que te falta desarrollar un poco más...
   <<DUDA>>: En el *análisis sintáctico* se especifica el orden de evaluación de los OPERADORES?
   si tienen igual precedencia, se evalúa por asociatividad ?

   <<DUDA>>: En el análisis semántico, que tiene de entrada? lexemas?

   <<DUDA>>: En el análisis semántico se verifica las restricciones en (LN) de la BNF,
   y también de la (GSC) que la BNF no puede representar?

   <<DUDA>>: En el *MROC* aparecen las *restricciones* sobre los constructos definidos
    en la "Sintaxis" y que la BNF ó una GIC no podría representar de forma clara?
   #+END_COMMENT
   
   #+BEGIN_QUOTE
   1. Análisis Léxico (Scanner)
      - recibe y procesa una secuencia de caracteres, los agrupa en lexemas y clasifica por tipo de TOKENs
   2. Análisis Sintáctico (Parser)
      - recibe y procesa una secuencia de TOKENs, analiza si cumplen con las reglas sintácticas de la BNF
      - verifica la precedencia y asociatividad de los operadores
      - sólo entiende TOKENs (son LRs, generados por GRs)
      - se especifíca la precedencia y asociatividad de los OPERADORES
   3. Análisis Semántico
      - se especifíca el orden de evaluación de los OPERANDOS
   #+END_QUOTE
** [WAITING] Problema 3 (2018-07-30)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto al proceso de compilación:
   1) Detecta errores semánticos.
   2) Incluye un backend y un front end.
   3) Incluye una etapa de vinculación (link).
   4) Incluye una etapa de preprocesamiento.
   5) Incluye una etapa de análisis y otra de síntesis.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: (2) la resolución dice que es verdadera (?)

   <<DUDA>>: (5) sintesis? 
   UN fragmento del apunte de ferreiros..
   "la segunda etapa del compilador — la Síntesis — y del programa objeto que se obtiene, como hemos visto en el capítulo 
   anterior, aunque éstos no sean temas para profundizar en este libro. "

   Otro fragmento del apunte de ferreiros..
   ArchivoFuente (.c) -> Analisis (Léxico, Sintáctico, Semántico) -> Sintesis -> Ensamblado -> Enlazado -> ArchivoEjecutable (.exe)
   #+END_COMMENT

   #+BEGIN_QUOTE
   (1) Verdadero. La última etapa del proceso de compilación es el *Analisis Semántico*,
   y en este se detectan los *errores semánticos*

   (3) FALSO. La etapa de vinculación es externa al compilador,
   la realiza el Linker/Enlazador para generar el ejecutable (.exe ó .out)
   a partir de los objetos (.o) generados a partir de los archivos fuente (.c) y archivos de cabecera (.h).

   (4) FALSO. La etapa preprocesamiento, es externa al compilador,
   la realiza el Preprocesador de C, que remueve los comentarios, y aplica las directivas (#define, #if, #include, ...)
   #+END_QUOTE
** Problema 4 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
   V/F? En un programa la línea ~#include <stdio.h>~ permite vincularlo (link) con la biblioteca estándar.
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: está ok lo del preprocesador?
   #+END_COMMENT

   #+BEGIN_QUOTE
   FALSO. El Linker/Enlazador no recibe la cabecera.
   La directiva ~#include~ es analizada por el *Preprocesador de C*, éste se encarga de las directivas
   #+END_QUOTE
* Lenguajes Formales
** Conceptos básicos
*** Relación con la BNF de C
**** Conceptos
   - Si X es (LR) => por definición es posible escribir una (GIC) que lo genere => es posible escribir una BNF que lo defina
**** Declaraciones
   - No son (LR) por tener *paréntesis balanceados*
   - En C se definen con notación BNF, que se puede representar con (LIC)
**** Constantes enteras
   - Las constantes enteras sin sufijo se pueden representar con la (ER) ~0(0+1+2+3+4+5+6+7)*~
**** Sentencias
* Regex
** [TODO] Problema 1 (2020-10-14)
   #+BEGIN_QUOTE
   Analice la siguiente expresión C: ~s.a[s.i]~
   
    Puede esta *expresión* considerarse una *regex*? Justifique
   #+END_QUOTE
** [WAITING] Problema 2 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
   Escriba la regex resultante de la intersección entre las *constantes enteras decimales de C*
   y el LF representado por la regex ~[0-9]*|a~
   #+END_QUOTE
*** Respuesta
   #+BEGIN_COMMENT
   <<DUDA>>: La resolución dice ~[1-9][0-9]*~ por que...?
   yo había puesto ~[0-9]*~ ya que es lo único que tienen en común...

   y que la Regex de las Constantes Decimales de C: [1-9]+[0-9]*
   #+END_COMMENT

   #+BEGIN_QUOTE
   #+END_QUOTE
* [TODO] Lex
** Problema 1 (2018-07-30)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas con respecto al archivo de entrada de Lex.
   1) Puede contener reglas.
   2) Puede contener acciones.
   3) Puede contener condiciones.
   4) Puede contener partes en lenguaje C.
   5) Puede contener partes en notación RegEx
   #+END_QUOTE
** Problema 2 (2018-06-07)
*** Enunciado
   #+BEGIN_QUOTE
   Tilde la afirmación falsa con respecto a lex:
   1) Entiende *regex*
   2) Genera un *scanner*
   3) Es un *analizador léxico*
   4) Su salida es un programa.
   5) Su entrada es un archivo con reglas.
   #+END_QUOTE
* [TODO] Yacc/Bison
** Problema 1 (2019-12-11)
*** Enunciado
   #+BEGIN_QUOTE
   Dada la siguiente gramática:
   E → E + T | T
   T → T * F | F
   F → 1 | 2 | 3
   
   Indique si las siguientes afirmaciones son verdaderas o falsas y justifique su respuesta   
   1. Puede ser implementada directamente, es decir, sin aplicar ninguna transformación a la gramática, por *Yacc/Bison*
   #+END_QUOTE
** Problema 2 (2018-12-10)
*** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente gramática en BNF tipo Yacc, donde + y Entero son tokens:
   Expresión
   : Expresión "+" Entero
   l Entero
   ;
   
   1. Indique si es LL(1) o no; si es justifique, si no, reescríbala para que sí sea:
   2. Indique si el lenguaje generado es regular o no, justifique:
   3. Escriba las reglas Lex para los dos tokens:
   #+END_QUOTE
* [WAITING] Automatas
** Ejemplo 1
*** Problema
   #+BEGIN_SRC c
     while( EOF != (c=getchar()) ){
       switch(state){
       case INICIAL:
         switch(c){
         case 'a':
           state=INICIAL;
           continue;
           // ...
         }
         // ...
       }
      }
   #+END_SRC
   
   #+BEGIN_QUOTE
   Asuma que el anterior fragmento es parte de la implementación de una *máquina de estado*, responda
   considerando sólo la parte presentada:
   
   1) Indique el *tipo de máquina de estado*. Justifique.
   2) Indique a qué conjunto pertenece ~INICIAL~
   3) Indique a qué conjunto pertenece ~a~
   4) Escriba la o las *transiciones* que representa.
   5) Escriba una *ERX* análoga.
   6) Escriba una *producción* análoga.
   #+END_QUOTE
* Diagramas
** Automatas
** [TODO] Arboles sintácticos
*** Problema 1 (2020-10-14)
**** Enunciado
   #+BEGIN_QUOTE
   Analice la siguiente expresión C: ~s.a[s.i]~
   
   Nivel sintáctico
   1. Indique *la raíz y las hojas* del *árbol de expresión*
   2. Escriba todas las *subexpresiones de la expresión*
   #+END_QUOTE
*** Problema 2 (2019-12-18)
**** Enunciado
   #+BEGIN_SRC C
     /*1*/ int h(int x){
       /*2*/ int y=0;
       /*3*/ y=f(x);
       /*4*/ y=g(y);
       /*5*/ return y;}
   #+END_SRC

   #+BEGIN_QUOTE
   Analice la *sentencia* de la línea 3, dibuje el *árbol asociado a la expresión*
   #+END_QUOTE
*** Problema 3 (2019-12-11)
**** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. En un *árbol de derivación*, los nodos internos son variables.
   #+END_QUOTE
*** Problema 4 (2019-12-04)
**** Enunciado
   #+BEGIN_QUOTE
   Tilde todas las afirmaciones verdaderas acerca del *análisis sintáctico*
   
   1. En un *árbol de derivación*, las hojas son *tokens*
   2. En C, la expresión ~a+b+c~ tiene un único *árbol de derivación*
   #+END_QUOTE
*** Problema 5 (2019-12-04)
**** Enunciado
   #+BEGIN_QUOTE
   Dibuje el *árbol de expresión* para ~f(x).a[i]~
   #+END_QUOTE
