* Pruebas en C
** Probando 1
#+BEGIN_SRC C
  #include <stdio.h>
  #include <ctype.h>
  #include <stdlib.h>
  #include <string.h>

  int main(){
          int *ptr1 = malloc(sizeof(int));
          int* const ptr2 = malloc(sizeof(int));
          // el ptr2 si lo pasamos a cadena de caracteres, sería similar a lo siguiente
          // char* const palabra = "hola"; // <-- no puede cambiar su dirección de memoria
          // char palabra[30] = "hola"; // <- se reservó memoria en stack, no puede cambiar
          const int *ptr3 = malloc(sizeof(int));
          int numero2= 2, numero3= 3;

          ,*ptr1 = 1;
          printf("ptr1: %d\n", *ptr1);

          ,*ptr1 = numero2;
          printf("ptr1: %d\n", *ptr1);

          ptr1 = &numero3;
          // free(ptr1); // <-- este free tiraría error, porque ahora apunta al stack
          printf("ptr1: %d\n", *ptr1);

          ,*ptr2 = numero2;
          printf("ptr2: %d\n", *ptr2);

          // - esto arrojaría error, porque al declarar ptr2 dijimos que
          // no puede apuntar a otra dirección de memoria..
          // - int* const ptr2: ptr2 es una constante del tipo puntero a entero
          // (no puede cambiar la dirección de memoria)
          // - const int* ptr1: ptr1 es un puntero a entero que es constante 
          // (no puede cambiar el valor)
          //
          // ptr2 = &numero2;

          // diferencias???
          const int n1 = 5; // constante entera, no se puede modificar su valor después
          int const n2 = 5; // apunta a 5, y no puede cambiar su dirección x tanto tmpc su valor
          // ambos darán error "asignación a variable de sólo lectura"
          //n1 = 2; 
          //n2 = 1;

          // --------------------------------------------------------------------

          char* cadena = malloc(sizeof(char)*100);
          char* palabra = "hola";
          // si no me equivoco.. los dos de abajo son lo mismo, no pueden cambiar su dirección en memoria
          // char* const palabra = "hola";
          // char palabra[30] = "hola";

          char *aux1=palabra, *aux2=palabra, *aux3=palabra;
          // errores xd
          //char aux1=malloc(sizeof(char)*100), aux2=malloc(sizeof(char)*100),aux3=malloc(sizeof(char)*100);
          //*aux1=palabra, *aux2=palabra, *aux3=palabra;

          // alternativa #1:
          // - while: ejecuta mientras el valor al que apunta aux1 no sea FIN de cadena
          // - printf: sólo imprime el valor al que referencia aux2
          // - aux2++: avanza a la sig. dirección usando arimética de punteros
          // (avanza a la sig. dirección, saltando N bytes como el tamaño de sizeof(char))
          printf("aux2: ");
          while(*aux2 != '\0') printf("%c", *aux2), aux2++; // <- usamos el , quedando una sentencia expresion
          //while(*aux2 != '\0'){ printf("%c", *aux2); aux2++; } // <- si usaramos sentencia compuesta
          aux2='\0';
          printf("\n");

          // alternativa #2:
          // - while: idem alternativa (1)
          // - printf: imprime el valor al que referenia aux1 y avanza a la sig. dirección
          printf("aux1: ");
          while(*aux1 != '\0') printf("%c", *aux1++);
          aux1='\0';
          printf("\n");

          // alternativa #3:
          // - while: itera mientras el puntero referencia a un valor, cuando sea NULL se detiene
          // - printf y aux3++ igual que los anteriores
          printf("aux3: ");
          while(*aux3){ printf("%c", *aux3), aux3++; }
          printf("\n");

          printf("\n");
          // aux1,aux2,aux3 apuntan a null... si queremos que devuelvan el string original
          // podriamos hacer que vuelvan a apuntar a la dirección de "palabra" si... (???)
          printf("aux1=%s, aux2=%s\n", aux1, aux2);
          free(aux1), free(aux2);
          //free(0); // <-- (???) no arroja error
          printf("palabra=%s\n", palabra);
          //*cadena++ = 'a';

          // --------------------------------------------------------------------

          int c;
          int i = 0;
          // mientras no sea un digito, le permite escribir
          // ó getc(stdin)
          char texto[500];

          while(!isdigit(c = getchar())){
                  //puts(c);
                  //*cadena++=c;
                  texto[i]=c;

                  //fprintf(stdout, "%c", c);
                  //
                  //fflush(stdin); // no es necesario...?
                  i++;
          }

          ungetc('#', stdout);
          printf("texto=%s\n", texto);

          return 0;
  }
#+END_SRC
** Probando 2
   #+BEGIN_SRC C
     #include <stdio.h>

     int main(void){
       int menor = 10;
       int mayor = 500;

       printf("valor=%d\n", menor ++> mayor); // lo interpreta: (menor++) > mayor
       printf("valor=%d\n", menor >++ mayor); // lo interpreta: menor > ++mayor
       printf("valor=%d\n", menor ++>++ mayor); // lo interpreta: menor++ > ++mayor
       // printf("valor=%d\n", menor++++); // ERROR sintáctico lvalue (menor++)++  
       // printf("valor=%d\n", menor+++++mayor); // ERROR sintáctico lvalue (menor++)++ + mayor

       printf("valor=%d\n", menor+++mayor); // lo interpreta: menor++ + mayor

       printf("valor=%d\n", menor --> mayor); // lo interpreta: (menor--) > mayor
       printf("valor=%d\n", (10-1) > 500); // sería lo mismo que esto

       printf("valor=%d\n", menor --< mayor); // lo interpreta: (menor--) < menor
       printf("valor=%d\n", (10-1) < 500); // sería lo mismo que esto



       printf("menor=%d, mayor=%d\n", menor, mayor);

       return 0;
     }
   #+END_SRC
** Probando 3
   #+BEGIN_SRC C
     #include <stdio.h>
     #include <stdlib.h>
     #include <string.h>

     struct { int finales[3]; } automata1;
     struct { int* finales; } *automata2;

     struct {int x, y;} posicion;
     int main(){
             int arr[5];
             arr;
             //arr = 5;
             //arr[0] = 1;

             posicion.x = 5, posicion.y=10;
             printf("x=%d, y=%d\n", posicion.x, posicion.y);

             int const numero;
             // numero = 5;

             /*
             static int pepe;
             auto int pope;
             // static auto int pape;

             //int double valor;
             int _5;
             _5 = 2;

             int a,b,c;

             a=1,b=1;

             c = &a == &b ? b : a;

             printf("c=%d\n", c);

             printf("condicion 2 = %d\n", (0 == 1) ? 0 : 1); // 1
             printf("condicion 1 = %d\n", (0 == 0) ? 0 : 1); // 0

             printf("condicion 2 = %d\n", 0 == 1 ? 0 : 1); // 1
             printf("condicion 1 = %d\n", 0 == 0 ? 0 : 1); // 0

             printf("condicion 3 = %d\n", 2 ? 0 : 1); // 0
             printf("condicion 4 = %d\n", -1 ? 0 : 1); // 0
             ,*/

             /*
             automata1.finales[0] = 10;

             automata2 = malloc(sizeof(automata2));
             automata2->finales = malloc(sizeof(int)*3);
             automata2->finales[0] = 10;
             automata2->finales[1] = 6;

             printf("automata1.finales[0]=%d\n",automata1.finales[0]);
             //printf("automata2->finales[0]=%d\n",automata2->finales[0]);
             printf("automata2->finales[0]=%d\n", *(automata2->finales));
             printf("automata2->finales[1]=%d\n", *(automata2->finales+1));

             ++automata2->finales;
             ,*/

             char* cadena = malloc(sizeof(char)*4); // 3char + 1 (por el \0)
             strcpy(cadena, "ABC");

             /*
             printf("cadena=%s\n", cadena);

             cadena++; // cadena++; != cadena+1; (el segundo no es arimética de ptr)
             printf("cadena=%s\n", cadena);

             //cadena+1 = 'm';
             printf("p=%p, p+1=%p\n", cadena, cadena+1);
             printf("cadena=%s\n", cadena);
             ,*/

             free(cadena);

             // -----------------------------------------------

             char v[] = "ABC"; // <- v[3] tiene NULL osea \0

             printf("%p\n", v);
             printf("%p\n", v+1);
             printf("%p\n", v+2);
             printf("%c\n", v+1);

             //v+1 = 'm';

             v<v+1;

             /*
             printf("v[2] = %p\n", v[2]);
             printf("v[2] = %c\n", v[2]);
             printf("v[2] = %c\n", *(v+2));

             printf("v[] = %s\n", v);

             printf("*v: %c\n", *v);

             v+1;
             //v+1 = 'm';
             // v++; // <- no se puede no es lvalue, a menos que haga char* v;
             printf("*v: %c\n", *v);

             ,*v = 'z'; // es lo mismo que v[0] = 'z';
             printf("*v: %c\n", *v);

             printf("v[] = %s\n", v);

             //v+1 = 'z';
             ,*/

             return 0;
     }
   #+END_SRC
** Probando 4
   #+BEGIN_SRC C
     #include <stdio.h>

     /*
     // alternativa #1

     // - declaramos una variable X del tipo estructura anónima,
     // porque no tiene identificador (se agrega luego de struct)
     // - no nos permite agregar otra sentencia creando un arreglo de 
     // esta estructura anónima, porque no tiene nombre
     // (X es el una variable del tipo struct, no es el struct en si)
     //
     // struct { int y; } X, Y[50]; <- podemos declarar un arreglo, pero con otro identificador que no sea X
     struct { int y; } X;

     // - declaramos una estructura "B" (identificador)
     // - declaramos una variable "Y" del tipo "struct B"
     // - podemos agregar otra sentencia declarando un arreglo "struct Y[50]"
     struct B{ int c; } Y;

     ,*/

     // -----------------------------------------------------------------

     struct B{ int c; }; // Ojo! no es lo mismo que struct { int c; } B;
     struct {struct B b[50]; } a;

     // alternativa #2
     //typedef struct { int c; } B;
     //struct { B b[50]; } a;

     // alternativa #3
     //struct { struct {int c;} b[50]; } a;
     // struct { struct { int c; } b[50]; } a;

     struct {
             // static int z;
     } Z;

     struct M{ int n; }; // declaramos la estructura llamada M
     struct M m; // declaramos una variable m del tipo M

     // interesante...!
     struct { struct{ int x, y; }posicion[50]; } posiciones={0};

     int main(){
             posiciones.posicion[40].x = 5;
             posiciones.posicion[40].y = 2;
             printf("posiciones.posicion[40].x=%d\n", posiciones.posicion[40].x);
             printf("posiciones.posicion[40].y=%d\n", posiciones.posicion[40].y);

             printf("posiciones.posicion[50].x=%d\n", posiciones.posicion[50].x);
             printf("posiciones.posicion[50].y=%d\n", posiciones.posicion[50].y);
             printf("\n\n");
             // a.b[40].c = 5;
             // printf("a.b[40].c=%d\n\n", a.b[40].c);

             int LU = 2;
             int a = 0;
             //a = 1LU++LU;

             printf("a=%d\n", a);
             a+++1;
             printf("a=%d\n", a);
             a++ +1;
             printf("a=%d\n", a);

             float x = 5001, y = .1, z=0LU;

             printf("x=%f\n", x);
             printf("x=%.2f\n", x);
             printf("x=%5.2f\n", x);

             printf("\n");

             printf("y=%f\n", y);
             printf("y=%.2f\n", y);
             printf("y=%3.2f\n", y);

             return 0;
     }
   #+END_SRC
** Probando 5
   #+BEGIN_SRC C
     #include <stdio.h>

     // - Scope: dentro de la definición de la función test()
     void test(void){
       struct { int x; } m;  // <- "m" es el identificador del struct
       // int m; // <-- Error semántico.! identificadores comparten namespaces

       enum {A,B} letras;
       // int A; // <-- Error semántico.! enum e identificadores comparten namespaces
     }

     // - Scope: Unidad de traducción (generado por el .c + .h)
     enum {A,B} letras;

     int main(void){
       // tag: test1
      test1: return 1; // etiqueta "test1"

       // etiqueta "test2"
      test2:
       return 2;

       return 0;
     }
   #+END_SRC
** Probando 6
   #+BEGIN_SRC C
     #include <stdio.h>

     int* f2(int x){ int *p; return p; }

     int* f3(int x){
       static int i = 0;
       i = 5 + x;

       // - si retornamos &x arrojará warning,
       // por devolver la dirección de una var local que
       // deja de existir cuando se termina de evaluar esta función
       // - si retornamos una variable "static" no hay problema
       // porque su ciclo de vida finaliza con el programa
       return &i;
     }

     char* f1(int x){
       static char* palabra = "hola";
       return palabra+x;
     }

     int main(void){
       char* x = f1(2);
       printf("palabra: %s\n", x);

       int* p = f2(5);
       p = f3(0);

       return 0;
     }
   #+END_SRC
** Probando 7
   #+BEGIN_sRC C
     #include <stdio.h>

     int f(int x){ return x; }
     int f2(int x, int y){ return x; }

     enum {INICIAL=1, FINAL} state;

     const struct {int x; int y;} Posicion[10];
     struct {const int x; const int y;} Position[10];

     typedef int EDAD, NUMERO;

     struct { int edad; } pedro;

     int main(void){
             pedro = 1 < 1;

             {1+1;}; 5;

             int m = {9}; // se le asigna 9
             {m=0;}; // se lo cambiamos a 0
             printf("m=%d\n", m);

             int n = {9+1}; +5; 0+0; {1+2;}; // se le asigna 9+1,
             printf("n=%d\n", n);

             int a,b,c;
             a=b=c=1;
             {a=b=c=2;};
             printf("a=%d, b=%d, c=%d\n", a , b , c);

             NUMERO primero = 5;
             EDAD edad = 11;
             unsigned x;
             x = -1;
             printf("x=%d\n", x);

             printf("0<0<-1 = 0<-1 = %d\n", 0<0<-1);
             printf("0>-1 = %d\n", 0>-1);

             printf("2<0<1 = (2<0)<1 = 0<1 = %d\n", 2 < 0 < 1); // stdout = 1
             printf("2<0<0 = (2<0)<0 = 0<0 = %d\n", 2 < 0 < 0); // stdout = 0
             printf("3<2<1 = (3<2)<1 = 0<1 = %d\n", 3 < 2 < 1); // stdout = 1
             printf("\n");

             /*
             // l value no modificable
             Posicion[0].x = 0;
             Posicion[0].y = 0;

             // l value no modificable
             Position[0].x = 0;
             Position[0].y = 0;
             ,*/

             // -------------------------------------------------

             // int EOF = 1;
             int letra;
             letra = 'a';
             printf("letra=%c\n", letra);
             printf("sizeof(int)=%d, sizeof(char)=%d\n", sizeof(int), sizeof(char));

             printf("state=%d\n", state);
             state = INICIAL;
             printf("state=%d\n", state);
             state = FINAL;
             printf("state=%d\n", state);

             // -------------------------------------------------

             f; // <- sólo arroja warning de que no tiene efecto esa declaración
             f, f2;
             f(2);

             printf("%d\n", f(10));

             return 0;
     }
   #+END_SRC
** Probando 8
   #+BEGIN_sRC C
     #include <stdio.h>

     int main(void){
       char nombre[10] = "hol\";

       // empieza por 1
       for(int i=1; i < 5; i++) printf("%d ", i);
       printf("\n");
       // empieza por 1
       for(int i=1; i < 5; ++i) printf("%d ", i);

       printf("\n");

       int x,y,z; x=y=z=0;

       // incrementa x en 1, luego que la expresión y=x sea evaluada
       y = x++, printf("x=%d, y=%d\n", x, y);
       printf("x=%d\n", x);
       // incrementa x en 1, antes que la expresión z=x sea evaluada
       z = ++x, printf("x=%d, z=%d\n", x, z);
       /*
         int a=0, b=a++, c=a++;
         printf("a=%d, b=%d, c=%d\n", a,b,c);
         printf("a=%d, b=%d, c=%d\n", a,b,c);
       ,*/

       printf("\n");
       return 0;
     }
   #+END_SRC
** Probando 9
   #+BEGIN_SRC C
     #include <stdio.h>

     int true(int x){
             printf("true: %d\t", x); return 1;
     }
     int false(int x){
             printf("false: %d\t", x); return 0;
     }
     int sumar(int x, int y){ return x+y; }

     int main(void){
             false(0) || false(1) && false(2); // exp1 || exp2 => 0
             printf("\n");

             true(0) || false(1) < false(2); //  exp1 <-- no llega a evaluarse exp2<exp3
             printf("\n");

             false(0) || false(1) < false(2); // exp1 || exp2 < exp3 => 0
             printf("\n");

             printf("1+1*2=%d\n", 1+1*2); // exp1+(exp2*exp3) => exp1+exp4 => 3

             printf("\n------------------------------------\n\n");
             // ---------------------------------------------------

             for(int i=0,a=0,b=0; i < 10; a+=2, b+=3, i++) printf("i=%d, a=%d, b=%d\n", i, a, b);

             printf("\n------------------------------------\n\n");

             char cadena[50] = "hola", cadena2[50]="chau", *aux;

             aux = cadena;
             printf("cadena=%s, aux=%s\n", cadena, aux);
             printf("cadena=%s, aux[0]=%c\n", cadena, aux[0]);
             printf("cadena=%s, aux=%s\n", cadena, ++aux);

             aux = cadena;
             printf("cadena=%s, aux=%s\n", cadena, (++aux, ++aux, ++aux));


             aux=cadena;
             printf("aux=%s\n", aux);
             // 1) desreferenciamos la 1ra dirección del puntero a caracteres (el 1º caracter)
             // 2) desreferenciamos la 2da dirección del puntero a caracteres (el 2º caracter)
             ,*(aux+0) = 'x', *(aux+1) = 'x';
             // En vez de "hola" imprimirá "xxla"
             printf("aux=%s\n", aux);
             // como el ptr 'aux' apuntaba a 'cadena', tenía la misma dirección de memoria
             // por tanto los cambios en aux, afectaban a cadena
             printf("cadena=%s, aux=%s\n", cadena, aux);

             int numbers[10] = {2, 4, [2 ... 9] = 0};
             for(int i=0; i < 10; i++) printf("%d ", numbers[i]);
             printf("\n");

             // arr[3]={[0 ... 2]=0} es equivalente a arr[0]=0, arr[1]=0, arr[2]=0;
             int numeros[5] = {[0 ... 2]=0, [3 ... 4]=1}; // equivale a numeros[5]={0,0,0,1,1}
             for(int i=0; i < 5; i++) printf("%d ", numeros[i]);
             printf("\n");


             aux=cadena;
             for(int i=0; *aux=cadena[i]; i++, aux++) printf("%c, ", *aux);
             //for(int i=0; *aux++=cadena[i]; i++, aux++) printf("%c, ", *aux);
             printf("\n");

             int i;
             for(i=0, aux=cadena; *aux; *aux++=cadena[i], i++) printf("%c, ", *aux);

             //while(*aux++) printf("%c, ", *aux); printf("\n");
             //printf("cadena=%s, aux=%s\n", cadena, aux);

             printf("\n------------------------------------\n\n");
             // ---------------------------------------------------

             aux = cadena2;
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             for(int i=0; *aux=cadena2[i]; i++, aux++) printf("%c, ", *aux);
             printf("\n");

             // - como en el for hacíamos aux++ avanzabamos a
             // a la sig. dirección del bloque al que hace referencia (cadena2)
             // - terminado el for, aux apuntará a la última dirección de cadena2, osea al fin de cadena
             // por tanto no imprimirá nada
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             //*aux--='y'; // es equivalente a *(aux--)='y'

             // si hacemos +aux-- apuntamos a la dirección anterior de cadena2,
             // osea retrocedemos al caracter anterior de fin de cadena
             // *aux--; // equivale a *(aux--);
             //printf("cadena2=%s, aux=%s\n", cadena2, aux);

             // - cuando avanzamos aux++ en realidad avanzamos en el array cadena1, pero en aux
             // - avanzamos aux a la sig. dirección que apunta de cadena2, desreferenciamos y le asignamos
             // el caracter 'z' (osea cambiamos el valor a cadena2, no al puntero)
             ,*aux++='z'; // es equivalente a *(aux++)='z'
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             // *(aux++)='y' no es equivalente a aux++,*aux='y'
             // - al ptr le asignamos el caracter 'y' (esto genera efecto en cadena2 también)
             //aux++, *aux='y';
             ,*aux='y';
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             // cambiamos el valor al que apunte ptr (genera efecto sobre cadena2 también)
             ,*aux='m';
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             ,*(aux++)='Z';
             printf("cadena2=%s, aux=%s\n", cadena2, aux);

             printf("\n------------------------------------\n\n");
             // ---------------------------------------------------

             1+1, 2||2, 1||printf("a"), 0|printf("b"), 'a', 1, printf("\n");


             // usamos la ',' como operador, para agrupar expresiones
             printf("%d\n", (1,2,10)); // stdout 10, usa la ultima subexp que evaluó

             // usamos la ',' como caracter de puntuación para separar expresiones
             // (por lo general para pasar parámetros a una función)
             sumar(1,2);

             // usamos la ',' como operador y caracter de puntuación
             // - usamos los '(',')' como operador para agrupar las subexpresiones 1,2,10
             // en una expresion y evitar que arroje error semántico por no coincidir con la firma de la función
             // - del 2do parámetro se evaluará cada subexpresión, 
             // pero sólo la última que será que se pasará por parametro a la función
             sumar(1, (1,2+1,'a', "abc", printf("omg\n"),10)); 
             return 0;
     }
   #+END_SRC
** Probando 10
   #+BEGIN_SRC C
     #include <stdio.h>
     #include <string.h>

     struct{char*a;int i;}s1,s2;
     struct{char* a;float i;}m1;

     int main(void){
             char _; _ = 'a';
             printf("_=%c\n", _);

             char __;
             // la expresión del 2do parámetro, se evalúan las subexpresiones de izq a der.
             // 1) se evalúa la expresión de asignación __='b'
             // 2) se evalúa la expresión de asignación __='c'
             // 3) se evalúa la expresión lógica __ < 0 (el valor del identificador __ es el de la tabla ascii)
             // 4) se evalúa la expresion __ (identificador)
             //
             // del 2do parámetro las expresiones son agrupadas por el operador () y , (coma)
             // se evalúan de izq a der. y sólo la última será la que usará printf como 2do parámetro
             printf("__=%c\n", (__='b', __='c', __ < 0, __)); // todo ok, sin errores

             printf("\n");
             // -----------------------------------------------

             int a=15, b=0xF, c=017, z=0L;
             printf("15(entero decimal)=%d\n", a);
             printf("0xF(entero hexadecimal)=%d\n", b);
             printf("017(entero octal)=%d\n",c);
             printf("0L (entero, long)=%d\n", z); // <- decimal u octal (???)
             printf("\n");

             float d = .1, f=10., g=10.50, h;
             printf(".1 (numero real con precisión simple)=%f=%.2f=%2.1f\n", d);
             printf("10. (numero real con precisión simple)=%2.3f\n", f);
             printf("10.50 (numero real con precisión simple)=%.1f\n", g);
             printf("\n");

             double i; // precisión doble
             // -----------------------------------------------

             // esto es un doble puntero, (char**) un array de strings
             // capacidad hasta 2 strings, 
             // no limitamos la longitud de los strings
             char* cadena1[2] = {"hola", "chau"};
             printf("cadena1[0]=%s, cadena1[1]=%s\n",
                     cadena1[0], cadena1[1]);
             //strcpy(cadena[0], "hola");
             //char* cadena[10] = "hola";
             //cadena = "hola";

             // este otro también es un doble puntero (const char **) ???
             // pero limitamos la long. de los strings a 30 caracteres
             char cadena2[2][30] = {"hola", "chau"};
             printf("cadena2[0]=%s, cadena2[1]=%s\n",
                     cadena1[0], cadena1[1]);
             // -----------------------------------------------

             s1.a = "hola", s1.i = 0;
             //m1.a = "hola", m1.i = 0;

             printf("s1.a=%s, s1.i=%d, s1.a[s1.i]=%c\n",
                     s1.a, s1.i, s1.a[s1.i]);

             //printf("m1.a=%s, m1.i=%d, m1.a[m1.i]=%c\n",
             //      m1.a, m1.i, m1.a[m1.i]);

             return 0;
     }
   #+END_SRC
** Probando 11
   #+BEGIN_sRC C
     #include <stdio.h>

     int main(void){
       // al evaluar esta sentencia compuesta, no evalúa el resto del código
       // {return 0;} 

       void x(); // mmh

       void *a=NULL, *b=(int*)5;

       (void) 1; 2 + 1, 2+a;
       1+NULL;

       printf("3+a=%d\n", 3+a); // 3+NULL = 3

       printf("3+a=%d\n", (a=(int*)5, 3+a)); // a=5 => 3+5 = 8

       // el NULL lo toma como 0 (?)
       printf("2+NULL=%d\n", 2+NULL); // 2+NULL = 1
       printf("9+\'\\0\'=%d\n", 9+'\0'); // 9+'\0'= 9

       printf("2+b=%d\n", 2+b); // 3+5 = 8

       // mmmh...
       printf("%d, %d, %d\n", (int*)b, 1+(int*)b, sizeof(int));

       return 0;
     }
   #+END_SRC
** Probando 12
   #+BEGIN_SRC C
     #include <stdio.h>
     #include <stdlib.h>

     //struct { S s;}S;
     //struct S{ struct S x; };

     struct P{}; struct { struct P x; } p;

     int a(){}; //int(*)() = &a; // anda

     struct { int b; } arr[10];
     const struct { int b; } vector[10];

     void s(int(*) (const char*, ...)){ }

     int sumar(){}

     struct { int x; } X;

     struct PE{ int *x; } *pe;
     struct { int x[10]; int y[10]; } po = {0};

     int main(){
             pe = malloc(sizeof(struct PE));
             pe->x = malloc(sizeof(int));
             ,*pe->x = 50;
             ,*(pe->x) = 40; // `->` mas precedencia que `*`
             printf("pe->x = %d\n", *(pe->x)); // `->` mas precedencia que `*`
             printf("pe->x[0]=%d\n", pe->x[0]);
             printf("++pe->x[0]=%d\n", ++pe->x[0]); // prioridad: ->, [], ++

             printf("\n\n");

             printf("po.x[0]=%d \t ++po.x[0]=%d\n", po.x[0], ++po.x[0]);
             printf("po.y[0]=%d \t po.y[0]++=%d\n", po.y[0], po.y[0]++);
             //5 = 1; if(1);
             //5=1;
             //X++;

             //char* opcion;
             //switch(opcion);

             int n =0;
             n++;
             //n[0];

             char* palabra = "hola";
             //palabra = 'a';

             char cadena[] = "ABC";
             cadena[0] = 'a';
             ,*cadena = 'a';
             ,*(cadena+0) = 'a';
             //cadena = 'a';
             //cadena+1 = 'a';

             sumar + 5;
             printf("%p\n", sumar);
             //printf("%d %s %c");

             s(printf);
             a(printf);

             printf;
             // while(1) printf;

             int c = vector[0].b;
             a;

             arr[1].b = 5;
 
             printf;

             if(1);
             if(1) 2;
             if(0.5);
             if('a');
             if("aa");
             int* ptr; if(ptr);
             int v[5]; if(v);

             printf("hola\n");

             return 0;
     }
   #+END_SRC
* Referencias
  1. https://www.tenouk.com/cpluscodesnippet/chardecimalhexoctal.html
  2. https://slidetodoc.com/parsing-tools-introduction-to-bison-and-flex-1/
